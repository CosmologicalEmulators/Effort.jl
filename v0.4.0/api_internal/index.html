<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API · Effort.jl</title><meta name="title" content="Internal API · Effort.jl"/><meta property="og:title" content="Internal API · Effort.jl"/><meta property="twitter:title" content="Internal API · Effort.jl"/><meta name="description" content="Documentation for Effort.jl."/><meta property="og:description" content="Documentation for Effort.jl."/><meta property="twitter:description" content="Documentation for Effort.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Effort.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Effort.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../api_external/">External API</a></li><li class="is-active"><a class="tocitem" href>Internal API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Neural-Networks"><span>Neural Networks</span></a></li><li><a class="tocitem" href="#EFT-Commands"><span>EFT Commands</span></a></li><li><a class="tocitem" href="#Projection"><span>Projection</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Internal API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/main/docs/src/api_internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This section documents the functions intended for internal usage by the package.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Effort.AbstractComponentEmulators"><code>Effort.AbstractComponentEmulators</code></a></li><li><a href="#Effort.AbstractPℓEmulators"><code>Effort.AbstractPℓEmulators</code></a></li><li><a href="#Effort.ComponentEmulator"><code>Effort.ComponentEmulator</code></a></li><li><a href="#Effort.PℓEmulator"><code>Effort.PℓEmulator</code></a></li><li><a href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a></li><li><a href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a></li><li><a href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a></li><li><a href="#Effort._P_obs"><code>Effort._P_obs</code></a></li><li><a href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a></li><li><a href="#Effort._Pkμ"><code>Effort._Pkμ</code></a></li><li><a href="#Effort._akima_spline"><code>Effort._akima_spline</code></a></li><li><a href="#Effort._akima_spline_legacy"><code>Effort._akima_spline_legacy</code></a></li><li><a href="#Effort._cubic_spline"><code>Effort._cubic_spline</code></a></li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._quadratic_spline"><code>Effort._quadratic_spline</code></a></li><li><a href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a></li><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP_check</code></a></li><li><a href="#Effort.get_Pℓ_jacobian"><code>Effort.get_Pℓ_jacobian</code></a></li><li><a href="#Effort.get_component"><code>Effort.get_component</code></a></li><li><a href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a></li><li><a href="#Effort.load_component_emulator"><code>Effort.load_component_emulator</code></a></li><li><a href="#Effort.load_multipole_emulator"><code>Effort.load_multipole_emulator</code></a></li></ul><h2 id="Neural-Networks"><a class="docs-heading-anchor" href="#Neural-Networks">Neural Networks</a><a id="Neural-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-Networks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.AbstractComponentEmulators" href="#Effort.AbstractComponentEmulators"><code>Effort.AbstractComponentEmulators</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractComponentEmulators</code></pre><p>Abstract type for component-level emulators that represent individual parts of the power spectrum calculation (e.g., P11, Ploop, Pct).</p><p>All concrete subtypes must implement the necessary fields to enable neural network evaluation, normalization, and postprocessing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/neural_networks.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.ComponentEmulator" href="#Effort.ComponentEmulator"><code>Effort.ComponentEmulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComponentEmulator &lt;: AbstractComponentEmulators</code></pre><p>A complete emulator for a single power spectrum component, combining neural network predictions with normalization and physics-based postprocessing.</p><p><strong>Fields</strong></p><ul><li><code>TrainedEmulator::AbstractTrainedEmulators</code>: The trained neural network (Lux or SimpleChains).</li><li><code>kgrid::Array</code>: Wavenumber grid on which the component is evaluated (in h/Mpc).</li><li><code>InMinMax::Matrix{Float64}</code>: Min-max normalization parameters for inputs (n_params × 2).</li><li><code>OutMinMax::Array{Float64}</code>: Min-max normalization parameters for outputs (n_k × 2).</li><li><code>Postprocessing::Function</code>: Function to apply physics transformations to raw NN output.</li></ul><p><strong>Details</strong></p><p>The typical evaluation flow is:</p><ol><li>Normalize input parameters using <code>InMinMax</code>.</li><li>Evaluate neural network to get normalized output.</li><li>Denormalize output using <code>OutMinMax</code>.</li><li>Apply postprocessing (e.g., multiply by D² for P11).</li></ol><p><strong>Example Postprocessing</strong></p><pre><code class="language-julia hljs"># For linear power spectrum component
postprocess_P11 = (params, output, D, emu) -&gt; output .* D^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/neural_networks.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.get_component" href="#Effort.get_component"><code>Effort.get_component</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_component(input_params, D, comp_emu::AbstractComponentEmulators)</code></pre><p>Evaluate a component emulator to obtain power spectrum component values.</p><p><strong>Arguments</strong></p><ul><li><code>input_params</code>: Array of input parameters (e.g., cosmological parameters).</li><li><code>D</code>: Growth factor at the redshift of interest.</li><li><code>comp_emu::AbstractComponentEmulators</code>: The component emulator to evaluate.</li></ul><p><strong>Returns</strong></p><p>A matrix of shape <code>(n_k, n_samples)</code> containing the evaluated power spectrum component values on the emulator&#39;s k-grid.</p><p><strong>Details</strong></p><p>This function performs the full evaluation pipeline:</p><ol><li>Copy input parameters to avoid mutation.</li><li>Apply min-max normalization to inputs.</li><li>Run neural network inference.</li><li>Denormalize network output.</li><li>Apply component-specific postprocessing (using <code>D</code> and emulator metadata).</li><li>Reshape to match k-grid dimensions.</li></ol><p>The postprocessing step typically includes physics-based transformations such as scaling by powers of the growth factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/neural_networks.jl#L46-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.AbstractPℓEmulators" href="#Effort.AbstractPℓEmulators"><code>Effort.AbstractPℓEmulators</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPℓEmulators</code></pre><p>Abstract type for complete power spectrum multipole emulators.</p><p>Concrete subtypes must combine multiple component emulators (P11, Ploop, Pct) with bias models to compute full power spectrum multipoles <span>$P_\ell(k)$</span> for <span>$\ell \in \{0, 2, 4\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/neural_networks.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.PℓEmulator" href="#Effort.PℓEmulator"><code>Effort.PℓEmulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PℓEmulator &lt;: AbstractPℓEmulators</code></pre><p>Complete emulator for power spectrum multipoles in the Effective Field Theory of Large Scale Structure (EFTofLSS) framework.</p><p><strong>Fields</strong></p><ul><li><code>P11::ComponentEmulator</code>: Emulator for the linear theory power spectrum component.</li><li><code>Ploop::ComponentEmulator</code>: Emulator for the one-loop corrections.</li><li><code>Pct::ComponentEmulator</code>: Emulator for the counterterm contributions.</li><li><code>StochModel::Function</code>: Function to compute stochastic (shot noise) terms.</li><li><code>BiasCombination::Function</code>: Function mapping bias parameters to linear combination weights.</li><li><code>JacobianBiasCombination::Function</code>: Analytical Jacobian of <code>BiasCombination</code> w.r.t. bias parameters.</li></ul><p><strong>Details</strong></p><p>The power spectrum multipole is computed as:</p><p class="math-container">\[P_\ell(k) = \sum_i c_i(b_1, b_2, ...) P_i(k)\]</p><p>where:</p><ul><li><span>$P_i(k)$</span> are the component power spectra (P11, Ploop, Pct, stochastic terms)</li><li><span>$c_i(b_1, b_2, ...)$</span> are coefficients from the bias expansion</li></ul><p>The <code>BiasCombination</code> function encodes the EFT bias model, while <code>JacobianBiasCombination</code> provides analytical derivatives for efficient gradient-based inference.</p><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs"># Load pre-trained emulator
emu = trained_emulators[&quot;PyBirdmnuw0wacdm&quot;][&quot;0&quot;]  # monopole

# Evaluate power spectrum
cosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]
bias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]
D = 0.8  # growth factor

P0 = get_Pℓ(cosmology, D, bias, emu)</code></pre><p><strong>See Also</strong></p><ul><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Evaluate the power spectrum.</li><li><a href="#Effort.get_Pℓ_jacobian"><code>get_Pℓ_jacobian</code></a>: Evaluate power spectrum and its Jacobian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/neural_networks.jl#L91-L134">source</a></section></article><h2 id="EFT-Commands"><a class="docs-heading-anchor" href="#EFT-Commands">EFT Commands</a><a id="EFT-Commands-1"></a><a class="docs-heading-anchor-permalink" href="#EFT-Commands" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.get_Pℓ_jacobian" href="#Effort.get_Pℓ_jacobian"><code>Effort.get_Pℓ_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Pℓ_jacobian(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators; stoch_kwargs...)</code></pre><p>Compute both the power spectrum multipole <span>$P_\ell(k)$</span> and its Jacobian with respect to bias parameters.</p><p><strong>Arguments</strong></p><ul><li><code>cosmology::Array</code>: Array of cosmological parameters (format depends on the emulator training).</li><li><code>D</code>: Growth factor value at the redshift of interest.</li><li><code>bs::Array</code>: Array of bias parameters.</li><li><code>cosmoemu::AbstractPℓEmulators</code>: The multipole emulator containing P11, Ploop, Pct components.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stoch_kwargs...</code>: Additional keyword arguments passed to the stochastic model (e.g., shot noise parameters).</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(Pℓ, ∂Pℓ_∂b)</code> where:</p><ul><li><code>Pℓ</code>: Power spectrum multipole values evaluated on the emulator&#39;s k-grid.</li><li><code>∂Pℓ_∂b</code>: Jacobian matrix of the power spectrum with respect to bias parameters.</li></ul><p><strong>Details</strong></p><p>This function is optimized for inference workflows where both the power spectrum and its derivatives are needed (e.g., gradient-based MCMC, Fisher forecasts). It computes both quantities in a single pass, avoiding redundant neural network evaluations.</p><p>The Jacobian is computed using the analytical derivative of the bias combination function, which is significantly faster than automatic differentiation for this specific operation.</p><p><strong>See Also</strong></p><ul><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Compute only the power spectrum without Jacobian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/eft_commands.jl#L38-L68">source</a></section></article><h2 id="Projection"><a class="docs-heading-anchor" href="#Projection">Projection</a><a id="Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Projection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pkμ" href="#Effort._Pkμ"><code>Effort._Pkμ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> at a given wavenumber <code>k</code> and cosine of the angle to the line-of-sight <code>μ</code>, using its Legendre multipole moments.</p><p><strong>Arguments</strong></p><ul><li><code>k</code>: The wavenumber.</li><li><code>μ</code>: The cosine of the angle to the line-of-sight.</li><li><code>Int_Mono</code>: A function or interpolant that provides the monopole moment <span>$I_0(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Quad</code>: A function or interpolant that provides the quadrupole moment <span>$I_2(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Hexa</code>: A function or interpolant that provides the hexadecapole moment <span>$I_4(k)$</span> at wavenumber <code>k</code>.</li></ul><p><strong>Returns</strong></p><p>The value of the anisotropic power spectrum <span>$P(k, \mu)$</span> at the given <code>k</code> and <code>μ</code>.</p><p><strong>Details</strong></p><p>The anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at <code>μ</code>. The function uses the 0th, 2nd, and 4th order Legendre polynomials.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P(k, \mu) = I_0(k) \mathcal{L}_0(\mu) + I_2(k) \mathcal{L}_2(\mu) + I_4(k) \mathcal{L}_4(\mu)\]</p><p>where <span>$I_l(k)$</span> are the multipole moments and <span>$\mathcal{L}_l(\mu)$</span> are the Legendre polynomials of order <span>$l$</span>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-NTuple{4, Any}" href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o, μ_o, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> from the observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber (scalar).</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true wavenumber <code>k</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></a>: Method for arrays of observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-Tuple{Array, Array, Any, Any}" href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> for arrays of observed wavenumbers <code>k_o</code> and observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: An array of observed wavenumbers.</li><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A vector containing the calculated true wavenumbers <code>k</code> for the given input arrays.</p><p><strong>Details</strong></p><p>The function calculates <code>k</code> for pairs or combinations of values from the input arrays <code>k_o</code> and <code>μ_o</code> using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.</p><p><strong>Formula</strong></p><p>The underlying transformation for each pair of <code>k_o</code> and <code>μ_o</code> is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true(k_o, μ_o, q_perp, F)</code></a>: Method for scalar observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L70-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Any, Any}" href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> from the observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true cosine of the angle to the line-of-sight <code>μ</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>_μ_true(μ_o::Array, F)</code></a>: Method for an array of observed values.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L111-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Array, Any}" href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o::Array, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> for an array of observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>An array containing the calculated true cosines of the angle to the line-of-sight <code>μ</code>.</p><p><strong>Details</strong></p><p>The function calculates <code>μ</code> for each value in the input array <code>μ_o</code> using a formula derived from anisotropic scaling. Broadcasting (<code>@.</code>) is used to apply the calculation element-wise.</p><p><strong>Formula</strong></p><p>The underlying transformation for each <code>μ_o</code> is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true(μ_o, F)</code></a>: Method for a scalar observed value.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L141-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._P_obs" href="#Effort._P_obs"><code>Effort._P_obs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Calculates the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> at a given observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber.</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>Int_Mono</code>: An interpolation function for the monopole moment <span>$I_0(k)$</span> in true k.</li><li><code>Int_Quad</code>: An interpolation function for the quadrupole moment <span>$I_2(k)$</span> in true k.</li><li><code>Int_Hexa</code>: An interpolation function for the hexadecapole moment <span>$I_4(k)$</span> in true k.</li></ul><p><strong>Returns</strong></p><p>The value of the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span>.</p><p><strong>Details</strong></p><p>The observed coordinates <span>$(k_o, \mu_o)$</span> are transformed to true coordinates <span>$(k_t, \mu_t)$</span> using the <a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a> and <a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a> functions, with <span>$F = q_\parallel / q_\perp$</span>. The true power spectrum <span>$P(k_t, \mu_t)$</span> is then reconstructed using <a href="#Effort._Pkμ"><code>_Pkμ</code></a> and the provided multipole interpolants. Finally, the result is scaled by <span>$1 / (q_\parallel q_\perp^2)$</span>.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P_{\text{obs}}(k_o, \mu_o) = \frac{1}{q_\parallel q_\perp^2} P(k_t, \mu_t)\]</p><p>where</p><p class="math-container">\[k_t = \text{_k_true}(k_o, \mu_o, q_\perp, F)\]</p><p class="math-container">\[\mu_t = \text{_μ_true}(\mu_o, F)\]</p><p>and</p><p class="math-container">\[F = q_\parallel / q_\perp\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Transforms observed wavenumber to true wavenumber.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Transforms observed angle cosine to true angle cosine.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs the true power spectrum from multipole moments.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the multipole interpolants.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L178-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.interp_Pℓs" href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)</code></pre><p>Creates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.</p><p>These interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Mono_array</code>: An array containing the values of the monopole moment <span>$I_0(k)$</span>.</li><li><code>Quad_array</code>: An array containing the values of the quadrupole moment <span>$I_2(k)$</span>.</li><li><code>Hexa_array</code>: An array containing the values of the hexadecapole moment <span>$I_4(k)$</span>.</li><li><code>k_grid</code>: An array containing the corresponding wavenumber <code>k</code> values for the multipole arrays.</li></ul><p><strong>Returns</strong></p><p>A tuple containing three interpolation functions: <code>(Int_Mono, Int_Quad, Int_Hexa)</code>.</p><p><strong>Details</strong></p><p>The function uses <code>AkimaInterpolation</code> from the <code>Interpolations.jl</code> package to create the interpolants. Extrapolation is set to <code>ExtrapolationType.Extension</code>, which means the interpolant will use the nearest data points to extrapolate outside the provided <code>k_grid</code> range. Note that extrapolation can sometimes introduce errors.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Uses the interpolation functions to reconstruct the anisotropic power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L237-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}" href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP_check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP_check(k_input::AbstractVector, k_output::AbstractVector, Mono_array::AbstractVector, Quad_array::AbstractVector, Hexa_array::AbstractVector, q_par, q_perp)</code></pre><p>Calculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid <code>k_output</code>, from vectors of true multipole moments provided on an input wavenumber grid <code>k_input</code>, using numerical integration.</p><p>This is a <strong>check version</strong>, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle <code>μ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_input</code>: A vector of wavenumber values on which the input true multipole moments (<code>Mono_array</code>, <code>Quad_array</code>, <code>Hexa_array</code>) are defined.</li><li><code>k_output</code>: A vector of observed wavenumber values at which to calculate the output observed multipoles.</li><li><code>Mono_array</code>: A vector containing the values of the true monopole moment <span>$I_0(k)$</span> on the <code>k_input</code> grid.</li><li><code>Quad_array</code>: A vector containing the values of the true quadrupole moment <span>$I_2(k)$</span> on the <code>k_input</code> grid.</li><li><code>Hexa_array</code>: A vector containing the values of the true hexadecapole moment <span>$I_4(k)$</span> on the <code>k_input</code> grid.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(P0_obs, P2_obs, P4_obs)</code>, where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in <code>k_output</code>.</p><p><strong>Details</strong></p><p>This method first creates interpolation functions for the true multipole moments using <a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a> based on the <code>k_input</code> grid. It then calls the core <a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a> method, passing <code>k_output</code> as the grid at which to calculate the observed multipoles.</p><p>This function is a <strong>slower check implementation</strong> and should not be used in performance-critical code.</p><p><strong>Formula</strong></p><p>The observed multipole moments are calculated using the formula:</p><p class="math-container">\[P_\ell(k_o) = (2\ell + 1) \int_{0}^1 P_{\text{obs}}(k_o, \mu_o) \mathcal{L}_\ell(\mu_o) d\mu_o\]</p><p>for <span>$\ell \in \{0, 2, 4\}$</span>. The observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> is calculated using <a href="#Effort._P_obs"><code>_P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa)</code></a>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a>: The core method performing the integration.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the interpolation functions for the true multipoles.</li><li><a href="#Effort._P_obs"><code>_P_obs</code></a>: Calculates the observed power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L273-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pk_recon" href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> on a grid of wavenumbers <code>k</code> and cosines of the angle to the line-of-sight <code>μ</code>, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.</p><p>This function is designed to efficiently reconstruct the 2D power spectrum for multiple <code>k</code> and <code>μ</code> values simultaneously, assuming the multipole moments are provided as matrices (e.g., <code>N_k x 1</code>) and Legendre polynomials as vectors (e.g., <code>N_μ</code>).</p><p><strong>Arguments</strong></p><ul><li><code>mono</code>: A matrix containing the monopole moment <span>$I_0(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>quad</code>: A matrix containing the quadrupole moment <span>$I_2(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>hexa</code>: A matrix containing the hexadecapole moment <span>$I_4(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>l0</code>: A vector containing the 0th order Legendre polynomial <span>$\mathcal{L}_0(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l2</code>: A vector containing the 2nd order Legendre polynomial <span>$\mathcal{L}_2(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l4</code>: A vector containing the 4th order Legendre polynomial <span>$\mathcal{L}_4(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li></ul><p><strong>Returns</strong></p><p>A matrix representing the anisotropic power spectrum <span>$P(k, \mu)$</span> on the <code>N_k x N_μ</code> grid.</p><p><strong>Details</strong></p><p>The function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input <code>k</code> (from the rows of the moment matrices) and <code>μ</code> (from the elements of the Legendre polynomial vectors).</p><p><strong>Formula</strong></p><p>The formula used for each element <span>$(i, j)$</span> of the output matrix (corresponding to the <span>$i$</span>-th wavenumber and <span>$j$</span>-th angle cosine) is:</p><p class="math-container">\[P(k_i, \mu_j) = I_0(k_i) \mathcal{L}_0(\mu_j) + I_2(k_i) \mathcal{L}_2(\mu_j) + I_4(k_i) \mathcal{L}_4(\mu_j)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs <span>$P(k, \mu)$</span> for single <code>k</code> and <code>μ</code>.</li><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculate the Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/projection.jl#L390-L429">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._transformed_weights" href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_transformed_weights(quadrature_rule, order, a, b)</code></pre><p>Transforms the points and weights of a standard quadrature rule from the interval <code>[-1, 1]</code> to a specified interval <code>[a, b]</code>.</p><p>This is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals <code>[a, b]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>quadrature_rule</code>: A function that takes an <code>order</code> and returns a tuple <code>(points, weights)</code>                    for the standard interval <code>[-1, 1]</code>.</li><li><code>order</code>: The order of the quadrature rule (number of points).</li><li><code>a</code>: The lower bound of the target interval.</li><li><code>b</code>: The upper bound of the target interval.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(transformed_points, transformed_weights)</code> for the interval <code>[a, b]</code>.</p><p><strong>Details</strong></p><p>The transformation is applied to the standard points <span>$x_i^{\text{std}}$</span> and weights <span>$w_i^{\text{std}}$</span> obtained from the <code>quadrature_rule</code>:</p><ul><li>Transformed points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span></li><li>Transformed weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></li></ul><p><strong>Formula</strong></p><p>The transformation formulas are: Points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span> Weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_0" href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_0(x)</code></pre><p>Calculates the 0th order Legendre polynomial, <span>$\mathcal{L}_0(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 0th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 0th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_0(x) = 1\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L259-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_2" href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_2(x)</code></pre><p>Calculates the 2nd order Legendre polynomial, <span>$\mathcal{L}_2(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 2nd order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 2nd order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_2(x) = \frac{1}{2} (3x^2 - 1)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L285-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_4" href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_4(x)</code></pre><p>Calculates the 4th order Legendre polynomial, <span>$\mathcal{L}_4(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 4th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 4th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_4(x) = \frac{1}{8} (35x^4 - 30x^2 + 3)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L311-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._cubic_spline" href="#Effort._cubic_spline"><code>Effort._cubic_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_cubic_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply a cubic spline interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating a <code>CubicSpline</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.CubicSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates a cubic spline interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.CubicSpline</code>: The underlying interpolation function.</li><li><a href="#Effort._quadratic_spline"><code>_quadratic_spline</code></a>: Wrapper for quadratic spline interpolation.</li><li><a href="#Effort._akima_spline"><code>_akima_spline</code></a>: Wrapper for Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L147-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._quadratic_spline" href="#Effort._quadratic_spline"><code>Effort._quadratic_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_quadratic_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply a quadratic spline interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating a <code>QuadraticSpline</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.QuadraticSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates a quadratic spline interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.QuadraticSpline</code>: The underlying interpolation function.</li><li><a href="#Effort._cubic_spline"><code>_cubic_spline</code></a>: Wrapper for cubic spline interpolation.</li><li><a href="#Effort._akima_spline"><code>_akima_spline</code></a>: Wrapper for Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L177-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_spline" href="#Effort._akima_spline"><code>Effort._akima_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply an Akima interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating an <code>AkimaInterpolation</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.AkimaInterpolation(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates an Akima interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.AkimaInterpolation</code>: The underlying interpolation function.</li><li><a href="#Effort._cubic_spline"><code>_cubic_spline</code></a>: Wrapper for cubic spline interpolation.</li><li><a href="#Effort._quadratic_spline"><code>_quadratic_spline</code></a>: Wrapper for quadratic spline interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L207-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_spline_legacy" href="#Effort._akima_spline_legacy"><code>Effort._akima_spline_legacy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_spline_legacy(u, t, t_new)</code></pre><p>Evaluates the one-dimensional Akima spline that interpolates the data points <span>$(t_i, u_i)$</span> at new abscissae <code>t_new</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Ordinates (function values) <span>$u_i$</span> at the data nodes.</li><li><code>t</code>: Strictly increasing abscissae (knots) <span>$t_i$</span> associated with <code>u</code>. <code>length(t)</code> must equal <code>length(u)</code>.</li><li><code>t_new</code>: The query point(s) where the spline is to be evaluated.</li></ul><p><strong>Returns</strong></p><p>The interpolated value(s) at <code>t_new</code>. A scalar input returns a scalar; a vector input returns a vector of the same length.</p><p><strong>Details</strong></p><p>This routine implements the original Akima piecewise-cubic method (T. Akima, 1970). On each interval <span>$[t_j, t_{j+1}]$</span>, a cubic polynomial is constructed. The method uses a weighted average of slopes to determine the derivative at each node, which effectively dampens oscillations without explicit shape constraints. The resulting spline is <span>$C^1$</span> continuous (its first derivative is continuous) but generally not <span>$C^2$</span>.</p><p><strong>Formulae</strong></p><p>The spline on the interval <span>$[t_j, t_{j+1}]$</span> is a cubic polynomial: [ S<em>j(w) = u</em>j + b<em>j w + c</em>j w^{2} + d<em>j w^{3}, \qquad w = t - t</em>j ] The derivative <span>$b_j$</span> at each node is determined by Akima&#39;s weighting of local slopes <span>$m_j=(u_{j}-u_{j-1})/(t_j-t_{j-1})$</span>: [ b<em>j = \frac{|m</em>{j+1}-m<em>{j}|\,m</em>{j-1} + |m<em>{j-1}-m</em>{j-2}|\,m<em>{j}}             {|m</em>{j+1}-m<em>{j}| + |m</em>{j-1}-m<em>{j-2}|} ] The remaining coefficients, ``c</em>j<span>$and$</span>d<em>j``, are found by enforcing continuity of the first derivative: [ c</em>j = \frac{3m<em>j - 2b</em>j - b<em>{j+1}}{t</em>{j+1}-t<em>j} ] [ d</em>j = \frac{b<em>j + b</em>{j+1} - 2m<em>j}{(t</em>{j+1}-t_j)^2} ]</p><p><strong>Automatic Differentiation</strong></p><p>The implementation is free of mutation on the inputs and uses only element-wise arithmetic, making the returned value differentiable with both <code>ForwardDiff.jl</code> (dual numbers) and <code>Zygote.jl</code> (reverse-mode AD). You can therefore embed <code>_akima_spline_legacy</code> in optimization or machine-learning pipelines and back-propagate through the interpolation seamlessly.</p><p><strong>Notes</strong></p><p>The algorithm and numerical results are equivalent to the Akima spline in <code>DataInterpolations.jl</code>, but this routine is self-contained and avoids any package dependency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L96-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.load_component_emulator" href="#Effort.load_component_emulator"><code>Effort.load_component_emulator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_component_emulator(path::String; emu=LuxEmulator, k_file=&quot;k.npy&quot;, weights_file=&quot;weights.npy&quot;, inminmax_file=&quot;inminmax.npy&quot;, outminmax_file=&quot;outminmax.npy&quot;, nn_setup_file=&quot;nn_setup.json&quot;, postprocessing_file=&quot;postprocessing_file.jl&quot;)</code></pre><p>Load a trained component emulator from disk.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: Directory path containing the emulator files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>emu</code>: Emulator type to initialize (<code>LuxEmulator</code> or <code>SimpleChainsEmulator</code>). Default: <code>LuxEmulator</code>.</li><li><code>k_file::String</code>: Filename for the wavenumber grid. Default: <code>&quot;k.npy&quot;</code>.</li><li><code>weights_file::String</code>: Filename for neural network weights. Default: <code>&quot;weights.npy&quot;</code>.</li><li><code>inminmax_file::String</code>: Filename for input normalization parameters. Default: <code>&quot;inminmax.npy&quot;</code>.</li><li><code>outminmax_file::String</code>: Filename for output normalization parameters. Default: <code>&quot;outminmax.npy&quot;</code>.</li><li><code>nn_setup_file::String</code>: Filename for network architecture configuration. Default: <code>&quot;nn_setup.json&quot;</code>.</li><li><code>postprocessing_file::String</code>: Filename for postprocessing function. Default: <code>&quot;postprocessing_file.jl&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>ComponentEmulator</code> instance ready for evaluation.</p><p><strong>Details</strong></p><p>This function loads all necessary files to reconstruct a trained component emulator:</p><ol><li>Neural network architecture from JSON configuration.</li><li>Trained weights from NumPy binary format.</li><li>Normalization parameters for inputs and outputs.</li><li>Wavenumber grid.</li><li>Postprocessing function dynamically loaded from Julia file.</li></ol><p>The postprocessing function is evaluated in an isolated scope to prevent namespace pollution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">P11_emu = load_component_emulator(&quot;/path/to/emulator/11/&quot;)</code></pre><p><strong>File Structure</strong></p><p>The expected directory structure is:</p><pre><code class="nohighlight hljs">path/
├── k.npy                    # Wavenumber grid
├── weights.npy              # Neural network weights
├── inminmax.npy            # Input normalization (n_params × 2)
├── outminmax.npy           # Output normalization (n_k × 2)
├── nn_setup.json           # Network architecture
└── postprocessing_file.jl  # Postprocessing function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L337-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.load_multipole_emulator" href="#Effort.load_multipole_emulator"><code>Effort.load_multipole_emulator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_multipole_emulator(path; emu=LuxEmulator, k_file=&quot;k.npy&quot;, weights_file=&quot;weights.npy&quot;, inminmax_file=&quot;inminmax.npy&quot;, outminmax_file=&quot;outminmax.npy&quot;, nn_setup_file=&quot;nn_setup.json&quot;, postprocessing_file=&quot;postprocessing.jl&quot;, stochmodel_file=&quot;stochmodel.jl&quot;, biascombination_file=&quot;biascombination.jl&quot;, jacbiascombination_file=&quot;jacbiascombination.jl&quot;)</code></pre><p>Load a complete power spectrum multipole emulator from disk.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Directory path containing the multipole emulator structure.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>emu</code>: Emulator type to initialize (<code>LuxEmulator</code> or <code>SimpleChainsEmulator</code>). Default: <code>LuxEmulator</code>.</li><li><code>k_file::String</code>: Filename for the wavenumber grid. Default: <code>&quot;k.npy&quot;</code>.</li><li><code>weights_file::String</code>: Filename for neural network weights. Default: <code>&quot;weights.npy&quot;</code>.</li><li><code>inminmax_file::String</code>: Filename for input normalization parameters. Default: <code>&quot;inminmax.npy&quot;</code>.</li><li><code>outminmax_file::String</code>: Filename for output normalization parameters. Default: <code>&quot;outminmax.npy&quot;</code>.</li><li><code>nn_setup_file::String</code>: Filename for network architecture configuration. Default: <code>&quot;nn_setup.json&quot;</code>.</li><li><code>postprocessing_file::String</code>: Filename for postprocessing function. Default: <code>&quot;postprocessing.jl&quot;</code>.</li><li><code>stochmodel_file::String</code>: Filename for stochastic model function. Default: <code>&quot;stochmodel.jl&quot;</code>.</li><li><code>biascombination_file::String</code>: Filename for bias combination function. Default: <code>&quot;biascombination.jl&quot;</code>.</li><li><code>jacbiascombination_file::String</code>: Filename for bias Jacobian function. Default: <code>&quot;jacbiascombination.jl&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>PℓEmulator</code> instance containing all three components (P11, Ploop, Pct) and bias models.</p><p><strong>Details</strong></p><p>This function loads a complete multipole emulator by:</p><ol><li>Loading three component emulators (P11, Ploop, Pct) from subdirectories.</li><li>Loading the stochastic model function (shot noise terms).</li><li>Loading the bias combination function (maps bias parameters to weights).</li><li>Loading the analytical Jacobian of the bias combination.</li></ol><p>All functions are evaluated in isolated scopes to prevent namespace conflicts between different emulator components.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load monopole emulator
monopole_emu = load_multipole_emulator(&quot;/path/to/artifact/0/&quot;)

# Evaluate
cosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]
bias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]
D = 0.8
P0 = get_Pℓ(cosmology, D, bias, monopole_emu)</code></pre><p><strong>File Structure</strong></p><p>The expected directory structure is:</p><pre><code class="nohighlight hljs">path/
├── 11/                       # P11 component
│   ├── k.npy
│   ├── weights.npy
│   ├── inminmax.npy
│   ├── outminmax.npy
│   ├── nn_setup.json
│   └── postprocessing.jl
├── loop/                     # Ploop component
│   └── ... (same structure)
├── ct/                       # Pct component
│   └── ... (same structure)
├── stochmodel.jl            # Stochastic model function
├── biascombination.jl       # Bias combination function
└── jacbiascombination.jl    # Bias Jacobian function</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Effort.load_component_emulator"><code>load_component_emulator</code></a>: Load individual component emulators.</li><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Evaluate the loaded emulator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/6017ab062d4f3068bff4abee0b89f4ca10f61c1f/src/utils.jl#L411-L479">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_external/">« External API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 20 October 2025 15:44">Monday 20 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
