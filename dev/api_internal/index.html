<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API · Effort.jl</title><meta name="title" content="Internal API · Effort.jl"/><meta property="og:title" content="Internal API · Effort.jl"/><meta property="twitter:title" content="Internal API · Effort.jl"/><meta name="description" content="Documentation for Effort.jl."/><meta property="og:description" content="Documentation for Effort.jl."/><meta property="twitter:description" content="Documentation for Effort.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Effort.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Effort.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../api_external/">External API</a></li><li class="is-active"><a class="tocitem" href>Internal API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Neural-Networks"><span>Neural Networks</span></a></li><li><a class="tocitem" href="#EFT-Commands"><span>EFT Commands</span></a></li><li><a class="tocitem" href="#Projection"><span>Projection</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Internal API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/main/docs/src/api_internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This section documents the functions intended for internal usage by the package.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Effort.AbstractComponentEmulators"><code>Effort.AbstractComponentEmulators</code></a></li><li><a href="#Effort.AbstractPℓEmulators"><code>Effort.AbstractPℓEmulators</code></a></li><li><a href="#Effort.ComponentEmulator"><code>Effort.ComponentEmulator</code></a></li><li><a href="#Effort.PℓEmulator"><code>Effort.PℓEmulator</code></a></li><li><a href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a></li><li><a href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a></li><li><a href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a></li><li><a href="#Effort._P_obs"><code>Effort._P_obs</code></a></li><li><a href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a></li><li><a href="#Effort._Pkμ"><code>Effort._Pkμ</code></a></li><li><a href="#Effort._akima_coefficients-Tuple{Any, AbstractMatrix}"><code>Effort._akima_coefficients</code></a></li><li><a href="#Effort._akima_eval-Tuple{AbstractMatrix, Any, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractArray}"><code>Effort._akima_eval</code></a></li><li><a href="#Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}"><code>Effort._akima_interpolation</code></a></li><li><a href="#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>Effort._akima_interpolation</code></a></li><li><a href="#Effort._akima_slopes-Tuple{AbstractMatrix, Any}"><code>Effort._akima_slopes</code></a></li><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a></li><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP</code></a></li><li><a href="#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>Effort.apply_AP</code></a></li><li><a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP_check</code></a></li><li><a href="#Effort.get_Pℓ_jacobian"><code>Effort.get_Pℓ_jacobian</code></a></li><li><a href="#Effort.get_component"><code>Effort.get_component</code></a></li><li><a href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a></li><li><a href="#Effort.load_component_emulator"><code>Effort.load_component_emulator</code></a></li><li><a href="#Effort.load_multipole_emulator"><code>Effort.load_multipole_emulator</code></a></li><li><a href="#Effort.q_par_perp"><code>Effort.q_par_perp</code></a></li><li><a href="#Effort.window_convolution"><code>Effort.window_convolution</code></a></li></ul><h2 id="Neural-Networks"><a class="docs-heading-anchor" href="#Neural-Networks">Neural Networks</a><a id="Neural-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-Networks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.AbstractComponentEmulators" href="#Effort.AbstractComponentEmulators"><code>Effort.AbstractComponentEmulators</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractComponentEmulators</code></pre><p>Abstract type for component-level emulators that represent individual parts of the power spectrum calculation (e.g., P11, Ploop, Pct).</p><p>All concrete subtypes must implement the necessary fields to enable neural network evaluation, normalization, and postprocessing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/neural_networks.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.ComponentEmulator" href="#Effort.ComponentEmulator"><code>Effort.ComponentEmulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComponentEmulator &lt;: AbstractComponentEmulators</code></pre><p>A complete emulator for a single power spectrum component, combining neural network predictions with normalization and physics-based postprocessing.</p><p><strong>Fields</strong></p><ul><li><code>TrainedEmulator::AbstractTrainedEmulators</code>: The trained neural network (Lux or SimpleChains).</li><li><code>kgrid::Array</code>: Wavenumber grid on which the component is evaluated (in h/Mpc).</li><li><code>InMinMax::Matrix{Float64}</code>: Min-max normalization parameters for inputs (n_params × 2).</li><li><code>OutMinMax::Array{Float64}</code>: Min-max normalization parameters for outputs (n_k × 2).</li><li><code>Postprocessing::Function</code>: Function to apply physics transformations to raw NN output.</li></ul><p><strong>Details</strong></p><p>The typical evaluation flow is:</p><ol><li>Normalize input parameters using <code>InMinMax</code>.</li><li>Evaluate neural network to get normalized output.</li><li>Denormalize output using <code>OutMinMax</code>.</li><li>Apply postprocessing (e.g., multiply by D² for P11).</li></ol><p><strong>Example Postprocessing</strong></p><pre><code class="language-julia hljs"># For linear power spectrum component
postprocess_P11 = (params, output, D, emu) -&gt; output .* D^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/neural_networks.jl#L12-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.get_component" href="#Effort.get_component"><code>Effort.get_component</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_component(input_params, D, comp_emu::AbstractComponentEmulators)</code></pre><p>Evaluate a component emulator to obtain power spectrum component values.</p><p><strong>Arguments</strong></p><ul><li><code>input_params</code>: Array of input parameters (e.g., cosmological parameters).</li><li><code>D</code>: Growth factor at the redshift of interest.</li><li><code>comp_emu::AbstractComponentEmulators</code>: The component emulator to evaluate.</li></ul><p><strong>Returns</strong></p><p>A matrix of shape <code>(n_k, n_samples)</code> containing the evaluated power spectrum component values on the emulator&#39;s k-grid.</p><p><strong>Details</strong></p><p>This function performs the full evaluation pipeline:</p><ol><li>Copy input parameters to avoid mutation.</li><li>Apply min-max normalization to inputs.</li><li>Run neural network inference.</li><li>Denormalize network output.</li><li>Apply component-specific postprocessing (using <code>D</code> and emulator metadata).</li><li>Reshape to match k-grid dimensions.</li></ol><p>The postprocessing step typically includes physics-based transformations such as scaling by powers of the growth factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/neural_networks.jl#L46-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.AbstractPℓEmulators" href="#Effort.AbstractPℓEmulators"><code>Effort.AbstractPℓEmulators</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPℓEmulators</code></pre><p>Abstract type for complete power spectrum multipole emulators.</p><p>Concrete subtypes must combine multiple component emulators (P11, Ploop, Pct) with bias models to compute full power spectrum multipoles <span>$P_\ell(k)$</span> for <span>$\ell \in \{0, 2, 4\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/neural_networks.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.PℓEmulator" href="#Effort.PℓEmulator"><code>Effort.PℓEmulator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PℓEmulator &lt;: AbstractPℓEmulators</code></pre><p>Complete emulator for power spectrum multipoles in the Effective Field Theory of Large Scale Structure (EFTofLSS) framework.</p><p><strong>Fields</strong></p><ul><li><code>P11::ComponentEmulator</code>: Emulator for the linear theory power spectrum component.</li><li><code>Ploop::ComponentEmulator</code>: Emulator for the one-loop corrections.</li><li><code>Pct::ComponentEmulator</code>: Emulator for the counterterm contributions.</li><li><code>StochModel::Function</code>: Function to compute stochastic (shot noise) terms.</li><li><code>BiasCombination::Function</code>: Function mapping bias parameters to linear combination weights.</li><li><code>JacobianBiasCombination::Function</code>: Analytical Jacobian of <code>BiasCombination</code> w.r.t. bias parameters.</li></ul><p><strong>Details</strong></p><p>The power spectrum multipole is computed as:</p><p class="math-container">\[P_\ell(k) = \sum_i c_i(b_1, b_2, ...) P_i(k)\]</p><p>where:</p><ul><li><span>$P_i(k)$</span> are the component power spectra (P11, Ploop, Pct, stochastic terms)</li><li><span>$c_i(b_1, b_2, ...)$</span> are coefficients from the bias expansion</li></ul><p>The <code>BiasCombination</code> function encodes the EFT bias model, while <code>JacobianBiasCombination</code> provides analytical derivatives for efficient gradient-based inference.</p><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs"># Load pre-trained emulator
emu = trained_emulators[&quot;PyBirdmnuw0wacdm&quot;][&quot;0&quot;]  # monopole

# Evaluate power spectrum
cosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]
bias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]
D = 0.8  # growth factor

P0 = get_Pℓ(cosmology, D, bias, emu)</code></pre><p><strong>See Also</strong></p><ul><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Evaluate the power spectrum.</li><li><a href="#Effort.get_Pℓ_jacobian"><code>get_Pℓ_jacobian</code></a>: Evaluate power spectrum and its Jacobian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/neural_networks.jl#L91-L134">source</a></section></article><h2 id="EFT-Commands"><a class="docs-heading-anchor" href="#EFT-Commands">EFT Commands</a><a id="EFT-Commands-1"></a><a class="docs-heading-anchor-permalink" href="#EFT-Commands" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.get_Pℓ_jacobian" href="#Effort.get_Pℓ_jacobian"><code>Effort.get_Pℓ_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Pℓ_jacobian(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators; stoch_kwargs...)</code></pre><p>Compute both the power spectrum multipole <span>$P_\ell(k)$</span> and its Jacobian with respect to bias parameters.</p><p><strong>Arguments</strong></p><ul><li><code>cosmology::Array</code>: Array of cosmological parameters (format depends on the emulator training).</li><li><code>D</code>: Growth factor value at the redshift of interest.</li><li><code>bs::Array</code>: Array of bias parameters.</li><li><code>cosmoemu::AbstractPℓEmulators</code>: The multipole emulator containing P11, Ploop, Pct components.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stoch_kwargs...</code>: Additional keyword arguments passed to the stochastic model (e.g., shot noise parameters).</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(Pℓ, ∂Pℓ_∂b)</code> where:</p><ul><li><code>Pℓ</code>: Power spectrum multipole values evaluated on the emulator&#39;s k-grid.</li><li><code>∂Pℓ_∂b</code>: Jacobian matrix of the power spectrum with respect to bias parameters.</li></ul><p><strong>Details</strong></p><p>This function is optimized for inference workflows where both the power spectrum and its derivatives are needed (e.g., gradient-based MCMC, Fisher forecasts). It computes both quantities in a single pass, avoiding redundant neural network evaluations.</p><p>The Jacobian is computed using the analytical derivative of the bias combination function, which is significantly faster than automatic differentiation for this specific operation.</p><p><strong>See Also</strong></p><ul><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Compute only the power spectrum without Jacobian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/eft_commands.jl#L38-L68">source</a></section></article><h2 id="Projection"><a class="docs-heading-anchor" href="#Projection">Projection</a><a id="Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Projection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pkμ" href="#Effort._Pkμ"><code>Effort._Pkμ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> at a given wavenumber <code>k</code> and cosine of the angle to the line-of-sight <code>μ</code>, using its Legendre multipole moments.</p><p><strong>Arguments</strong></p><ul><li><code>k</code>: The wavenumber.</li><li><code>μ</code>: The cosine of the angle to the line-of-sight.</li><li><code>Int_Mono</code>: A function or interpolant that provides the monopole moment <span>$I_0(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Quad</code>: A function or interpolant that provides the quadrupole moment <span>$I_2(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Hexa</code>: A function or interpolant that provides the hexadecapole moment <span>$I_4(k)$</span> at wavenumber <code>k</code>.</li></ul><p><strong>Returns</strong></p><p>The value of the anisotropic power spectrum <span>$P(k, \mu)$</span> at the given <code>k</code> and <code>μ</code>.</p><p><strong>Details</strong></p><p>The anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at <code>μ</code>. The function uses the 0th, 2nd, and 4th order Legendre polynomials.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P(k, \mu) = I_0(k) \mathcal{L}_0(\mu) + I_2(k) \mathcal{L}_2(\mu) + I_4(k) \mathcal{L}_4(\mu)\]</p><p>where <span>$I_l(k)$</span> are the multipole moments and <span>$\mathcal{L}_l(\mu)$</span> are the Legendre polynomials of order <span>$l$</span>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-NTuple{4, Any}" href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o, μ_o, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> from the observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber (scalar).</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true wavenumber <code>k</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></a>: Method for arrays of observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-Tuple{Array, Array, Any, Any}" href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> for arrays of observed wavenumbers <code>k_o</code> and observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: An array of observed wavenumbers.</li><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A vector containing the calculated true wavenumbers <code>k</code> for the given input arrays.</p><p><strong>Details</strong></p><p>The function calculates <code>k</code> for pairs or combinations of values from the input arrays <code>k_o</code> and <code>μ_o</code> using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.</p><p><strong>Formula</strong></p><p>The underlying transformation for each pair of <code>k_o</code> and <code>μ_o</code> is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true(k_o, μ_o, q_perp, F)</code></a>: Method for scalar observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L70-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Any, Any}" href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> from the observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true cosine of the angle to the line-of-sight <code>μ</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>_μ_true(μ_o::Array, F)</code></a>: Method for an array of observed values.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L111-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Array, Any}" href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o::Array, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> for an array of observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>An array containing the calculated true cosines of the angle to the line-of-sight <code>μ</code>.</p><p><strong>Details</strong></p><p>The function calculates <code>μ</code> for each value in the input array <code>μ_o</code> using a formula derived from anisotropic scaling. Broadcasting (<code>@.</code>) is used to apply the calculation element-wise.</p><p><strong>Formula</strong></p><p>The underlying transformation for each <code>μ_o</code> is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true(μ_o, F)</code></a>: Method for a scalar observed value.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L141-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._P_obs" href="#Effort._P_obs"><code>Effort._P_obs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Calculates the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> at a given observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber.</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>Int_Mono</code>: An interpolation function for the monopole moment <span>$I_0(k)$</span> in true k.</li><li><code>Int_Quad</code>: An interpolation function for the quadrupole moment <span>$I_2(k)$</span> in true k.</li><li><code>Int_Hexa</code>: An interpolation function for the hexadecapole moment <span>$I_4(k)$</span> in true k.</li></ul><p><strong>Returns</strong></p><p>The value of the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span>.</p><p><strong>Details</strong></p><p>The observed coordinates <span>$(k_o, \mu_o)$</span> are transformed to true coordinates <span>$(k_t, \mu_t)$</span> using the <a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a> and <a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a> functions, with <span>$F = q_\parallel / q_\perp$</span>. The true power spectrum <span>$P(k_t, \mu_t)$</span> is then reconstructed using <a href="#Effort._Pkμ"><code>_Pkμ</code></a> and the provided multipole interpolants. Finally, the result is scaled by <span>$1 / (q_\parallel q_\perp^2)$</span>.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P_{\text{obs}}(k_o, \mu_o) = \frac{1}{q_\parallel q_\perp^2} P(k_t, \mu_t)\]</p><p>where</p><p class="math-container">\[k_t = \text{_k_true}(k_o, \mu_o, q_\perp, F)\]</p><p class="math-container">\[\mu_t = \text{_μ_true}(\mu_o, F)\]</p><p>and</p><p class="math-container">\[F = q_\parallel / q_\perp\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Transforms observed wavenumber to true wavenumber.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Transforms observed angle cosine to true angle cosine.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs the true power spectrum from multipole moments.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the multipole interpolants.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L178-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.interp_Pℓs" href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)</code></pre><p>Creates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.</p><p>These interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Mono_array</code>: An array containing the values of the monopole moment <span>$I_0(k)$</span>.</li><li><code>Quad_array</code>: An array containing the values of the quadrupole moment <span>$I_2(k)$</span>.</li><li><code>Hexa_array</code>: An array containing the values of the hexadecapole moment <span>$I_4(k)$</span>.</li><li><code>k_grid</code>: An array containing the corresponding wavenumber <code>k</code> values for the multipole arrays.</li></ul><p><strong>Returns</strong></p><p>A tuple containing three interpolation functions: <code>(Int_Mono, Int_Quad, Int_Hexa)</code>.</p><p><strong>Details</strong></p><p>The function uses <code>AkimaInterpolation</code> from the <code>Interpolations.jl</code> package to create the interpolants. Extrapolation is set to <code>ExtrapolationType.Extension</code>, which means the interpolant will use the nearest data points to extrapolate outside the provided <code>k_grid</code> range. Note that extrapolation can sometimes introduce errors.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Uses the interpolation functions to reconstruct the anisotropic power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L237-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.q_par_perp" href="#Effort.q_par_perp"><code>Effort.q_par_perp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)</code></pre><p>Calculates the parallel (<code>q_par</code>) and perpendicular (<code>q_perp</code>) Alcock-Paczynski (AP) parameters at a given redshift <code>z</code>, comparing a varying cosmology to a reference cosmology.</p><p>The AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift at which to calculate the AP parameters.</li><li><code>cosmo_mcmc</code>: An <code>AbstractCosmology</code> struct representing the varying cosmology (e.g., from an MCMC chain).</li><li><code>cosmo_ref</code>: An <code>AbstractCosmology</code> struct representing the reference cosmology used for measurements.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(q_par, q_perp)</code> containing the calculated parallel and perpendicular AP parameters at redshift <code>z</code>.</p><p><strong>Details</strong></p><p>The parallel AP parameter <code>q_par</code> is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter <code>q_perp</code> is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.</p><p><strong>Formula</strong></p><p>The formulas for the Alcock-Paczynski parameters are:</p><p class="math-container">\[q_\parallel(z) = \frac{E_{\text{ref}}(z)}{E_{\text{mcmc}}(z)}\]</p><p class="math-container">\[q_\perp(z) = \frac{\tilde{d}_{A,\text{mcmc}}(z)}{\tilde{d}_{A,\text{ref}}(z)}\]</p><p>where <span>$E(z)$</span> is the normalized Hubble parameter and <span>$\tilde{d}_A(z)$</span> is the conformal angular diameter distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L341-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}" href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP_check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP_check(k_input::AbstractVector, k_output::AbstractVector, Mono_array::AbstractVector, Quad_array::AbstractVector, Hexa_array::AbstractVector, q_par, q_perp)</code></pre><p>Calculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid <code>k_output</code>, from vectors of true multipole moments provided on an input wavenumber grid <code>k_input</code>, using numerical integration.</p><p>This is a <strong>check version</strong>, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle <code>μ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_input</code>: A vector of wavenumber values on which the input true multipole moments (<code>Mono_array</code>, <code>Quad_array</code>, <code>Hexa_array</code>) are defined.</li><li><code>k_output</code>: A vector of observed wavenumber values at which to calculate the output observed multipoles.</li><li><code>Mono_array</code>: A vector containing the values of the true monopole moment <span>$I_0(k)$</span> on the <code>k_input</code> grid.</li><li><code>Quad_array</code>: A vector containing the values of the true quadrupole moment <span>$I_2(k)$</span> on the <code>k_input</code> grid.</li><li><code>Hexa_array</code>: A vector containing the values of the true hexadecapole moment <span>$I_4(k)$</span> on the <code>k_input</code> grid.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(P0_obs, P2_obs, P4_obs)</code>, where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in <code>k_output</code>.</p><p><strong>Details</strong></p><p>This method first creates interpolation functions for the true multipole moments using <a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a> based on the <code>k_input</code> grid. It then calls the core <a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a> method, passing <code>k_output</code> as the grid at which to calculate the observed multipoles.</p><p>This function is a <strong>slower check implementation</strong> and should not be used in performance-critical code.</p><p><strong>Formula</strong></p><p>The observed multipole moments are calculated using the formula:</p><p class="math-container">\[P_\ell(k_o) = (2\ell + 1) \int_{0}^1 P_{\text{obs}}(k_o, \mu_o) \mathcal{L}_\ell(\mu_o) d\mu_o\]</p><p>for <span>$\ell \in \{0, 2, 4\}$</span>. The observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> is calculated using <a href="#Effort._P_obs"><code>_P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa)</code></a>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a>: The core method performing the integration.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the interpolation functions for the true multipoles.</li><li><a href="#Effort._P_obs"><code>_P_obs</code></a>: Calculates the observed power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L273-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}" href="#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>Effort.apply_AP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp; n_GL_points=8)</code></pre><p>Calculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid <code>k_output</code>, using arrays of true multipole moments provided on an input wavenumber grid <code>k_input</code>, and employing Gauss-Lobatto quadrature.</p><p>This is the <strong>standard, faster implementation</strong> for applying the Alcock-Paczynski (AP) effect to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.</p><p><strong>Arguments</strong></p><ul><li><code>k_input</code>: A vector of wavenumber values on which the input true multipole moments (<code>mono</code>, <code>quad</code>, <code>hexa</code>) are defined.</li><li><code>k_output</code>: A vector of observed wavenumber values at which to calculate the output observed multipoles.</li><li><code>mono</code>: A vector containing the values of the true monopole moment <span>$I_0(k)$</span> on the <code>k_input</code> grid.</li><li><code>quad</code>: A vector containing the values of the true quadrupole moment <span>$I_2(k)$</span> on the <code>k_input</code> grid.</li><li><code>hexa</code>: A vector containing the values of the true hexadecapole moment <span>$I_4(k)$</span> on the <code>k_input</code> grid.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_GL_points</code>: The number of Gauss-Lobatto points to use for the integration over <code>μ</code>. The actual number of nodes used corresponds to <code>2 * n_GL_points</code>. Defaults to 8.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(P0_obs, P2_obs, P4_obs)</code>, where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in <code>k_output</code>.</p><p><strong>Details</strong></p><p>The function applies the AP and RSD effects by integrating the observed anisotropic power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> over the observed cosine of the angle to the line-of-sight <span>$\mu_o \in [0, 1]$</span> (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial <span>$\mathcal{L}_\ell(\mu_o)$</span>.</p><p>The process involves:</p><ol><li>Determine Gauss-Lobatto nodes and weights for the interval <code>[0, 1]</code>.</li><li>For each observed wavenumber <code>k_o</code> in the input <code>k_output</code> array and each <code>μ_o</code> node: a. Calculate the true wavenumber <span>$k_t(k_o, \mu_o)$</span> using <a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>. b. Calculate the true angle cosine <span>$\mu_t(\mu_o)$</span> using <a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>. c. Interpolate the true multipole moments <span>$I_\ell(k_t)$</span> using <a href="#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>_akima_interpolation</code></a>, interpolating from the <code>k_input</code> grid to the new <code>k_t</code> values. d. Calculate the true Legendre polynomials <span>$\mathcal{L}_\ell(\mu_t)$</span> using <a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>. e. Reconstruct the true power spectrum <span>$P(k_t, \mu_t)$</span> using <a href="#Effort._Pk_recon"><code>_Pk_recon</code></a>. f. Calculate the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o) = P(k_t, \mu_t) / (q_\parallel q_\perp^2)$</span>.</li><li>Perform the weighted sum (quadrature) over the <code>μ_o</code> nodes to get the observed multipoles <span>$P_\ell(k_o)$</span> on the <code>k_output</code> grid.</li></ol><p>This function is the <strong>standard, performant implementation</strong> for applying AP compared to the slower <a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check</code></a>.</p><p><strong>Formula</strong></p><p>The observed multipole moments are calculated using the formula:</p><p class="math-container">\[P_\ell(k_o) = (2\ell + 1) \int_{0}^1 P_{\text{obs}}(k_o, \mu_o) \mathcal{L}_\ell(\mu_o) d\mu_o\]</p><p>for <span>$\ell \in \{0, 2, 4\}$</span>. The integral is approximated using Gauss-Lobatto quadrature.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check</code></a>: The slower, check version using generic numerical integration.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Transforms observed wavenumber to true wavenumber.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Transforms observed angle cosine to true angle cosine.</li><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculate the Legendre polynomials.</li><li><a href="#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>_akima_interpolation</code></a>: Interpolates the true multipole moments.</li><li><a href="#Effort._Pk_recon"><code>_Pk_recon</code></a>: Reconstructs the true power spectrum on a grid.</li><li><code>gausslobatto</code>: Function used to get quadrature nodes and weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L432-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}" href="#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}"><code>Effort.apply_AP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractMatrix, quad::AbstractMatrix, hexa::AbstractMatrix, q_par, q_perp; n_GL_points=8)</code></pre><p>Batch version of <code>apply_AP</code> for processing multiple columns simultaneously using optimized matrix Akima interpolation.</p><p>This method applies the Alcock-Paczynski effect to multiple sets of multipole moments (e.g., multiple Jacobian columns or parameter variations) in a single call. It leverages the optimized matrix Akima spline implementation to interpolate all columns at once, providing significant performance improvements over column-by-column processing.</p><p><strong>Arguments</strong></p><ul><li><code>k_input::AbstractVector</code>: Input wavenumber grid.</li><li><code>k_output::AbstractVector</code>: Output wavenumber grid.</li><li><code>mono::AbstractMatrix</code>: Monopole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>quad::AbstractMatrix</code>: Quadrupole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>hexa::AbstractMatrix</code>: Hexadecapole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>q_par</code>: Parallel AP parameter.</li><li><code>q_perp</code>: Perpendicular AP parameter.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_GL_points::Int</code>: Number of Gauss-Lobatto points. Default: 8.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(mono_AP, quad_AP, hexa_AP)</code> where each is a matrix of shape <code>(n_k_output, n_cols)</code> containing the AP-corrected multipoles for all input columns.</p><p><strong>Details</strong></p><p>This optimized implementation uses matrix Akima interpolation to process all columns simultaneously rather than iterating column-by-column. For N columns, this reduces 3×N Akima calls to just 3 matrix Akima calls, providing a ~2-3× speedup.</p><p>This is particularly useful for computing Jacobians where each column represents the derivative with respect to a different parameter (typically 11 bias parameters).</p><p><strong>Performance</strong></p><p>For typical DESI-like scenarios (50 input k-points, 100 output k-points, 11 columns):</p><ul><li>Old implementation: ~6 ms (33 scalar Akima calls)</li><li>New implementation: ~2 ms (3 matrix Akima calls)</li><li>Speedup: ~2.5-3×</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp)</code></a>: Single-column version.</li><li><a href="#Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}"><code>_akima_interpolation(u::AbstractMatrix, t, t_new)</code></a>: Optimized matrix Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L525-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pk_recon" href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> on a grid of wavenumbers <code>k</code> and cosines of the angle to the line-of-sight <code>μ</code>, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.</p><p>This function is designed to efficiently reconstruct the 2D power spectrum for multiple <code>k</code> and <code>μ</code> values simultaneously, assuming the multipole moments are provided as matrices (e.g., <code>N_k x 1</code>) and Legendre polynomials as vectors (e.g., <code>N_μ</code>).</p><p><strong>Arguments</strong></p><ul><li><code>mono</code>: A matrix containing the monopole moment <span>$I_0(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>quad</code>: A matrix containing the quadrupole moment <span>$I_2(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>hexa</code>: A matrix containing the hexadecapole moment <span>$I_4(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>l0</code>: A vector containing the 0th order Legendre polynomial <span>$\mathcal{L}_0(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l2</code>: A vector containing the 2nd order Legendre polynomial <span>$\mathcal{L}_2(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l4</code>: A vector containing the 4th order Legendre polynomial <span>$\mathcal{L}_4(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li></ul><p><strong>Returns</strong></p><p>A matrix representing the anisotropic power spectrum <span>$P(k, \mu)$</span> on the <code>N_k x N_μ</code> grid.</p><p><strong>Details</strong></p><p>The function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input <code>k</code> (from the rows of the moment matrices) and <code>μ</code> (from the elements of the Legendre polynomial vectors).</p><p><strong>Formula</strong></p><p>The formula used for each element <span>$(i, j)$</span> of the output matrix (corresponding to the <span>$i$</span>-th wavenumber and <span>$j$</span>-th angle cosine) is:</p><p class="math-container">\[P(k_i, \mu_j) = I_0(k_i) \mathcal{L}_0(\mu_j) + I_2(k_i) \mathcal{L}_2(\mu_j) + I_4(k_i) \mathcal{L}_4(\mu_j)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs <span>$P(k, \mu)$</span> for single <code>k</code> and <code>μ</code>.</li><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculate the Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L388-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.window_convolution" href="#Effort.window_convolution"><code>Effort.window_convolution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">window_convolution(W::Array{T, 4}, v::Matrix) where {T}</code></pre><p>Applies a 4-dimensional window function or kernel <code>W</code> to a 2-dimensional input matrix <code>v</code>.</p><p>This operation performs a transformation or generalized convolution, summing over the <code>j</code> and <code>l</code> indices of the inputs to produce a 2D result indexed by <code>i</code> and <code>k</code>. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: A 4-dimensional array representing the window function or kernel.</li><li><code>v</code>: A 2-dimensional matrix representing the input data.</li></ul><p><strong>Returns</strong></p><p>A 2-dimensional matrix representing the result of the convolution or transformation.</p><p><strong>Details</strong></p><p>The function implements the summation using the <code>@tullio</code> macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.</p><p><strong>Formula</strong></p><p>The operation is defined as:</p><p class="math-container">\[C_{ik} = \sum_{j,l} W_{ijkl} v_{jl}\]</p><p><strong>See Also</strong></p><ul><li><a href="../api_external/#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}"><code>window_convolution(W::AbstractMatrix, v::AbstractVector)</code></a>: Method for a matrix kernel and vector input.</li></ul><p><strong>References</strong></p><ul><li>The methodology for this type of window measurement is discussed in: <a href="https://arxiv.org/abs/1810.05051">arXiv:1810.05051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L617-L651">source</a></section><section><div><pre><code class="language-julia hljs">window_convolution(W::AbstractMatrix, v::AbstractVector)</code></pre><p>Performs matrix-vector multiplication, where the matrix <code>W</code> acts as a linear transformation or window applied to the vector input <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: An abstract matrix representing the linear transformation or window.</li><li><code>v</code>: An abstract vector representing the input data.</li></ul><p><strong>Returns</strong></p><p>An abstract vector representing the result of the matrix-vector multiplication.</p><p><strong>Details</strong></p><p>This method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix <code>W</code> to the vector <code>v</code>.</p><p><strong>Formula</strong></p><p>The operation is defined as:</p><p class="math-container">\[\mathbf{c} = \mathbf{W} \mathbf{v}\]</p><p>or element-wise:</p><p class="math-container">\[c_i = \sum_j W_{ij} v_j\]</p><p><strong>See Also</strong></p><ul><li><a href="../api_external/#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T"><code>window_convolution(W::Array{T, 4}, v::Matrix) where {T}</code></a>: Method for a 4D kernel and matrix input.</li></ul><p><strong>References</strong></p><ul><li>The methodology for this type of window measurement is discussed in: <a href="https://arxiv.org/abs/1810.05051">arXiv:1810.05051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/projection.jl#L656-L688">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._transformed_weights" href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_transformed_weights(quadrature_rule, order, a, b)</code></pre><p>Transforms the points and weights of a standard quadrature rule from the interval <code>[-1, 1]</code> to a specified interval <code>[a, b]</code>.</p><p>This is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals <code>[a, b]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>quadrature_rule</code>: A function that takes an <code>order</code> and returns a tuple <code>(points, weights)</code>                    for the standard interval <code>[-1, 1]</code>.</li><li><code>order</code>: The order of the quadrature rule (number of points).</li><li><code>a</code>: The lower bound of the target interval.</li><li><code>b</code>: The upper bound of the target interval.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(transformed_points, transformed_weights)</code> for the interval <code>[a, b]</code>.</p><p><strong>Details</strong></p><p>The transformation is applied to the standard points <span>$x_i^{\text{std}}$</span> and weights <span>$w_i^{\text{std}}$</span> obtained from the <code>quadrature_rule</code>:</p><ul><li>Transformed points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span></li><li>Transformed weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></li></ul><p><strong>Formula</strong></p><p>The transformation formulas are: Points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span> Weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_0" href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_0(x)</code></pre><p>Calculates the 0th order Legendre polynomial, <span>$\mathcal{L}_0(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 0th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 0th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_0(x) = 1\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L311-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_2" href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_2(x)</code></pre><p>Calculates the 2nd order Legendre polynomial, <span>$\mathcal{L}_2(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 2nd order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 2nd order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_2(x) = \frac{1}{2} (3x^2 - 1)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L337-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_4" href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_4(x)</code></pre><p>Calculates the 4th order Legendre polynomial, <span>$\mathcal{L}_4(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 4th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 4th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_4(x) = \frac{1}{8} (35x^4 - 30x^2 + 3)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L364-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_interpolation-Tuple{Any, Any, Any}" href="#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>Effort._akima_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_interpolation(u, t, t_new)</code></pre><p>Evaluates the one-dimensional Akima spline that interpolates the data points <span>$(t_i, u_i)$</span> at new abscissae <code>t_new</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Ordinates (function values) <span>$u_i$</span> at the data nodes.</li><li><code>t</code>: Strictly increasing abscissae (knots) <span>$t_i$</span> associated with <code>u</code>. <code>length(t)</code> must equal <code>length(u)</code>.</li><li><code>t_new</code>: The query point(s) where the spline is to be evaluated.</li></ul><p><strong>Returns</strong></p><p>The interpolated value(s) at <code>t_new</code>. A scalar input returns a scalar; a vector input returns a vector of the same length.</p><p><strong>Details</strong></p><p>This routine implements the original Akima piecewise-cubic method (T. Akima, 1970). On each interval <span>$[t_j, t_{j+1}]$</span>, a cubic polynomial is constructed. The method uses a weighted average of slopes to determine the derivative at each node, which effectively dampens oscillations without explicit shape constraints. The resulting spline is <span>$C^1$</span> continuous (its first derivative is continuous) but generally not <span>$C^2$</span>.</p><p><strong>Formulae</strong></p><p>The spline on the interval <span>$[t_j, t_{j+1}]$</span> is a cubic polynomial: [ S<em>j(w) = u</em>j + b<em>j w + c</em>j w^{2} + d<em>j w^{3}, \qquad w = t - t</em>j ] The derivative <span>$b_j$</span> at each node is determined by Akima&#39;s weighting of local slopes <span>$m_j=(u_{j}-u_{j-1})/(t_j-t_{j-1})$</span>: [ b<em>j = \frac{|m</em>{j+1}-m<em>{j}|\,m</em>{j-1} + |m<em>{j-1}-m</em>{j-2}|\,m<em>{j}}             {|m</em>{j+1}-m<em>{j}| + |m</em>{j-1}-m<em>{j-2}|} ] The remaining coefficients, ``c</em>j<span>$and$</span>d<em>j``, are found by enforcing continuity of the first derivative: [ c</em>j = \frac{3m<em>j - 2b</em>j - b<em>{j+1}}{t</em>{j+1}-t<em>j} ] [ d</em>j = \frac{b<em>j + b</em>{j+1} - 2m<em>j}{(t</em>{j+1}-t_j)^2} ]</p><p><strong>Automatic Differentiation</strong></p><p>The implementation is free of mutation on the inputs and uses only element-wise arithmetic, making the returned value differentiable with both <code>ForwardDiff.jl</code> (dual numbers) and <code>Zygote.jl</code> (reverse-mode AD). You can therefore embed <code>_akima_interpolation</code> in optimization or machine-learning pipelines and back-propagate through the interpolation seamlessly.</p><p><strong>Notes</strong></p><p>The algorithm and numerical results are equivalent to the Akima spline in <code>DataInterpolations.jl</code>, but this routine is self-contained and avoids any package dependency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L96-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}" href="#Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}"><code>Effort._akima_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_interpolation(u::AbstractMatrix, t, t_new)</code></pre><p>Akima spline interpolation for multiple data series sharing the same x-coordinates. Uses a simple comprehension-based approach that is compatible with automatic differentiation.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code>: Data values with shape <code>(n_points, n_columns)</code>.</li><li><code>t</code>: X-coordinates shared by all columns.</li><li><code>t_new</code>: Query points.</li></ul><p><strong>Returns</strong></p><p>Matrix of interpolated values with shape <code>(length(t_new), n_columns)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Interpolate 11 Jacobian columns at 100 k-points
k_in = range(0.01, 0.3, length=50)
k_out = range(0.01, 0.3, length=100)
jacobian = randn(50, 11)  # 11 parameters

result = _akima_interpolation(jacobian, k_in, k_out)  # (100, 11)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L278-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_slopes-Tuple{AbstractMatrix, Any}" href="#Effort._akima_slopes-Tuple{AbstractMatrix, Any}"><code>Effort._akima_slopes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_slopes(u::AbstractMatrix, t)</code></pre><p>Optimized version of <code>_akima_slopes</code> for matrix input where each column represents a different data series but all share the same x-coordinates <code>t</code>.</p><p><strong>Performance Optimization</strong></p><p>Computes <code>dt = diff(t)</code> once and reuses it for all columns, avoiding redundant computation.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code>: Data values with shape <code>(n_points, n_columns)</code>.</li><li><code>t</code>: X-coordinates (same for all columns).</li></ul><p><strong>Returns</strong></p><p>Matrix of slopes with shape <code>(n_points + 3, n_columns)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_coefficients-Tuple{Any, AbstractMatrix}" href="#Effort._akima_coefficients-Tuple{Any, AbstractMatrix}"><code>Effort._akima_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_coefficients(t, m::AbstractMatrix)</code></pre><p>Optimized version of <code>_akima_coefficients</code> for matrix input where each column represents coefficients for a different spline series.</p><p><strong>Performance Optimization</strong></p><p>Computes <code>dt = diff(t)</code> once and reuses it for all columns.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: X-coordinates.</li><li><code>m::AbstractMatrix</code>: Slopes matrix with shape <code>(n_points + 3, n_columns)</code>.</li></ul><p><strong>Returns</strong></p><p>Tuple <code>(b, c, d)</code> where:</p><ul><li><code>b</code> is a matrix of shape <code>(n_points, n_columns)</code></li><li><code>c</code> and <code>d</code> are matrices of shape <code>(n_points - 1, n_columns)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L184-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_eval-Tuple{AbstractMatrix, Any, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractArray}" href="#Effort._akima_eval-Tuple{AbstractMatrix, Any, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractArray}"><code>Effort._akima_eval</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_eval(u::AbstractMatrix, t, b::AbstractMatrix, c::AbstractMatrix, d::AbstractMatrix, tq::AbstractArray)</code></pre><p>Optimized version of <code>_akima_eval</code> for matrix input where each column represents a different spline series.</p><p><strong>Performance Optimization</strong></p><ul><li>Finds intervals once per query point (not per column)</li><li>Computes polynomial weights once per query point</li><li>Broadcasts evaluation across all columns simultaneously</li></ul><p>This is significantly faster than calling the vector version in a loop.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code>: Data values with shape <code>(n_points, n_columns)</code>.</li><li><code>t</code>: X-coordinates.</li><li><code>b::AbstractMatrix</code>, <code>c::AbstractMatrix</code>, <code>d::AbstractMatrix</code>: Spline coefficients.</li><li><code>tq::AbstractArray</code>: Query points.</li></ul><p><strong>Returns</strong></p><p>Matrix of interpolated values with shape <code>(length(tq), n_columns)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L237-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.load_component_emulator" href="#Effort.load_component_emulator"><code>Effort.load_component_emulator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_component_emulator(path::String; emu=LuxEmulator, k_file=&quot;k.npy&quot;, weights_file=&quot;weights.npy&quot;, inminmax_file=&quot;inminmax.npy&quot;, outminmax_file=&quot;outminmax.npy&quot;, nn_setup_file=&quot;nn_setup.json&quot;, postprocessing_file=&quot;postprocessing_file.jl&quot;)</code></pre><p>Load a trained component emulator from disk.</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: Directory path containing the emulator files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>emu</code>: Emulator type to initialize (<code>LuxEmulator</code> or <code>SimpleChainsEmulator</code>). Default: <code>LuxEmulator</code>.</li><li><code>k_file::String</code>: Filename for the wavenumber grid. Default: <code>&quot;k.npy&quot;</code>.</li><li><code>weights_file::String</code>: Filename for neural network weights. Default: <code>&quot;weights.npy&quot;</code>.</li><li><code>inminmax_file::String</code>: Filename for input normalization parameters. Default: <code>&quot;inminmax.npy&quot;</code>.</li><li><code>outminmax_file::String</code>: Filename for output normalization parameters. Default: <code>&quot;outminmax.npy&quot;</code>.</li><li><code>nn_setup_file::String</code>: Filename for network architecture configuration. Default: <code>&quot;nn_setup.json&quot;</code>.</li><li><code>postprocessing_file::String</code>: Filename for postprocessing function. Default: <code>&quot;postprocessing_file.jl&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>ComponentEmulator</code> instance ready for evaluation.</p><p><strong>Details</strong></p><p>This function loads all necessary files to reconstruct a trained component emulator:</p><ol><li>Neural network architecture from JSON configuration.</li><li>Trained weights from NumPy binary format.</li><li>Normalization parameters for inputs and outputs.</li><li>Wavenumber grid.</li><li>Postprocessing function dynamically loaded from Julia file.</li></ol><p>The postprocessing function is evaluated in an isolated scope to prevent namespace pollution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">P11_emu = load_component_emulator(&quot;/path/to/emulator/11/&quot;)</code></pre><p><strong>File Structure</strong></p><p>The expected directory structure is:</p><pre><code class="nohighlight hljs">path/
├── k.npy                    # Wavenumber grid
├── weights.npy              # Neural network weights
├── inminmax.npy            # Input normalization (n_params × 2)
├── outminmax.npy           # Output normalization (n_k × 2)
├── nn_setup.json           # Network architecture
└── postprocessing_file.jl  # Postprocessing function</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L391-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.load_multipole_emulator" href="#Effort.load_multipole_emulator"><code>Effort.load_multipole_emulator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_multipole_emulator(path; emu=LuxEmulator, k_file=&quot;k.npy&quot;, weights_file=&quot;weights.npy&quot;, inminmax_file=&quot;inminmax.npy&quot;, outminmax_file=&quot;outminmax.npy&quot;, nn_setup_file=&quot;nn_setup.json&quot;, postprocessing_file=&quot;postprocessing.jl&quot;, stochmodel_file=&quot;stochmodel.jl&quot;, biascombination_file=&quot;biascombination.jl&quot;, jacbiascombination_file=&quot;jacbiascombination.jl&quot;)</code></pre><p>Load a complete power spectrum multipole emulator from disk.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Directory path containing the multipole emulator structure.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>emu</code>: Emulator type to initialize (<code>LuxEmulator</code> or <code>SimpleChainsEmulator</code>). Default: <code>LuxEmulator</code>.</li><li><code>k_file::String</code>: Filename for the wavenumber grid. Default: <code>&quot;k.npy&quot;</code>.</li><li><code>weights_file::String</code>: Filename for neural network weights. Default: <code>&quot;weights.npy&quot;</code>.</li><li><code>inminmax_file::String</code>: Filename for input normalization parameters. Default: <code>&quot;inminmax.npy&quot;</code>.</li><li><code>outminmax_file::String</code>: Filename for output normalization parameters. Default: <code>&quot;outminmax.npy&quot;</code>.</li><li><code>nn_setup_file::String</code>: Filename for network architecture configuration. Default: <code>&quot;nn_setup.json&quot;</code>.</li><li><code>postprocessing_file::String</code>: Filename for postprocessing function. Default: <code>&quot;postprocessing.jl&quot;</code>.</li><li><code>stochmodel_file::String</code>: Filename for stochastic model function. Default: <code>&quot;stochmodel.jl&quot;</code>.</li><li><code>biascombination_file::String</code>: Filename for bias combination function. Default: <code>&quot;biascombination.jl&quot;</code>.</li><li><code>jacbiascombination_file::String</code>: Filename for bias Jacobian function. Default: <code>&quot;jacbiascombination.jl&quot;</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>PℓEmulator</code> instance containing all three components (P11, Ploop, Pct) and bias models.</p><p><strong>Details</strong></p><p>This function loads a complete multipole emulator by:</p><ol><li>Loading three component emulators (P11, Ploop, Pct) from subdirectories.</li><li>Loading the stochastic model function (shot noise terms).</li><li>Loading the bias combination function (maps bias parameters to weights).</li><li>Loading the analytical Jacobian of the bias combination.</li></ol><p>All functions are evaluated in isolated scopes to prevent namespace conflicts between different emulator components.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load monopole emulator
monopole_emu = load_multipole_emulator(&quot;/path/to/artifact/0/&quot;)

# Evaluate
cosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]
bias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]
D = 0.8
P0 = get_Pℓ(cosmology, D, bias, monopole_emu)</code></pre><p><strong>File Structure</strong></p><p>The expected directory structure is:</p><pre><code class="nohighlight hljs">path/
├── 11/                       # P11 component
│   ├── k.npy
│   ├── weights.npy
│   ├── inminmax.npy
│   ├── outminmax.npy
│   ├── nn_setup.json
│   └── postprocessing.jl
├── loop/                     # Ploop component
│   └── ... (same structure)
├── ct/                       # Pct component
│   └── ... (same structure)
├── stochmodel.jl            # Stochastic model function
├── biascombination.jl       # Bias combination function
└── jacbiascombination.jl    # Bias Jacobian function</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Effort.load_component_emulator"><code>load_component_emulator</code></a>: Load individual component emulators.</li><li><a href="../example/#Effort.get_Pℓ"><code>get_Pℓ</code></a>: Evaluate the loaded emulator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/f277bd3c5e492d1c25f8ec293211163597b9083d/src/utils.jl#L465-L533">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_external/">« External API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 22 October 2025 21:02">Wednesday 22 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
