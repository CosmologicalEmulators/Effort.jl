<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API · Effort.jl</title><meta name="title" content="Internal API · Effort.jl"/><meta property="og:title" content="Internal API · Effort.jl"/><meta property="twitter:title" content="Internal API · Effort.jl"/><meta name="description" content="Documentation for Effort.jl."/><meta property="og:description" content="Documentation for Effort.jl."/><meta property="twitter:description" content="Documentation for Effort.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Effort.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Effort.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../api_external/">External API</a></li><li class="is-active"><a class="tocitem" href>Internal API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Projection"><span>Projection</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Internal API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/main/docs/src/api_internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This section documents the functions intended for internal usage by the package.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>Effort._D_f_z</code></a></li><li><a href="#Effort._D_f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._D_f_z</code></a></li><li><a href="#Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._D_z</code></a></li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>Effort._D_z</code></a></li><li><a href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>Effort._D_z</code></a></li><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>Effort._E_a</code></a></li><li><a href="#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._E_a</code></a></li><li><a href="#Effort._E_z-Tuple{Any, Any, Any}"><code>Effort._E_z</code></a></li><li><a href="#Effort._E_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._E_z</code></a></li><li><a href="#Effort._F"><code>Effort._F</code></a></li><li><a href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a></li><li><a href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a></li><li><a href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a></li><li><a href="#Effort._P_obs"><code>Effort._P_obs</code></a></li><li><a href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a></li><li><a href="#Effort._Pkμ"><code>Effort._Pkμ</code></a></li><li><a href="#Effort._a_z"><code>Effort._a_z</code></a></li><li><a href="#Effort._akima_spline"><code>Effort._akima_spline</code></a></li><li><a href="#Effort._akima_spline_legacy"><code>Effort._akima_spline_legacy</code></a></li><li><a href="#Effort._cubic_spline"><code>Effort._cubic_spline</code></a></li><li><a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>Effort._dA_z</code></a></li><li><a href="#Effort._dA_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._dA_z</code></a></li><li><a href="#Effort._dFdy"><code>Effort._dFdy</code></a></li><li><a href="#Effort._dlogEdloga"><code>Effort._dlogEdloga</code></a></li><li><a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>Effort._d̃A_z</code></a></li><li><a href="#Effort._d̃A_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._d̃A_z</code></a></li><li><a href="#Effort._dΩνE2da-Tuple{Any, Any, AbstractVector}"><code>Effort._dΩνE2da</code></a></li><li><a href="#Effort._dΩνE2da-Tuple{Any, Any, Any}"><code>Effort._dΩνE2da</code></a></li><li><a href="#Effort._dρDEda"><code>Effort._dρDEda</code></a></li><li><a href="#Effort._f_z-Tuple{Any, Any, Any}"><code>Effort._f_z</code></a></li><li><a href="#Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._f_z</code></a></li><li><a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>Effort._f_z</code></a></li><li><a href="#Effort._get_y"><code>Effort._get_y</code></a></li><li><a href="#Effort._growth!"><code>Effort._growth!</code></a></li><li><a href="#Effort._growth_solver-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._growth_solver</code></a></li><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>Effort._growth_solver</code></a></li><li><a href="#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}"><code>Effort._growth_solver</code></a></li><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>Effort._growth_solver</code></a></li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a></li><li><a href="#Effort._quadratic_spline"><code>Effort._quadratic_spline</code></a></li><li><a href="#Effort._r_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._r_z</code></a></li><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>Effort._r_z</code></a></li><li><a href="#Effort._r_z_check-Tuple{Any, Any, Any}"><code>Effort._r_z_check</code></a></li><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>Effort._r̃_z</code></a></li><li><a href="#Effort._r̃_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._r̃_z</code></a></li><li><a href="#Effort._r̃_z_check"><code>Effort._r̃_z_check</code></a></li><li><a href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a></li><li><a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>Effort._Ωma</code></a></li><li><a href="#Effort._Ωma-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._Ωma</code></a></li><li><a href="#Effort._ΩνE2-Tuple{Any, Any, AbstractVector}"><code>Effort._ΩνE2</code></a></li><li><a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>Effort._ΩνE2</code></a></li><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a></li><li><a href="#Effort._ρDE_a"><code>Effort._ρDE_a</code></a></li><li><a href="#Effort._ρDE_z"><code>Effort._ρDE_z</code></a></li><li><a href="#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}"><code>Effort.apply_AP_check</code></a></li><li><a href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a></li></ul><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._F" href="#Effort._F"><code>Effort._F</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_F(y)</code></pre><p><strong>Arguments</strong></p><ul><li><code>y</code>: The value of the parameter <code>y</code> for which the integral is calculated.</li></ul><p><strong>Returns</strong></p><p>The value of the definite integral for the given <code>y</code>.</p><p><strong>Details</strong></p><p>The integrand is defined as: <span>$f(x, y) = x^2 \cdot \sqrt{x^2 + y^2} / (1 + e^x)$</span></p><p>The integration is performed over the domain <code>(0, Inf)</code> for the variable <code>x</code>. A relative tolerance of <code>1e-12</code> is used for the integration solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L32-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dFdy" href="#Effort._dFdy"><code>Effort._dFdy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dFdy(y)</code></pre><p>Calculates the definite integral of the function <span>$f(x, y) = x^2 / ((1 + e^x) \cdot \sqrt{x^2 + y^2})$</span> with respect to <code>x</code> from <code>0</code> to <code>Inf</code>, and then multiplies the result by <code>y</code>.</p><p>This function is the derivative of the integral function <a href="#Effort._F"><code>_F(y)</code></a> with respect to <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: The value of the parameter <code>y</code> used in the integrand and as a multiplicative factor.</li></ul><p><strong>Returns</strong></p><p>The value of the definite integral multiplied by <code>y</code> for the given <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L81-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._get_y" href="#Effort._get_y"><code>Effort._get_y</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_y(mν, a; kB=8.617342e-5, Tν=0.71611 * 2.7255)</code></pre><p>Calculates the dimensionless parameter <code>y</code> used in the integral function <a href="#Effort._F"><code>_F(y)</code></a>.</p><p>The parameter <code>y</code> is calculated based on the neutrino mass, scale factor, Boltzmann constant, and neutrino temperature according to the formula:</p><p><code>y = mν * a / (kB * Tν)</code></p><p><strong>Arguments</strong></p><ul><li><code>mν</code>: Neutrino mass (in units where <code>kB</code> and <code>Tν</code> are defined).</li><li><code>a</code>: Scale factor.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kB</code>: Boltzmann constant (default: 8.617342e-5 eV/K).</li><li><code>Tν</code>: Neutrino temperature (default: 0.71611 * 2.7255 K).</li></ul><p><strong>Returns</strong></p><p>The calculated dimensionless parameter <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L56-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._ΩνE2-Tuple{Any, Any, Any}" href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>Effort._ΩνE2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_ΩνE2(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)</code></pre><p>Calculates the energy density of relic neutrinos, scaled by the critical density, at a given scale factor <code>a</code>, for a <em>single</em> neutrino mass.</p><p>This function accounts for the contribution of a single neutrino mass <code>mν</code> to the total energy density. It uses <a href="#Effort._F"><code>_F(y)</code></a> to incorporate the effect of neutrino mass and temperature.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor.</li><li><code>Ωγ0</code>: The photon density parameter today.</li><li><code>mν</code>: The neutrino mass (a single value).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kB</code>: Boltzmann constant (default: 8.617342e-5 eV/K).</li><li><code>Tν</code>: Neutrino temperature (default: 0.71611 * 2.7255 K).</li><li><code>Neff</code>: Effective number of neutrino species (default: 3.044).</li></ul><p><strong>Returns</strong></p><p>The calculated neutrino energy density parameter <code>ΩνE2</code> at scale factor <code>a</code> for the given mass.</p><p><strong>Details</strong></p><p>The calculation involves a factor <code>Γν</code> derived from <code>Neff</code> and the ratio of neutrino to photon temperatures. The main term is proportional to <code>Ωγ0 / a^4</code> multiplied by <code>F_interpolant(_get_y(mν, a))</code>.</p><p>The parameter <code>y</code> passed to <code>F_interpolant</code> is calculated using <a href="#Effort._get_y"><code>_get_y(mν, a)</code></a>.</p><p><strong>Formula</strong></p><p>The formula used is: <code>ΩνE2 = (15 / π^4) * Γν^4 * (Ωγ0 / a^4) * F(y)</code> where <code>Γν = (4/11)^(1/3) * (Neff/3)^(1/4)</code> and <code>y = mν * a / (kB * Tν)</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._get_y"><code>_get_y(mν, a)</code></a>: Calculates the <code>y</code> parameter.</li><li><a href="#Effort._F"><code>_F(y)</code></a>: The integral function used as <code>F_interpolant</code>.</li><li><a href="#Effort._ΩνE2-Tuple{Any, Any, AbstractVector}"><code>_ΩνE2(a, Ωγ0, mν::AbstractVector)</code></a>: Method for a vector of neutrino masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L104-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._ΩνE2-Tuple{Any, Any, AbstractVector}" href="#Effort._ΩνE2-Tuple{Any, Any, AbstractVector}"><code>Effort._ΩνE2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_ΩνE2(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)</code></pre><p>Calculates the energy density of relic neutrinos, scaled by the critical density, at a given scale factor <code>a</code>, for a <em>vector</em> of neutrino masses.</p><p>This function accounts for the combined contribution of multiple neutrino masses to the total energy density by summing the individual contributions. It uses the <code>F_interpolant</code> function (which is equivalent to <a href="#Effort._F"><code>_F(y)</code></a>) for each mass.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor.</li><li><code>Ωγ0</code>: The photon density parameter today.</li><li><code>mν</code>: A vector of neutrino masses (<code>AbstractVector</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kB</code>: Boltzmann constant (default: 8.617342e-5 eV/K).</li><li><code>Tν</code>: Neutrino temperature (default: 0.71611 * 2.7255 K).</li><li><code>Neff</code>: Effective number of neutrino species (default: 3.044).</li></ul><p><strong>Returns</strong></p><p>The calculated total neutrino energy density parameter <code>ΩνE2</code> at scale factor <code>a</code> for the sum of contributions from all masses in the vector.</p><p><strong>Details</strong></p><p>The calculation involves a factor <code>Γν</code> derived from <code>Neff</code> and the ratio of neutrino to photon temperatures. The main term is proportional to <code>Ωγ0 / a^4</code> multiplied by the sum of <code>F_interpolant(_get_y(mν_i, a))</code> for each mass <code>mν_i</code> in the input vector <code>mν</code>.</p><p>The parameter <code>y</code> passed to <code>F_interpolant</code> for each mass is calculated using <a href="#Effort._get_y"><code>_get_y(mν_i, a)</code></a>.</p><p><strong>Formula</strong></p><p>The formula used is: <code>ΩνE2 = (15 / π^4) * Γν^4 * (Ωγ0 / a^4) * Σ F(y_i)</code> where <code>Γν = (4/11)^(1/3) * (Neff/3)^(1/4)</code> and <code>y_i = mν_i * a / (kB * Tν)</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._get_y"><code>_get_y(mν, a)</code></a>: Calculates the <code>y</code> parameter for each mass.</li><li><a href="#Effort._F"><code>_F(y)</code></a>: The integral function used as <code>F_interpolant</code>.</li><li><a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>_ΩνE2(a, Ωγ0, mν)</code></a>: Method for a single neutrino mass.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L148-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dΩνE2da-Tuple{Any, Any, Any}" href="#Effort._dΩνE2da-Tuple{Any, Any, Any}"><code>Effort._dΩνE2da</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dΩνE2da(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)</code></pre><p>Calculates the derivative of the neutrino energy density parameter <a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>_ΩνE2</code></a> with respect to the scale factor <code>a</code>, for a <em>single</em> neutrino mass.</p><p>This function computes the derivative of the expression for <code>_ΩνE2</code> by applying the chain rule, involving both <a href="#Effort._F"><code>_F(y)</code></a> and <a href="#Effort._dFdy"><code>_dFdy(y)</code></a> functions.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor.</li><li><code>Ωγ0</code>: The photon density parameter today.</li><li><code>mν</code>: The neutrino mass (a single value).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kB</code>: Boltzmann constant (default: 8.617342e-5 eV/K).</li><li><code>Tν</code>: Neutrino temperature (default: 0.71611 * 2.7255 K).</li><li><code>Neff</code>: Effective number of neutrino species (default: 3.044).</li></ul><p><strong>Returns</strong></p><p>The calculated derivative <code>d(ΩνE2)/da</code> at scale factor <code>a</code> for the given mass.</p><p><strong>Details</strong></p><p>The calculation is based on the derivative of the <code>_ΩνE2</code> formula with respect to <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>_ΩνE2(a, Ωγ0, mν)</code></a>: The function whose derivative is calculated.</li><li><a href="#Effort._get_y"><code>_get_y(mν, a)</code></a>: Calculates the <code>y</code> parameter.</li><li><a href="#Effort._F"><code>_F(y)</code></a>: The integral function used as <code>F_interpolant</code>.</li><li><a href="#Effort._dFdy"><code>_dFdy(y)</code></a>: The function used as <code>dFdy_interpolant</code>.</li><li><a href="#Effort._dΩνE2da-Tuple{Any, Any, AbstractVector}"><code>_dΩνE2da(a, Ωγ0, mν::AbstractVector)</code></a>: Method for a vector of neutrino masses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L200-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dΩνE2da-Tuple{Any, Any, AbstractVector}" href="#Effort._dΩνE2da-Tuple{Any, Any, AbstractVector}"><code>Effort._dΩνE2da</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dΩνE2da(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)</code></pre><p>Calculates the derivative of the neutrino energy density parameter <a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>_ΩνE2</code></a> with respect to the scale factor <code>a</code>, for a <em>vector</em> of neutrino masses.</p><p>This function computes the derivative of the expression for <code>_ΩνE2</code> by summing the derivatives of the contributions from each individual neutrino mass. It uses the <a href="#Effort._F"><code>_F(y)</code></a> and <a href="#Effort._dFdy"><code>_dFdy(y)</code></a> functions for each mass.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor.</li><li><code>Ωγ0</code>: The photon density parameter today.</li><li><code>mν</code>: A vector of neutrino masses (<code>AbstractVector</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kB</code>: Boltzmann constant (default: 8.617342e-5 eV/K).</li><li><code>Tν</code>: Neutrino temperature (default: 0.71611 * 2.7255 K).</li><li><code>Neff</code>: Effective number of neutrino species (default: 3.044).</li></ul><p><strong>Returns</strong></p><p>The calculated total derivative <code>d(ΩνE2)/da</code> at scale factor <code>a</code> for the sum of contributions from all masses in the vector.</p><p><strong>Details</strong></p><p>The calculation sums the derivatives of the individual neutrino mass contributions to <code>_ΩνE2</code> with respect to <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ΩνE2-Tuple{Any, Any, AbstractVector}"><code>_ΩνE2(a, Ωγ0, mν::AbstractVector)</code></a>: The function whose derivative is calculated.</li><li><a href="#Effort._get_y"><code>_get_y(mν, a)</code></a>: Calculates the <code>y</code> parameter for each mass.</li><li><a href="#Effort._F"><code>_F(y)</code></a>: The integral function used as <code>F_interpolant</code>.</li><li><a href="#Effort._dFdy"><code>_dFdy(y)</code></a>: The function used as <code>dFdy_interpolant</code>.</li><li><a href="#Effort._dΩνE2da-Tuple{Any, Any, Any}"><code>_dΩνE2da(a, Ωγ0, mν)</code></a>: Method for a single neutrino mass.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L239-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._a_z" href="#Effort._a_z"><code>Effort._a_z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_a_z(z)</code></pre><p>Calculates the cosmological scale factor <code>a</code> from the redshift <code>z</code>.</p><p>The relationship between scale factor and redshift is given by <span>$a = 1 / (1 + z)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li></ul><p><strong>Returns</strong></p><p>The corresponding scale factor <code>a</code> (scalar or array).</p><p><strong>Formula</strong></p><p>The formula used is: <span>$a = 1 / (1 + z)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L284-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._ρDE_a" href="#Effort._ρDE_a"><code>Effort._ρDE_a</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_ρDE_a(a, w0, wa)</code></pre><p>Calculates the evolution of the dark energy density parameter relative to its value today, as a function of the scale factor <code>a</code>.</p><p>This function implements the standard parametrization for the dark energy equation of state <code>w(a) = w0 + wa*(1-a)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>w0</code>: The present-day value of the dark energy equation of state parameter.</li><li><code>wa</code>: The derivative of the dark energy equation of state parameter with respect to <code>(1-a)</code>.</li></ul><p><strong>Returns</strong></p><p>The dark energy density parameter relative to its value today, <code>ρ_DE(a) / ρ_DE(a=1)</code>, at the given scale factor <code>a</code> (scalar or array).</p><p><strong>Formula</strong></p><p>The formula used is: <span>$\rho_\mathrm{DE}(a) / \rho_\mathrm{DE}(a=1) = a^(-3 * (1 + w0 + wa)) * e^{3 * wa * (a - 1)}$</span></p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ρDE_z"><code>_ρDE_z(z, w0, wa)</code></a>: Calculates the dark energy density evolution as a function of redshift <code>z</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L305-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._ρDE_z" href="#Effort._ρDE_z"><code>Effort._ρDE_z</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_ρDE_z(z, w0, wa)</code></pre><p>Calculates the evolution of the dark energy density parameter relative to its value today, as a function of the redshift <code>z</code>.</p><p>This function implements the standard parametrization for the dark energy equation of state <span>$w(a) = w0 + wa*(1-a)$</span>, converted to depend on redshift <code>z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0</code>: The present-day value of the dark energy equation of state parameter.</li><li><code>wa</code>: The derivative of the dark energy equation of state parameter with respect to <code>(1-a)</code>.</li></ul><p><strong>Returns</strong></p><p>The dark energy density parameter relative to its value today, <code>ρ_DE(z) / ρ_DE(z=0)</code>, at the given redshift <code>z</code> (scalar or array).</p><p><strong>Formula</strong></p><p>The formula used is: <span>$\rho_\mathrm{DE}(z) / \rho_\mathrm{DE}(z=0) = (1 + z)^(3 * (1 + w0 + wa)) * e^{-3 * wa * z / (1 + z)}$</span></p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>z</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ρDE_a"><code>_ρDE_a(a, w0, wa)</code></a>: Calculates the dark energy density evolution as a function of scale factor <code>a</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L336-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dρDEda" href="#Effort._dρDEda"><code>Effort._dρDEda</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dρDEda(a, w0, wa)</code></pre><p>Calculates the derivative of the dark energy density parameter evolution, <code>d(ρ_DE(a)/ρ_DE(a=1))/da</code>, with respect to the scale factor <code>a</code>.</p><p>This function computes the derivative of the formula implemented in <a href="#Effort._ρDE_a"><code>_ρDE_a(a, w0, wa)</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>w0</code>: The present-day value of the dark energy equation of state parameter.</li><li><code>wa</code>: The derivative of the dark energy equation of state parameter with respect to <code>(1-a)</code>.</li></ul><p><strong>Returns</strong></p><p>The calculated derivative of the dark energy density parameter evolution with respect to <code>a</code> at the given scale factor <code>a</code> (scalar or array).</p><p><strong>Formula</strong></p><p>The formula used is: <span>$\frac{d}{da} \left( \frac{\rho_{\text{DE}}(a)}{\rho_{\text{DE}}(a=1)} \right) = 3 \left( -\frac{1 + w_0 + w_a}{a} + w_a \right) \frac{\rho_{\text{DE}}(a)}{\rho_{\text{DE}}(a=1)}$</span></p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ρDE_a"><code>_ρDE_a(a, w0, wa)</code></a>: Calculates the dark energy density evolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L367-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._E_a-Tuple{Any, Any, Any}" href="#Effort._E_a-Tuple{Any, Any, Any}"><code>Effort._E_a</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_E_a(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the normalized Hubble parameter, <code>E(a)</code>, at a given scale factor <code>a</code>.</p><p><code>E(a)</code> describes the expansion rate of the universe relative to the Hubble constant today, incorporating contributions from different energy density components: radiation (photons and massless neutrinos), cold dark matter and baryons, dark energy, and massive neutrinos.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: The total neutrino mass (or a vector of masses), used in the calculation of the       massive neutrino energy density. Defaults to 0.0 (massless neutrinos).</li><li><code>w0</code>: The present-day value of the dark energy equation of state parameter <code>w(a) = w0 + wa*(1-a)</code>. Defaults to -1.0 (ΛCDM).</li><li><code>wa</code>: The derivative of the dark energy equation of state parameter with respect to <code>(1-a)</code>. Defaults to 0.0 (ΛCDM).</li></ul><p><strong>Returns</strong></p><p>The calculated normalized Hubble parameter <code>E(a)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The calculation includes:</p><ul><li>Photon density <code>Ωγ0 = 2.469e-5 / h^2</code>.</li><li>Massless neutrino density <code>Ων0</code> (calculated from <code>_ΩνE2</code> at a=1).</li><li>Dark energy density <code>ΩΛ0</code> (calculated to ensure a flat universe: <code>1 - Ωγ0 - Ωcb0 - Ων0</code>).</li><li>Massive neutrino density <code>_ΩνE2(a, Ωγ0, mν)</code>.</li><li>Dark energy evolution <code>_ρDE_a(a, w0, wa)</code> (density relative to today&#39;s dark energy density).</li></ul><p>The formula used is: <code>E(a) = sqrt(Ωγ0 * a^-4 + Ωcb0 * a^-3 + ΩΛ0 * ρDE(a) + ΩνE2(a))</code> where <code>ρDE(a)</code> is the dark energy density relative to its value today, and <code>ΩνE2(a)</code> is the massive neutrino energy density parameter at scale factor <code>a</code>.</p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._ΩνE2-Tuple{Any, Any, Any}"><code>_ΩνE2(a, Ωγ0, mν)</code></a>: Calculates the massive neutrino energy density.</li><li><a href="#Effort._ρDE_a"><code>_ρDE_a(a, w0, wa)</code></a>: Calculates the dark energy density evolution (relative to today).</li><li><a href="#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}"><code>_E_a(a, w0wacosmo::w0waCDMCosmology)</code></a>: Convenience method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L397-L439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._E_a</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_E_a(a, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the normalized Hubble parameter, <code>E(a)</code>, at a given scale factor <code>a</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the main <code>_E_a</code> function. It extracts the cold dark matter and baryon density (<code>Ωcb0</code>), Hubble parameter (<code>h</code>), neutrino mass (<code>mν</code>), and dark energy parameters (<code>w0</code>, <code>wa</code>) from the provided cosmology struct and passes them to the primary <code>_E_a</code> method.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated normalized Hubble parameter <code>E(a)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>: The primary method that performs the calculation.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L447-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._E_z-Tuple{Any, Any, Any}" href="#Effort._E_z-Tuple{Any, Any, Any}"><code>Effort._E_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_E_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the normalized Hubble parameter, <code>E(z)</code>, as a function of redshift <code>z</code>.</p><p>This function is the redshift-dependent counterpart to <a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>. It first converts <code>z</code> to the scale factor <code>a</code> using <a href="#Effort._a_z"><code>_a_z(z)</code></a> and then calls the <code>_E_a</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated normalized Hubble parameter <code>E(z)</code> (scalar or array).</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>: The corresponding scale factor dependent function.</li><li><a href="#Effort._a_z"><code>_a_z(z)</code></a>: Converts redshift to scale factor.</li><li><a href="#Effort._E_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_E_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L480-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._E_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._E_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._E_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_E_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the normalized Hubble parameter, <code>E(z)</code>, as a function of redshift <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This function is the redshift-dependent counterpart to <a href="#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}"><code>_E_a(a, w0wacosmo::w0waCDMCosmology)</code></a>. It&#39;s a convenience method that extracts parameters from the struct and calls the primary <a href="#Effort._E_z-Tuple{Any, Any, Any}"><code>_E_z(z, Ωcb0, h; mν, w0, wa)</code></a> method.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated normalized Hubble parameter <code>E(z)</code> (scalar or array).</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}"><code>_E_a(a, w0wacosmo::w0waCDMCosmology)</code></a>: The corresponding scale factor dependent function using a struct.</li><li><a href="#Effort._E_z-Tuple{Any, Any, Any}"><code>_E_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method using individual parameters.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L512-L533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dlogEdloga" href="#Effort._dlogEdloga"><code>Effort._dlogEdloga</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dlogEdloga(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the logarithmic derivative of the normalized Hubble parameter, <span>$\frac{d(\log E)}{d(\log a)}$</span>, with respect to the logarithm of the scale factor <code>a</code>.</p><p>This quantity is useful in cosmological calculations, particularly when analyzing the growth of structure. It is derived from the derivative of <code>E(a)</code> with respect to <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated value of <span>$\frac{d(\log E)}{d(\log a)}$</span> at the given scale factor <code>a</code> (scalar or array).</p><p><strong>Details</strong></p><p>The calculation involves the derivative of the <code>_E_a</code> function with respect to <code>a</code>. The formula is derived from <span>$\frac{d(\log E)}{d(\log a)} = \frac{a}{E} \frac{dE}{da}$</span>. The derivative <code>dE/da</code> involves terms related to the derivatives of the density components with respect to <code>a</code>, including <a href="#Effort._dρDEda"><code>_dρDEda(a, w0, wa)</code></a> and <a href="#Effort._dΩνE2da-Tuple{Any, Any, Any}"><code>_dΩνE2da(a, Ωγ0, mν)</code></a>.</p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>: The normalized Hubble parameter function.</li><li><a href="#Effort._dΩνE2da-Tuple{Any, Any, Any}"><code>_dΩνE2da(a, Ωγ0, mν)</code></a>: Derivative of the neutrino energy density.</li><li><a href="#Effort._ρDE_a"><code>_ρDE_a(a, w0, wa)</code></a>: Dark energy density evolution (relative to today).</li><li><a href="#Effort._dρDEda"><code>_dρDEda(a, w0, wa)</code></a>: Derivative of the dark energy density evolution (relative to today).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L539-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Ωma-Tuple{Any, Any, Any}" href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>Effort._Ωma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Ωma(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the total matter density parameter, <code>Ω_m(a)</code>, at a given scale factor <code>a</code>.</p><p>This represents the combined density of cold dark matter and baryons relative to the critical density at scale factor <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es) (used in the calculation of <code>_E_a</code>).</li><li><code>w0</code>: Dark energy equation of state parameter (used in the calculation of <code>_E_a</code>).</li><li><code>wa</code>: Dark energy equation of state parameter derivative (used in the calculation of <code>_E_a</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated total matter density parameter <code>Ω_m(a)</code> at the given scale factor <code>a</code> (scalar or array).</p><p><strong>Formula</strong></p><p>The formula used is: <span>$\Omega_m(a) = \frac{\Omega_{\text{cb}0} a^{-3}}{E(a)^2}$</span> where <span>$E(a)$</span> is the normalized Hubble parameter calculated using <a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>.</p><p>This function uses broadcasting (<code>@.</code>) to handle scalar or array inputs for <code>a</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a(a, Ωcb0, h; mν, w0, wa)</code></a>: The normalized Hubble parameter function.</li><li><a href="#Effort._Ωma-Tuple{Any, Effort.w0waCDMCosmology}"><code>_Ωma(a, w0wacosmo::w0waCDMCosmology)</code></a>: Convenience method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L583-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Ωma-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._Ωma-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._Ωma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Ωma(a, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the total matter density parameter, <code>Ω_m(a)</code>, at a given scale factor <code>a</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>_Ωma(a, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the cold dark matter and baryon density (<code>Ωcb0</code>), Hubble parameter (<code>h</code>), neutrino mass (<code>mν</code>), and dark energy parameters (<code>w0</code>, <code>wa</code>) from the provided cosmology struct and passes them to the primary <code>_Ωma</code> method.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: The scale factor (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated total matter density parameter <code>Ω_m(a)</code> at the given scale factor <code>a</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>_Ωma(a, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>_Ωma(a, Ωcb0, h; mν, w0, wa)</code></a>: The primary method that performs the calculation.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L619-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r̃_z_check" href="#Effort._r̃_z_check"><code>Effort._r̃_z_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r̃_z_check(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the conformal distance <code>r̃(z)</code> to a given redshift <code>z</code> using numerical integration.</p><p>This is a &quot;check&quot; version, typically slower but potentially more accurate, used for verifying results from faster methods. The conformal distance is the integral of <code>1/E(z)</code> with respect to <code>z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated conformal distance <code>r̃(z)</code> (scalar).</p><p><strong>Details</strong></p><p>The function calculates the integral <span>$\int_0^z \frac{dz&#39;}{E(z&#39;)}$</span> where <span>$E(z&#39;)$</span> is the normalized Hubble parameter at redshift <span>$z&#39;$</span>, calculated using <a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a</code></a> after converting <span>$z&#39;$</span> to scale factor using <a href="#Effort._a_z"><code>_a_z</code></a>. The integration is performed using <code>IntegralProblem</code> and the <code>QuadGKJL()</code> solver.</p><p><strong>Formula</strong></p><p>The conformal distance is defined as: <span>$\tilde{r}(z) = \int_0^z \frac{dz&#39;}{E(z&#39;)}$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a>: The standard, faster method for calculating conformal distance.</li><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a</code></a>: Calculates the normalized Hubble parameter as a function of scale factor.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li><li><a href="#Effort._r_z_check-Tuple{Any, Any, Any}"><code>_r_z_check</code></a>: Calculates the comoving distance using this check version.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L652-L688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r̃_z-Tuple{Any, Any, Any}" href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>Effort._r̃_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r̃_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the conformal distance <code>r̃(z)</code> to a given redshift <code>z</code> using Gauss-Legendre quadrature.</p><p>This is the standard, faster method for calculating the conformal distance, which is the integral of <code>1/E(z)</code> with respect to <code>z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated conformal distance <code>r̃(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The function approximates the integral <span>$\int_0^z \frac{dz&#39;}{E(z&#39;)}$</span> using Gauss-Legendre quadrature with a specified number of points (here, 9). It uses <a href="#Effort._transformed_weights"><code>_transformed_weights</code></a> to get the quadrature points and weights over the interval <code>[0, z]</code>. The integrand <span>$1/E(z&#39;)$</span> is evaluated at these points using <a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a</code></a> (after converting <code>z&#39;</code> to <code>a</code> with <a href="#Effort._a_z"><code>_a_z</code></a>), and the result is a weighted sum.</p><p><strong>Formula</strong></p><p>The conformal distance is defined as: <span>$\tilde{r}(z) = \int_0^z \frac{dz&#39;}{E(z&#39;)}$</span> This function computes this integral numerically.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z_check"><code>_r̃_z_check</code></a>: A slower, check version using different integration.</li><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a</code></a>: Calculates the normalized Hubble parameter as a function of scale factor.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li><li><a href="#Effort._transformed_weights"><code>_transformed_weights</code></a>: Generates quadrature points and weights.</li><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z</code></a>: Calculates the comoving distance.</li><li><a href="#Effort._r̃_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_r̃_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L698-L738">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r̃_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._r̃_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._r̃_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r̃_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the conformal distance <code>r̃(z)</code> to a given redshift <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z(z, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated conformal distance <code>r̃(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z(z, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method for calculating conformal distance.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z</code></a>: Calculates the comoving distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L745-L771">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r_z_check-Tuple{Any, Any, Any}" href="#Effort._r_z_check-Tuple{Any, Any, Any}"><code>Effort._r_z_check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r_z_check(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the comoving distance <code>r(z)</code> to a given redshift <code>z</code> using the &quot;check&quot; version of the conformal distance calculation.</p><p>The comoving distance is related to the conformal distance by a factor involving the speed of light and the Hubble parameter today. This version uses the slower, potentially more accurate <a href="#Effort._r̃_z_check"><code>_r̃_z_check</code></a> for the conformal distance.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated comoving distance <code>r(z)</code> (scalar).</p><p><strong>Details</strong></p><p>The comoving distance is calculated by scaling the conformal distance obtained from <a href="#Effort._r̃_z_check"><code>_r̃_z_check(z, Ωcb0, h; mν, w0, wa)</code></a> by the factor <span>$c_0 / (100 h)$</span>, where <span>$c_0$</span> is the speed of light (in units consistent with <code>h</code>).</p><p><strong>Formula</strong></p><p>The comoving distance is defined as: <span>$r(z) = \frac{c_0}{100 h} \tilde{r}(z)$</span> This function uses <span>$\tilde{r}(z) = \text{_r̃_z_check}(z, \dots)$</span>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z_check"><code>_r̃_z_check</code></a>: The slower, check version of the conformal distance calculation.</li><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z</code></a>: The standard, faster method for calculating comoving distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L777-L813">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r_z-Tuple{Any, Any, Any}" href="#Effort._r_z-Tuple{Any, Any, Any}"><code>Effort._r_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the comoving distance <code>r(z)</code> to a given redshift <code>z</code> using the standard conformal distance calculation.</p><p>The comoving distance is related to the conformal distance by a factor involving the speed of light and the Hubble parameter today. This version uses the standard, faster <a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a> for the conformal distance.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated comoving distance <code>r(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The comoving distance is calculated by scaling the conformal distance obtained from <a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z(z, Ωcb0, h; mν, w0, wa)</code></a> by the factor <span>$c_0 / (100 h)$</span>, where <span>$c_0$</span> is the speed of light (in units consistent with <code>h</code>).</p><p><strong>Formula</strong></p><p>The comoving distance is defined as: <span>$r(z) = \frac{c_0}{100 h} \tilde{r}(z)$</span> This function uses <span>$\tilde{r}(z) = \text{_r̃_z}(z, \dots)$</span>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a>: The standard, faster method for calculating conformal distance.</li><li><a href="#Effort._r_z_check-Tuple{Any, Any, Any}"><code>_r_z_check</code></a>: A slower, check version using a different conformal distance calculation.</li><li><a href="#Effort._r_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_r_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L818-L855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._r_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._r_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._r_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_r_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the comoving distance <code>r(z)</code> to a given redshift <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z(z, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated comoving distance <code>r(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z(z, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method for calculating comoving distance.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a>: Calculates the conformal distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L860-L886">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._d̃A_z-Tuple{Any, Any, Any}" href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>Effort._d̃A_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_d̃A_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the conformal angular diameter distance <code>d̃_A(z)</code> to a given redshift <code>z</code>.</p><p>The conformal angular diameter distance is defined as the conformal comoving distance divided by <code>(1 + z)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated conformal angular diameter distance <code>d̃_A(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The function calculates the conformal comoving distance using <a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z(z, Ωcb0, h; mν, w0, wa)</code></a> and then divides by <code>(1 + z)</code>.</p><p><strong>Formula</strong></p><p>The formula used is: <span>$\tilde{d}_A(z) = \frac{\tilde{r}(z)}{1 + z}$</span> where <span>$\tilde{r}(z)$</span> is the conformal comoving distance.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a>: Calculates the conformal comoving distance.</li><li><a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>_dA_z</code></a>: Calculates the standard angular diameter distance.</li><li><a href="#Effort._d̃A_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_d̃A_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L892-L926">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._d̃A_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._d̃A_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._d̃A_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_d̃A_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the conformal angular diameter distance <code>d̃_A(z)</code> to a given redshift <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>_d̃A_z(z, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated conformal angular diameter distance <code>d̃_A(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>_d̃A_z(z, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>_d̃A_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method for calculating conformal angular diameter distance.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>_dA_z</code></a>: Calculates the standard angular diameter distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L931-L957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dA_z-Tuple{Any, Any, Any}" href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>Effort._dA_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dA_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the angular diameter distance <code>d_A(z)</code> to a given redshift <code>z</code>.</p><p>The angular diameter distance is defined as the comoving distance divided by <code>(1 + z)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated angular diameter distance <code>d_A(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The function calculates the comoving distance using <a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z(z, Ωcb0, h; mν, w0, wa)</code></a> and then divides by <code>(1 + z)</code>.</p><p><strong>Formula</strong></p><p>The formula used is: <span>$d_A(z) = \frac{r(z)}{1 + z}$</span> where <span>$r(z)$</span> is the comoving distance.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r_z-Tuple{Any, Any, Any}"><code>_r_z</code></a>: Calculates the comoving distance.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li><li><a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>_d̃A_z</code></a>: Calculates the conformal angular diameter distance.</li><li><a href="#Effort._dA_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_dA_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L963-L997">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._dA_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._dA_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._dA_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dA_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the angular diameter distance <code>d_A(z)</code> to a given redshift <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>_dA_z(z, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar or array).</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated angular diameter distance <code>d_A(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>_dA_z(z, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._dA_z-Tuple{Any, Any, Any}"><code>_dA_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method for calculating angular diameter distance.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._d̃A_z-Tuple{Any, Any, Any}"><code>_d̃A_z</code></a>: Calculates the conformal angular diameter distance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1002-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._growth!" href="#Effort._growth!"><code>Effort._growth!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_growth!(du, u, p, loga)</code></pre><p>Defines the in-place right-hand side of the second-order ordinary differential equation for the linear growth factor <code>D(a)</code>, with <code>log(a)</code> as the independent variable.</p><p>The state vector <code>u</code> is <code>[D(log a), dD/d(log a)]</code>. This function calculates the derivatives <code>du = [dD/d(log a), d^2D/d(log a)^2]</code> based on the growth equation.</p><p><strong>Arguments</strong></p><ul><li><code>du</code>: The output vector where the calculated derivatives are stored (modified in-place).</li><li><code>u</code>: The current state vector <code>[D(log a), dD/d(log a)]</code>.</li><li><code>p</code>: A vector of parameters <code>[Ωcb0, mν, h, w0, wa]</code>.</li><li><code>loga</code>: The natural logarithm of the scale factor, <code>log(a)</code>.</li></ul><p><strong>Returns</strong></p><p>Modifies the <code>du</code> vector in-place.</p><p><strong>Details</strong></p><p>The function solves the second-order differential equation for the linear growth factor, often written as:</p><p class="math-container">\[\frac{d^2 D}{d(\ln a)^2} + \left(2 + \frac{d \ln E}{d \ln a}\right) \frac{d D}{d \ln a} - \frac{3}{2} \Omega_m(a) D = 0\]</p><p>where <span>$E(a)$</span> is the normalized Hubble parameter and <span>$\Omega_m(a)$</span> is the matter density parameter.</p><p>The terms <span>$\frac{d \ln E}{d \ln a}$</span> and <span>$\Omega_m(a)$</span> are calculated using <a href="#Effort._dlogEdloga"><code>_dlogEdloga</code></a> and <a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>_Ωma</code></a> respectively, with parameters extracted from <code>p</code>.</p><p>The system of first-order ODEs implemented is: <span>$\frac{d u[1]}{d(\ln a)} = u[2]$</span> <span>$\frac{d u[2]}{d(\ln a)} = -\left(2 + \frac{d \ln E}{d \ln a}\right) u[2] + \frac{3}{2} \Omega_m(a) u[1]$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver</code></a>: Functions that solve this ODE.</li><li><a href="#Effort._dlogEdloga"><code>_dlogEdloga</code></a>: Calculates the logarithmic derivative of E(a).</li><li><a href="#Effort._Ωma-Tuple{Any, Any, Any}"><code>_Ωma</code></a>: Calculates the matter density parameter at scale factor a.</li><li><a href="#Effort._E_a-Tuple{Any, Any, Any}"><code>_E_a</code></a>: Related normalized Hubble parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1034-L1073">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._growth_solver-Tuple{Any, Any}" href="#Effort._growth_solver-Tuple{Any, Any}"><code>Effort._growth_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_growth_solver(Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Solves the ODE for the linear growth factor <code>D(a)</code> and its derivative <code>dD/d(log a)</code> over a fixed range of <code>log(a)</code>, typically from an early time to slightly past <code>a=1</code>.</p><p>This function sets up and solves the <a href="#Effort._growth!"><code>_growth!</code></a> ODE using a standard solver.</p><p><strong>Arguments</strong></p><ul><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A DifferentialEquations.jl solution object containing the values of <code>D(log a)</code> and <code>dD/d(log a)</code> over the solved <code>log(a)</code> range.</p><p><strong>Details</strong></p><p>The ODE is solved from <code>log(amin)</code> to <code>log(1.01)</code>, where <code>amin = 1/139</code>. Initial conditions <code>u₀ = [amin, amin]</code> are used, corresponding to <code>D(a) ≈ a</code> at early times. The problem is solved using the <code>Tsit5()</code> solver with a relative tolerance of <code>1e-5</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth!"><code>_growth!</code></a>: Defines the growth ODE.</li><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Method to solve and save at specific redshifts.</li><li><a href="#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}"><code>_growth_solver(w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1088-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}" href="#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}"><code>Effort._growth_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_growth_solver(w0wacosmo::w0waCDMCosmology)</code></pre><p>Solves the ODE for the linear growth factor <code>D(a)</code> and its derivative <code>dD/d(log a)</code> using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>A DifferentialEquations.jl solution object containing the values of <code>D(log a)</code> and <code>dD/d(log a)</code> over the solved <code>log(a)</code> range.</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth!"><code>_growth!</code></a>: Defines the growth ODE.</li><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a>: The primary solver method.</li><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Method to solve and save at specific redshifts.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1185-L1212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._growth_solver-Tuple{Any, Any, Any}" href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>Effort._growth_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_growth_solver(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Solves the ODE for the linear growth factor <code>D(a)</code> and its derivative <code>dD/d(log a)</code> and returns the solution evaluated specifically at the given redshift(s) <code>z</code>.</p><p>This function solves the <a href="#Effort._growth!"><code>_growth!</code></a> ODE over a range of <code>log(a)</code> and then extracts the solution values corresponding to the provided redshift(s).</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift or an array of redshifts at which to save the solution.</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A 2xN array (where N is the number of redshifts in <code>z</code>) containing the solution. The first row contains the growth factor <code>D(z)</code>, and the second row contains the derivative <code>dD/d(log a)</code> evaluated at redshift <code>z</code>.</p><p><strong>Details</strong></p><p>The ODE is solved from <code>log(amin)</code> to <code>log(1.01)</code>, where <code>amin = 1/139</code>. Initial conditions <code>u₀ = [amin, amin]</code> are used, corresponding to <code>D(a) ≈ a</code> at early times. The problem is solved using the <code>Tsit5()</code> solver with a relative tolerance of <code>1e-5</code>. The solution is saved specifically at the <code>log(a)</code> values corresponding to the input redshifts <code>z</code>, obtained using <a href="#Effort._a_z"><code>_a_z</code></a>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth!"><code>_growth!</code></a>: Defines the growth ODE.</li><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a>: Method to solve over a fixed range.</li><li><a href="#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}"><code>_growth_solver(w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1133-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._growth_solver-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._growth_solver-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._growth_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_D_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the linear growth factor <code>D(z)</code> for a single redshift <code>z</code>.</p><p>The linear growth factor describes how density perturbations grow in the linear regime of structure formation. It is obtained by solving a second-order ODE.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated linear growth factor <code>D(z)</code> (scalar).</p><p><strong>Details</strong></p><p>This function solves the growth ODE using the <a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a> method, which solves over a fixed range of <code>log(a)</code>. It then evaluates the solution at the <code>log(a)</code> value corresponding to the input redshift <code>z</code> (obtained via <a href="#Effort._a_z"><code>_a_z</code></a>) to get the value of <code>D(z)</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver</code></a>: Solves the growth ODE.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li><li><a href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a>: Method for a vector of redshifts.</li><li><a href="#Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_D_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1218-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._D_z-Tuple{Any, Any, Any}" href="#Effort._D_z-Tuple{Any, Any, Any}"><code>Effort._D_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_growth_solver(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Solves the ODE for the linear growth factor <code>D(a)</code> and its derivative <code>dD/d(log a)</code> and returns the solution evaluated specifically at the given redshift(s) <code>z</code>.</p><p>This function solves the <a href="#Effort._growth!"><code>_growth!</code></a> ODE over a range of <code>log(a)</code> and then extracts the solution values corresponding to the provided redshift(s).</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift or an array of redshifts at which to save the solution.</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A 2xN array (where N is the number of redshifts in <code>z</code>) containing the solution. The first row contains the growth factor <code>D(z)</code>, and the second row contains the derivative <code>dD/d(log a)</code> evaluated at redshift <code>z</code>.</p><p><strong>Details</strong></p><p>The ODE is solved from <code>log(amin)</code> to <code>log(1.01)</code>, where <code>amin = 1/139</code>. Initial conditions <code>u₀ = [amin, amin]</code> are used, corresponding to <code>D(a) ≈ a</code> at early times. The problem is solved using the <code>Tsit5()</code> solver with a relative tolerance of <code>1e-5</code>. The solution is saved specifically at the <code>log(a)</code> values corresponding to the input redshifts <code>z</code>, obtained using <a href="#Effort._a_z"><code>_a_z</code></a>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth!"><code>_growth!</code></a>: Defines the growth ODE.</li><li><a href="#Effort._growth_solver-Tuple{Any, Any}"><code>_growth_solver(Ωcb0, h; mν, w0, wa)</code></a>: Method to solve over a fixed range.</li><li><a href="#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}"><code>_growth_solver(w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1256-L1292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._D_z-Tuple{AbstractVector, Any, Any}" href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>Effort._D_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_D_z(z::AbstractVector, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the linear growth factor <code>D(z)</code> for a vector of redshifts <code>z</code>.</p><p>The linear growth factor describes how density perturbations grow in the linear regime of structure formation. It is obtained by solving a second-order ODE.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: A vector of redshifts (<code>AbstractVector</code>).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A vector containing the calculated linear growth factor <code>D(z)</code> for each redshift in the input vector <code>z</code>.</p><p><strong>Details</strong></p><p>This function solves the growth ODE using the <a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a> method, which solves the ODE and saves the solution specifically at the <code>log(a)</code> values corresponding to the input redshifts <code>z</code>. It then extracts the first row of the solution (which contains the <code>D(z)</code> values) and reverses it.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Solves the growth ODE and saves at specific redshifts.</li><li><a href="#Effort._a_z"><code>_a_z</code></a>: Converts redshift to scale factor (used internally by <code>_growth_solver</code>).</li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z(z, Ωcb0, h; mν, w0, wa)</code></a>: Method for a single redshift.</li><li><a href="#Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_D_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1298-L1330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._D_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_D_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the linear growth factor <code>D(z)</code> for a given redshift or vector of redshifts <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z(z, Ωcb0, h; mν, w0, wa)</code></a> or <a href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a> functions. It extracts the necessary cosmological parameters from the provided struct and calls the appropriate method based on whether <code>z</code> is a scalar or a vector.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift or an array of redshifts.</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated linear growth factor <code>D(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls either <a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z(z, Ωcb0, h; mν, w0, wa)</code></a> or <a href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a> internally, depending on the type of <code>z</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z(z, Ωcb0, h; mν, w0, wa)</code></a>: Method for a single redshift.</li><li><a href="#Effort._D_z-Tuple{AbstractVector, Any, Any}"><code>_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a>: Method for a vector of redshifts.</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1336-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._f_z-Tuple{AbstractVector, Any, Any}" href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>Effort._f_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_f_z(z::AbstractVector, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the linear growth rate <code>f(z)</code> for a vector of redshifts <code>z</code>.</p><p>The linear growth rate is defined as <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span>, where <code>D(z)</code> is the linear growth factor and <code>a</code> is the scale factor.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: A vector of redshifts (<code>AbstractVector</code>).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A vector containing the calculated linear growth rate <code>f(z)</code> for each redshift in the input vector <code>z</code>.</p><p><strong>Details</strong></p><p>This function uses the <a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a> method to solve the growth ODE and obtain the growth factor <code>D(z)</code> and its derivative with respect to <code>log(a)</code>, <code>dD/d(log a)</code>, at the specified redshifts. It then calculates <code>f(z)</code> as the ratio of <code>dD/d(log a)</code> to <code>D(z)</code> at each redshift. The result is reversed before returning.</p><p><strong>Formula</strong></p><p>The formula used is: <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Solves the growth ODE and saves at specific redshifts.</li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z</code></a>: Calculates the linear growth factor.</li><li><a href="#Effort._f_z-Tuple{Any, Any, Any}"><code>_f_z(z, Ωcb0, h; mν, w0, wa)</code></a>: Method for a single redshift.</li><li><a href="#Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_f_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li><li><a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z</code></a>: Calculates both D(z) and f(z).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1371-L1408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._f_z-Tuple{Any, Any, Any}" href="#Effort._f_z-Tuple{Any, Any, Any}"><code>Effort._f_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)</code></pre><p>Calculates the linear growth rate <code>f(z)</code> for a single redshift <code>z</code>.</p><p>The linear growth rate is defined as <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span>, where <code>D(z)</code> is the linear growth factor and <code>a</code> is the scale factor.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift (scalar).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>The calculated linear growth rate <code>f(z)</code> (scalar).</p><p><strong>Details</strong></p><p>This function uses the <a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a> method to solve the growth ODE and obtain the growth factor <code>D(z)</code> and its derivative with respect to <code>log(a)</code>, <code>dD/d(log a)</code>, at the specified redshift. It then calculates <code>f(z)</code> as the ratio of <code>dD/d(log a)</code> to <code>D(z)</code>.</p><p><strong>Formula</strong></p><p>The formula used is: <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Solves the growth ODE and saves at specific redshifts.</li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z</code></a>: Calculates the linear growth factor.</li><li><a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a>: Method for a vector of redshifts.</li><li><a href="#Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_f_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li><li><a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z</code></a>: Calculates both D(z) and f(z).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1417-L1454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._f_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_f_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates the linear growth rate <code>f(z)</code> for a given redshift or vector of redshifts <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._f_z-Tuple{Any, Any, Any}"><code>_f_z(z, Ωcb0, h; mν, w0, wa)</code></a> or <a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a> functions. It extracts the necessary cosmological parameters from the provided struct and calls the appropriate method based on whether <code>z</code> is a scalar or a vector.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift or an array of redshifts.</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>The calculated linear growth rate <code>f(z)</code> (scalar or array).</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls either <a href="#Effort._f_z-Tuple{Any, Any, Any}"><code>_f_z(z, Ωcb0, h; mν, w0, wa)</code></a> or <a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a> internally, depending on the type of <code>z</code>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._f_z-Tuple{Any, Any, Any}"><code>_f_z(z, Ωcb0, h; mν, w0, wa)</code></a>: Method for a single redshift.</li><li><a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa)</code></a>: Method for a vector of redshifts.</li><li><a href="../api_external/#Effort.w0waCDMCosmology"><code>w0waCDMCosmology</code></a>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z</code></a>: Calculates both D(z) and f(z).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1462-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._D_f_z-Tuple{Any, Any, Any}" href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>Effort._D_f_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_D_f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)</code></pre><p>Calculates both the linear growth factor <code>D(z)</code> and the linear growth rate <code>f(z)</code> for a vector of redshifts <code>z</code>.</p><p>This function is a convenience to get both quantities from a single ODE solution. The growth rate is defined as <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: A vector of redshifts (<code>AbstractVector</code>).</li><li><code>Ωcb0</code>: The density parameter for cold dark matter and baryons today.</li><li><code>h</code>: The Hubble parameter today, divided by 100 km/s/Mpc.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mν</code>: Total neutrino mass(es).</li><li><code>w0</code>: Dark energy equation of state parameter.</li><li><code>wa</code>: Dark energy equation of state parameter derivative.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(D_values, f_values)</code>, where <code>D_values</code> is a vector of the linear growth factor <code>D(z)</code> and <code>f_values</code> is a vector of the linear growth rate <code>f(z)</code> for each redshift in the input vector <code>z</code>. Both vectors are reversed before returning.</p><p><strong>Details</strong></p><p>This function uses the <a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a> method to solve the growth ODE and obtain the growth factor <code>D(z)</code> and its derivative with respect to <code>log(a)</code>, <code>dD/d(log a)</code>, at the specified redshifts. It then calculates <code>f(z)</code> as the ratio of <code>dD/d(log a)</code> to <code>D(z)</code> at each redshift. Both the <code>D(z)</code> and calculated <code>f(z)</code> vectors are returned.</p><p><strong>Formula</strong></p><p>The formula used for <code>f(z)</code> is: <span>$f(z) = \frac{d \ln D}{d \ln a} = \frac{dD/d(\ln a)}{D}$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._growth_solver-Tuple{Any, Any, Any}"><code>_growth_solver(z, Ωcb0, h; mν, w0, wa)</code></a>: Solves the growth ODE and saves at specific redshifts.</li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z</code></a>: Calculates the linear growth factor separately.</li><li><a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z</code></a>: Calculates the linear growth rate separately.</li><li><a href="#Effort._D_f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>_D_f_z(z, w0wacosmo::w0waCDMCosmology)</code></a>: Method using a cosmology struct.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1498-L1538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._D_f_z-Tuple{Any, Effort.w0waCDMCosmology}" href="#Effort._D_f_z-Tuple{Any, Effort.w0waCDMCosmology}"><code>Effort._D_f_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_D_f_z(z, w0wacosmo::w0waCDMCosmology)</code></pre><p>Calculates both the linear growth factor <code>D(z)</code> and the linear growth rate <code>f(z)</code> for a vector of redshifts <code>z</code>, using parameters extracted from a <code>w0waCDMCosmology</code> struct.</p><p>This method is a convenience wrapper around the primary <a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z(z, Ωcb0, h; mν, w0, wa)</code></a> function. It extracts the necessary cosmological parameters from the provided struct.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: A vector of redshifts.</li><li><code>w0wacosmo</code>: A struct of type <code>w0waCDMCosmology</code> containing the cosmological parameters.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(D_values, f_values)</code>, where <code>D_values</code> is a vector of the linear growth factor <code>D(z)</code> and <code>f_values</code> is a vector of the linear growth rate <code>f(z)</code> for each redshift in the input vector <code>z</code>.</p><p><strong>Details</strong></p><p>The parameters <code>Ωcb0</code>, <code>h</code>, <code>mν</code>, <code>w0</code>, and <code>wa</code> are extracted from the <code>w0wacosmo</code> struct. <code>Ωcb0</code> is calculated as <code>(w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2</code>.</p><p>This method calls the primary <a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z(z, Ωcb0, h; mν, w0, wa)</code></a> method internally.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._D_f_z-Tuple{Any, Any, Any}"><code>_D_f_z(z, Ωcb0, h; mν, w0, wa)</code></a>: The primary method for calculating D(z) and f(z).</li><li><code>w0waCDMCosmology</code>: The struct type containing the cosmological parameters.</li><li><a href="#Effort._D_z-Tuple{Any, Any, Any}"><code>_D_z</code></a>: Calculates the linear growth factor separately.</li><li><a href="#Effort._f_z-Tuple{AbstractVector, Any, Any}"><code>_f_z</code></a>: Calculates the linear growth rate separately.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/background.jl#L1547-L1576">source</a></section></article><h2 id="Projection"><a class="docs-heading-anchor" href="#Projection">Projection</a><a id="Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Projection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pkμ" href="#Effort._Pkμ"><code>Effort._Pkμ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> at a given wavenumber <code>k</code> and cosine of the angle to the line-of-sight <code>μ</code>, using its Legendre multipole moments.</p><p><strong>Arguments</strong></p><ul><li><code>k</code>: The wavenumber.</li><li><code>μ</code>: The cosine of the angle to the line-of-sight.</li><li><code>Int_Mono</code>: A function or interpolant that provides the monopole moment <span>$I_0(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Quad</code>: A function or interpolant that provides the quadrupole moment <span>$I_2(k)$</span> at wavenumber <code>k</code>.</li><li><code>Int_Hexa</code>: A function or interpolant that provides the hexadecapole moment <span>$I_4(k)$</span> at wavenumber <code>k</code>.</li></ul><p><strong>Returns</strong></p><p>The value of the anisotropic power spectrum <span>$P(k, \mu)$</span> at the given <code>k</code> and <code>μ</code>.</p><p><strong>Details</strong></p><p>The anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at <code>μ</code>. The function uses the 0th, 2nd, and 4th order Legendre polynomials.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P(k, \mu) = I_0(k) \mathcal{L}_0(\mu) + I_2(k) \mathcal{L}_2(\mu) + I_4(k) \mathcal{L}_4(\mu)\]</p><p>where <span>$I_l(k)$</span> are the multipole moments and <span>$\mathcal{L}_l(\mu)$</span> are the Legendre polynomials of order <span>$l$</span>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-NTuple{4, Any}" href="#Effort._k_true-NTuple{4, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o, μ_o, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> from the observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber (scalar).</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true wavenumber <code>k</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></a>: Method for arrays of observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._k_true-Tuple{Array, Array, Any, Any}" href="#Effort._k_true-Tuple{Array, Array, Any, Any}"><code>Effort._k_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_k_true(k_o::Array, μ_o::Array, q_perp, F)</code></pre><p>Calculates the true (physical) wavenumber <code>k</code> for arrays of observed wavenumbers <code>k_o</code> and observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by <code>q_perp</code> and <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: An array of observed wavenumbers.</li><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A vector containing the calculated true wavenumbers <code>k</code> for the given input arrays.</p><p><strong>Details</strong></p><p>The function calculates <code>k</code> for pairs or combinations of values from the input arrays <code>k_o</code> and <code>μ_o</code> using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.</p><p><strong>Formula</strong></p><p>The underlying transformation for each pair of <code>k_o</code> and <code>μ_o</code> is:</p><p class="math-container">\[k = \frac{k_o}{q_\perp} \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true(k_o, μ_o, q_perp, F)</code></a>: Method for scalar observed values.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Calculates the true cosine of the angle to the line-of-sight.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L70-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Any, Any}" href="#Effort._μ_true-Tuple{Any, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> from the observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight (scalar).</li><li><code>F</code>: A parameter related to parallel anisotropic scaling (often the growth rate <code>f</code> divided by the anisotropic scaling parameter <code>q_parallel</code>).</li></ul><p><strong>Returns</strong></p><p>The calculated true cosine of the angle to the line-of-sight <code>μ</code> (scalar).</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Array, Any}"><code>_μ_true(μ_o::Array, F)</code></a>: Method for an array of observed values.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L111-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._μ_true-Tuple{Array, Any}" href="#Effort._μ_true-Tuple{Array, Any}"><code>Effort._μ_true</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_μ_true(μ_o::Array, F)</code></pre><p>Calculates the true (physical) cosine of the angle to the line-of-sight <code>μ</code> for an array of observed cosines of the angle to the line-of-sight <code>μ_o</code>.</p><p>This method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by <code>F</code>.</p><p><strong>Arguments</strong></p><ul><li><code>μ_o</code>: An array of observed cosines of the angle to the line-of-sight.</li><li><code>F</code>: A parameter related to parallel anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>An array containing the calculated true cosines of the angle to the line-of-sight <code>μ</code>.</p><p><strong>Details</strong></p><p>The function calculates <code>μ</code> for each value in the input array <code>μ_o</code> using a formula derived from anisotropic scaling. Broadcasting (<code>@.</code>) is used to apply the calculation element-wise.</p><p><strong>Formula</strong></p><p>The underlying transformation for each <code>μ_o</code> is:</p><p class="math-container">\[\mu = \frac{\mu_o}{F \sqrt{1 + \mu_o^2 \left(\frac{1}{F^2} - 1\right)}}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true(μ_o, F)</code></a>: Method for a scalar observed value.</li><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Calculates the true wavenumber.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L141-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._P_obs" href="#Effort._P_obs"><code>Effort._P_obs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)</code></pre><p>Calculates the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> at a given observed wavenumber <code>k_o</code> and observed cosine of the angle to the line-of-sight <code>μ_o</code>.</p><p>This function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.</p><p><strong>Arguments</strong></p><ul><li><code>k_o</code>: The observed wavenumber.</li><li><code>μ_o</code>: The observed cosine of the angle to the line-of-sight.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li><li><code>Int_Mono</code>: An interpolation function for the monopole moment <span>$I_0(k)$</span> in true k.</li><li><code>Int_Quad</code>: An interpolation function for the quadrupole moment <span>$I_2(k)$</span> in true k.</li><li><code>Int_Hexa</code>: An interpolation function for the hexadecapole moment <span>$I_4(k)$</span> in true k.</li></ul><p><strong>Returns</strong></p><p>The value of the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span>.</p><p><strong>Details</strong></p><p>The observed coordinates <span>$(k_o, \mu_o)$</span> are transformed to true coordinates <span>$(k_t, \mu_t)$</span> using the <a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a> and <a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a> functions, with <span>$F = q_\parallel / q_\perp$</span>. The true power spectrum <span>$P(k_t, \mu_t)$</span> is then reconstructed using <a href="#Effort._Pkμ"><code>_Pkμ</code></a> and the provided multipole interpolants. Finally, the result is scaled by <span>$1 / (q_\parallel q_\perp^2)$</span>.</p><p><strong>Formula</strong></p><p>The formula used is:</p><p class="math-container">\[P_{\text{obs}}(k_o, \mu_o) = \frac{1}{q_\parallel q_\perp^2} P(k_t, \mu_t)\]</p><p>where</p><p class="math-container">\[k_t = \text{_k_true}(k_o, \mu_o, q_\perp, F)\]</p><p>math \mu<em>t = \text{</em>μ<em>true}(\mu</em>o, F)</p><pre><code class="nohighlight hljs">and</code></pre><p>math F = q<em>\parallel / q</em>\perp ```</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Transforms observed wavenumber to true wavenumber.</li><li><a href="#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Transforms observed angle cosine to true angle cosine.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs the true power spectrum from multipole moments.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the multipole interpolants.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L178-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.interp_Pℓs" href="#Effort.interp_Pℓs"><code>Effort.interp_Pℓs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)</code></pre><p>Creates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.</p><p>These interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Mono_array</code>: An array containing the values of the monopole moment <span>$I_0(k)$</span>.</li><li><code>Quad_array</code>: An array containing the values of the quadrupole moment <span>$I_2(k)$</span>.</li><li><code>Hexa_array</code>: An array containing the values of the hexadecapole moment <span>$I_4(k)$</span>.</li><li><code>k_grid</code>: An array containing the corresponding wavenumber <code>k</code> values for the multipole arrays.</li></ul><p><strong>Returns</strong></p><p>A tuple containing three interpolation functions: <code>(Int_Mono, Int_Quad, Int_Hexa)</code>.</p><p><strong>Details</strong></p><p>The function uses <code>AkimaInterpolation</code> from the <code>Interpolations.jl</code> package to create the interpolants. Extrapolation is set to <code>ExtrapolationType.Extension</code>, which means the interpolant will use the nearest data points to extrapolate outside the provided <code>k_grid</code> range. Note that extrapolation can sometimes introduce errors.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Uses the interpolation functions to reconstruct the anisotropic power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L236-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}" href="#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}"><code>Effort.apply_AP_check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP_check(k_input::Array, k_output::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array, q_par, q_perp)</code></pre><p>Calculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid <code>k_output</code>, from arrays of true multipole moments provided on an input wavenumber grid <code>k_input</code>, using numerical integration.</p><p>This is a <strong>check version</strong>, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle <code>μ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k_input</code>: An array of wavenumber values on which the input true multipole moments (<code>Mono_array</code>, <code>Quad_array</code>, <code>Hexa_array</code>) are defined.</li><li><code>k_output</code>: An array of observed wavenumber values at which to calculate the output observed multipoles.</li><li><code>Mono_array</code>: An array containing the values of the true monopole moment <span>$I_0(k)$</span> on the <code>k_input</code> grid.</li><li><code>Quad_array</code>: An array containing the values of the true quadrupole moment <span>$I_2(k)$</span> on the <code>k_input</code> grid.</li><li><code>Hexa_array</code>: An array containing the values of the true hexadecapole moment <span>$I_4(k)$</span> on the <code>k_input</code> grid.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(P0_obs, P2_obs, P4_obs)</code>, where each element is an array containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in <code>k_output</code>.</p><p><strong>Details</strong></p><p>This method first creates interpolation functions for the true multipole moments using <a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a> based on the <code>k_input</code> grid. It then calls the core <a href="#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a> method, passing <code>k_output</code> as the grid at which to calculate the observed multipoles.</p><p>This function is a <strong>slower check implementation</strong> and should not be used in performance-critical code.</p><p><strong>Formula</strong></p><p>The observed multipole moments are calculated using the formula:</p><p class="math-container">\[P_\ell(k_o) = (2\ell + 1) \int_{0}^1 P_{\text{obs}}(k_o, \mu_o) \mathcal{L}_\ell(\mu_o) d\mu_o\]</p><p>for <span>$\ell \in \{0, 2, 4\}$</span>. The observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> is calculated using <a href="#Effort._P_obs"><code>_P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa)</code></a>.</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}"><code>apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp)</code></a>: The core method performing the integration.</li><li><a href="#Effort.interp_Pℓs"><code>interp_Pℓs</code></a>: Creates the interpolation functions for the true multipoles.</li><li><a href="#Effort._P_obs"><code>_P_obs</code></a>: Calculates the observed power spectrum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L272-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Pk_recon" href="#Effort._Pk_recon"><code>Effort._Pk_recon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)</code></pre><p>Reconstructs the anisotropic power spectrum <span>$P(k, \mu)$</span> on a grid of wavenumbers <code>k</code> and cosines of the angle to the line-of-sight <code>μ</code>, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.</p><p>This function is designed to efficiently reconstruct the 2D power spectrum for multiple <code>k</code> and <code>μ</code> values simultaneously, assuming the multipole moments are provided as matrices (e.g., <code>N_k x 1</code>) and Legendre polynomials as vectors (e.g., <code>N_μ</code>).</p><p><strong>Arguments</strong></p><ul><li><code>mono</code>: A matrix containing the monopole moment <span>$I_0(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>quad</code>: A matrix containing the quadrupole moment <span>$I_2(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>hexa</code>: A matrix containing the hexadecapole moment <span>$I_4(k)$</span> values (expected dimensions <code>N_k x 1</code>).</li><li><code>l0</code>: A vector containing the 0th order Legendre polynomial <span>$\mathcal{L}_0(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l2</code>: A vector containing the 2nd order Legendre polynomial <span>$\mathcal{L}_2(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li><li><code>l4</code>: A vector containing the 4th order Legendre polynomial <span>$\mathcal{L}_4(\mu)$</span> values evaluated at the desired <code>μ</code> values (expected dimensions <code>N_μ</code>).</li></ul><p><strong>Returns</strong></p><p>A matrix representing the anisotropic power spectrum <span>$P(k, \mu)$</span> on the <code>N_k x N_μ</code> grid.</p><p><strong>Details</strong></p><p>The function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input <code>k</code> (from the rows of the moment matrices) and <code>μ</code> (from the elements of the Legendre polynomial vectors).</p><p><strong>Formula</strong></p><p>The formula used for each element <span>$(i, j)$</span> of the output matrix (corresponding to the <span>$i$</span>-th wavenumber and <span>$j$</span>-th angle cosine) is:</p><p class="math-container">\[P(k_i, \mu_j) = I_0(k_i) \mathcal{L}_0(\mu_j) + I_2(k_i) \mathcal{L}_2(\mu_j) + I_4(k_i) \mathcal{L}_4(\mu_j)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: Reconstructs <span>$P(k, \mu)$</span> for single <code>k</code> and <code>μ</code>.</li><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculate the Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/projection.jl#L392-L431">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._transformed_weights" href="#Effort._transformed_weights"><code>Effort._transformed_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_transformed_weights(quadrature_rule, order, a, b)</code></pre><p>Transforms the points and weights of a standard quadrature rule from the interval <code>[-1, 1]</code> to a specified interval <code>[a, b]</code>.</p><p>This is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals <code>[a, b]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>quadrature_rule</code>: A function that takes an <code>order</code> and returns a tuple <code>(points, weights)</code>                    for the standard interval <code>[-1, 1]</code>.</li><li><code>order</code>: The order of the quadrature rule (number of points).</li><li><code>a</code>: The lower bound of the target interval.</li><li><code>b</code>: The upper bound of the target interval.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(transformed_points, transformed_weights)</code> for the interval <code>[a, b]</code>.</p><p><strong>Details</strong></p><p>The transformation is applied to the standard points <span>$x_i^{\text{std}}$</span> and weights <span>$w_i^{\text{std}}$</span> obtained from the <code>quadrature_rule</code>:</p><ul><li>Transformed points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span></li><li>Transformed weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></li></ul><p><strong>Formula</strong></p><p>The transformation formulas are: Points: <span>$x_i = \frac{b - a}{2} x_i^{\text{std}} + \frac{b + a}{2}$</span> Weights: <span>$w_i = \frac{b - a}{2} w_i^{\text{std}}$</span></p><p><strong>See Also</strong></p><ul><li><a href="#Effort._r̃_z-Tuple{Any, Any, Any}"><code>_r̃_z</code></a>: An example function that uses this utility for numerical integration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_0" href="#Effort._Legendre_0"><code>Effort._Legendre_0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_0(x)</code></pre><p>Calculates the 0th order Legendre polynomial, <span>$\mathcal{L}_0(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 0th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 0th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_0(x) = 1\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L253-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_2" href="#Effort._Legendre_2"><code>Effort._Legendre_2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_2(x)</code></pre><p>Calculates the 2nd order Legendre polynomial, <span>$\mathcal{L}_2(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 2nd order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 2nd order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_2(x) = \frac{1}{2} (3x^2 - 1)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculates the 4th order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L279-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._Legendre_4" href="#Effort._Legendre_4"><code>Effort._Legendre_4</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_Legendre_4(x)</code></pre><p>Calculates the 4th order Legendre polynomial, <span>$\mathcal{L}_4(x)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).</li></ul><p><strong>Returns</strong></p><p>The value of the 4th order Legendre polynomial evaluated at <code>x</code>.</p><p><strong>Formula</strong></p><p>The formula for the 4th order Legendre polynomial is:</p><p class="math-container">\[\mathcal{L}_4(x) = \frac{1}{8} (35x^4 - 30x^2 + 3)\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort._Legendre_0"><code>_Legendre_0</code></a>: Calculates the 0th order Legendre polynomial.</li><li><a href="#Effort._Legendre_2"><code>_Legendre_2</code></a>: Calculates the 2nd order Legendre polynomial.</li><li><a href="#Effort._Pkμ"><code>_Pkμ</code></a>: A function that uses Legendre polynomials.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L305-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._cubic_spline" href="#Effort._cubic_spline"><code>Effort._cubic_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_cubic_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply a cubic spline interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating a <code>CubicSpline</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.CubicSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates a cubic spline interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.CubicSpline</code>: The underlying interpolation function.</li><li><a href="#Effort._quadratic_spline"><code>_quadratic_spline</code></a>: Wrapper for quadratic spline interpolation.</li><li><a href="#Effort._akima_spline"><code>_akima_spline</code></a>: Wrapper for Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L141-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._quadratic_spline" href="#Effort._quadratic_spline"><code>Effort._quadratic_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_quadratic_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply a quadratic spline interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating a <code>QuadraticSpline</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.QuadraticSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates a quadratic spline interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.QuadraticSpline</code>: The underlying interpolation function.</li><li><a href="#Effort._cubic_spline"><code>_cubic_spline</code></a>: Wrapper for cubic spline interpolation.</li><li><a href="#Effort._akima_spline"><code>_akima_spline</code></a>: Wrapper for Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L171-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_spline" href="#Effort._akima_spline"><code>Effort._akima_spline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_spline(u, t, new_t::AbstractArray)</code></pre><p>A convenience wrapper to create and apply an Akima interpolation using <code>DataInterpolations.jl</code>.</p><p>This function simplifies the process of creating an <code>AkimaInterpolation</code> interpolant for the data <code>(u, t)</code> and evaluating it at the points <code>new_t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: An array of data values.</li><li><code>t</code>: An array of data points corresponding to <code>u</code>.</li><li><code>new_t</code>: An array of points at which to interpolate.</li></ul><p><strong>Returns</strong></p><p>An array of interpolated values corresponding to <code>new_t</code>.</p><p><strong>Details</strong></p><p>This function is a convenience wrapper around <code>DataInterpolations.AkimaInterpolation(u, t; extrapolation=ExtrapolationType.Extension).(new_t)</code>. It creates an Akima interpolant with extrapolation enabled using <code>ExtrapolationType.Extension</code> and immediately evaluates it at all points in <code>new_t</code>.</p><p><strong>See Also</strong></p><ul><li><code>DataInterpolations.AkimaInterpolation</code>: The underlying interpolation function.</li><li><a href="#Effort._cubic_spline"><code>_cubic_spline</code></a>: Wrapper for cubic spline interpolation.</li><li><a href="#Effort._quadratic_spline"><code>_quadratic_spline</code></a>: Wrapper for quadratic spline interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L201-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort._akima_spline_legacy" href="#Effort._akima_spline_legacy"><code>Effort._akima_spline_legacy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_akima_spline_legacy(u, t, t_new)</code></pre><p>Evaluates the one-dimensional Akima spline that interpolates the data points <span>$(t_i, u_i)$</span> at new abscissae <code>t_new</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Ordinates (function values) <span>$u_i$</span> at the data nodes.</li><li><code>t</code>: Strictly increasing abscissae (knots) <span>$t_i$</span> associated with <code>u</code>. <code>length(t)</code> must equal <code>length(u)</code>.</li><li><code>t_new</code>: The query point(s) where the spline is to be evaluated.</li></ul><p><strong>Returns</strong></p><p>The interpolated value(s) at <code>t_new</code>. A scalar input returns a scalar; a vector input returns a vector of the same length.</p><p><strong>Details</strong></p><p>This routine implements the original Akima piecewise-cubic method (T. Akima, 1970). On each interval <span>$[t_j, t_{j+1}]$</span>, a cubic polynomial is constructed. The method uses a weighted average of slopes to determine the derivative at each node, which effectively dampens oscillations without explicit shape constraints. The resulting spline is <span>$C^1$</span> continuous (its first derivative is continuous) but generally not <span>$C^2$</span>.</p><p><strong>Formulae</strong></p><p>The spline on the interval <span>$[t_j, t_{j+1}]$</span> is a cubic polynomial: [ S<em>j(w) = u</em>j + b<em>j w + c</em>j w^{2} + d<em>j w^{3}, \qquad w = t - t</em>j ] The derivative <span>$b_j$</span> at each node is determined by Akima&#39;s weighting of local slopes <span>$m_j=(u_{j}-u_{j-1})/(t_j-t_{j-1})$</span>: [ b<em>j = \frac{|m</em>{j+1}-m<em>{j}|\,m</em>{j-1} + |m<em>{j-1}-m</em>{j-2}|\,m<em>{j}}             {|m</em>{j+1}-m<em>{j}| + |m</em>{j-1}-m<em>{j-2}|} ] The remaining coefficients, ``c</em>j<span>$and$</span>d<em>j``, are found by enforcing continuity of the first derivative: [ c</em>j = \frac{3m<em>j - 2b</em>j - b<em>{j+1}}{t</em>{j+1}-t<em>j} ] [ d</em>j = \frac{b<em>j + b</em>{j+1} - 2m<em>j}{(t</em>{j+1}-t_j)^2} ]</p><p><strong>Automatic Differentiation</strong></p><p>The implementation is free of mutation on the inputs and uses only element-wise arithmetic, making the returned value differentiable with both <code>ForwardDiff.jl</code> (dual numbers) and <code>Zygote.jl</code> (reverse-mode AD). You can therefore embed <code>_akima_spline_legacy</code> in optimization or machine-learning pipelines and back-propagate through the interpolation seamlessly.</p><p><strong>Notes</strong></p><p>The algorithm and numerical results are equivalent to the Akima spline in <code>DataInterpolations.jl</code>, but this routine is self-contained and avoids any package dependency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/11cfae5e92b4f4cd943b368dbd4d5961e0f13c87/src/utils.jl#L90-L130">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_external/">« External API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 3 August 2025 13:20">Sunday 3 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
