<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · Effort.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Effort.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Example</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Alcock-Paczyński-effect"><span>Alcock-Paczyński effect</span></a></li><li><a class="tocitem" href="#Growth-factor"><span>Growth factor</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/main/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h1><p>In order to use <code>Effort.jl</code> you need a trained emulator. There are two different categories of trained emulators:</p><ul><li>single component emulators (e.g.  <span>$P_{11}$</span>, <span>$P_\mathrm{loop}$</span>, <span>$P_\mathrm{ct}$</span>)</li><li>complete emulators, containing all the three different component emulators</li></ul><p>In this section we are going to show how to:</p><ul><li>obtain a multipole power spectrum, using a trained emulator</li><li>apply the Alcock-Paczyński effect</li><li>compute stochastic term contribution</li></ul><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>Let us show how to use Effort.jl to compute Power Spectrum Multipoles.</p><p>First of all, we need some trained emulators, then we can use the <code>Effort.get_Pℓ</code> function</p><article class="docstring"><header><a class="docstring-binding" id="Effort.get_Pℓ" href="#Effort.get_Pℓ"><code>Effort.get_Pℓ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Pℓ(cosmology::Array, bs::Array, f, cosmoemu::AbstractPℓEmulators)</code></pre><p>Compute the Pℓ array given the cosmological parameters array <code>cosmology</code>, the bias array <code>bs</code>, the growth factor <code>f</code> and an <code>AbstractEmulator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/71bce3a2ee122cac7b21286ba9814d94576fc2cb/src/eft_commands.jl#L1-L5">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Trained emulators</header><div class="admonition-body"><p>Right now we do not provide any emulator, but with the paper publication we will release several trained emulators on Zenodo.</p></div></div><pre><code class="language-julia hljs">import Effort
Pct_comp_array = Effort.compute_component(input_test, Pct_Mono_emu) #compute the components of Pct without the bias
Pct_array_Effort = Array{Float64}(zeros(length(Pct_comp_array[1,:]))) #allocate final array
Effort.bias_multiplication!(Pct_array_Effort, bct, Pct_comp_array) #components multiplied by bias
Effort.get_Pℓ(input_test, bs, f, Pℓ_Mono_emu) # whole multipole computation</code></pre><p>Here we are using a <code>ComponentEmulator</code>, which can compute one of the components as predicted by PyBird, and a <code>MultipoleEmulator</code>, which emulates an entire multipole.</p><p>This computation is quite fast: a benchmark performed locally, with a 12th Gen Intel® Core™ i7-1260P, gives the following result for a multipole computation</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  17.257 μs … 811.003 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     20.069 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   20.955 μs ±   8.589 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

     ▁▄▆██▇▅▃▁                                                  
  ▂▂▅█████████▇▆▆▅▅▄▄▃▃▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂ ▃
  17.3 μs         Histogram: frequency by time           37 μs &lt;

 Memory estimate: 19.30 KiB, allocs estimate: 54.</code></pre><p>The result of these computations look like this <img src="https://user-images.githubusercontent.com/58727599/209453056-a83dfd18-03c2-46be-a3a5-01b5f3bd459d.png" alt="effort"/></p><h2 id="Alcock-Paczyński-effect"><a class="docs-heading-anchor" href="#Alcock-Paczyński-effect">Alcock-Paczyński effect</a><a id="Alcock-Paczyński-effect-1"></a><a class="docs-heading-anchor-permalink" href="#Alcock-Paczyński-effect" title="Permalink"></a></h2><p>Here we are going to write down the equations related to the AP effect, following the <a href="https://arxiv.org/abs/1909.05277">Ivanov et al. (2019)</a> and <a href="https://arxiv.org/abs/2003.07956">D&#39;Amico et al. (2020)</a> notation.</p><p>In particular, we are going to use:</p><ul><li><span>$\rm{ref}$</span>, for the quantities evaluated in the reference cosmology used to perform the measurements</li><li><span>$\rm{true}$</span>, for the quantities evaluated in the true cosmology used to perform the theoretical predictions</li><li><span>$\mathrm{obs}$</span>, for the observed quantities after applying the AP effect</li></ul><p>The wavenumbers parallel and perpendicular to the line of sight <span>$(k^\mathrm{true}_\parallel,\, k^\mathrm{true}_\perp)$</span> are related to the ones of the reference cosmology as <span>$(k^\mathrm{ref}_\parallel,\, k^\mathrm{ref}_\perp)$</span> as:</p><p class="math-container">\[k_{\|}^{\text {ref }}=q_{\|} k^\mathrm{true}_{\|}, \quad k_{\perp}^{\mathrm{ref}}=q_{\perp} k^\mathrm{true}_{\perp}\]</p><p>where the distortion parameters are defined by</p><p class="math-container">\[q_{\|}=\frac{D^\mathrm{true}_A(z) H^\mathrm{true}(z=0)}{D_A^{\mathrm{ref}}(z) H^{\mathrm{ref}}(z=0)}, \quad q_{\perp}=\frac{H^{\mathrm{ref}}(z) / H^{\mathrm{ref}}(z=0)}{H^\mathrm{true}(z) / H^\mathrm{true}(z=0)}\]</p><p>where <span>$D^A$</span>, <span>$H$</span> are the angular diameter distance and Hubble parameter, respectively. In terms of these parameters, the power spectrum multipoles in the reference cosmology is given by the multipole projection integral</p><p class="math-container">\[P_{\ell, \mathrm{AP}}(k)=\frac{2 \ell+1}{2} \int_{-1}^1 d \mu_{\mathrm{obs}} P_{\mathrm{obs}}\left(k_{\mathrm{obs}}, \mu_{\mathrm{obs}}\right) \cdot \mathcal{P}_{\ell}\left(\mu_{\mathrm{obs}}\right)\]</p><p>The observed <span>$P_{\mathrm{obs}}\left(k_{\mathrm{obs}}, \mu_{\mathrm{obs}}\right)$</span>, when including the AP effect, is given by</p><p class="math-container">\[P_{\mathrm{obs}}\left(k_{\mathrm{obs}}, \mu_{\mathrm{obs}}\right)= \frac{1}{q_{\|} q_{\perp}^2} \cdot P_g\left(k_{\text {true }}\left[k_{\mathrm{obs}}, \mu_{\mathrm{obs}}\right], \mu_{\text {true }}\left[k_{\text {obs }}, \mu_{\mathrm{obs}}\right]\right)\]</p><p>In the <code>Effort.jl</code> workflow, the Alcock-Paczyński (AP) effect can be included in two different ways:</p><ul><li>by training the emulators using spectra where the AP effect has already been applied</li><li>by using standard trained emulators and applying analitycally the AP effect</li></ul><p>While the former approach is computationally faster (there is no overhead from the NN point-of-view), the latter is more flexible, since the reference cosmology for the AP effect computation can be changed at runtime.</p><p>Regarding the second approach, the most important choice regards the algorithm employed to compute the multipole projection integral. Here we implement two different approaches, based on</p><ul><li><a href="https://juliamath.github.io/QuadGK.jl/stable/">QuadGK.jl</a>. This approach is the most precise, since it uses an adaptive method to compute the integral.</li><li><a href="https://juliaapproximation.github.io/FastGaussQuadrature.jl/stable/">FastGaussQuadrature.jl</a>. This approach is the fastest, since we are going to employ only 5 points to compute the integral, taking advantage of the Gauss-Lobatto quadrature rule.</li></ul><p>In order to understand <em>why</em> it is possible to use few points to evaluate the AP projection integral, it is intructive to plot the <span>$\mu$</span> dependence of the integrand</p><p><img src="https://user-images.githubusercontent.com/58727599/210108594-8c2c1c02-22e9-4d5d-a266-5fffa92bbcba.png" alt="mu_dependence"/></p><p>The <span>$\ell=4$</span> integrand, the most complicated one, can be accurately fit with a <span>$n=8$</span> polynomial</p><p><img src="https://user-images.githubusercontent.com/58727599/210109373-fbd9ab7e-1926-4761-a972-8045724b6704.png" alt="polyfit_residuals"/></p><p>Since a <span>$n$</span> Gauss-Lobatto rule can integrate exactly <span>$2n – 3$</span> degree polynomials,  we expect that a GL rule with 10 points can perform the integral with high precision.</p><p>Now we can show how to use Effort.jl to compute the AP effect using the GK adaptive integration</p><article class="docstring"><header><a class="docstring-binding" id="Effort.apply_AP_check" href="#Effort.apply_AP_check"><code>Effort.apply_AP_check</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_AP_check(k_grid::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array,
q_par, q_perp)</code></pre><p>Given the Monopole, the Quadrupole, the Hexadecapole, and the k-grid, this function apply the AP effect using the Gauss-Kronrod adaptive quadrature. Precise, but expensive, function. Mainly used for check and debugging purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/71bce3a2ee122cac7b21286ba9814d94576fc2cb/src/projection.jl#L46-L52">source</a></section></article><pre><code class="language-julia hljs">import Effort
Effort.apply_AP_check(k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  250.371 μs …  20.084 ms  ┊ GC (min … max): 0.00% … 98.43%
 Time  (median):     290.774 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   296.550 μs ± 198.483 μs  ┊ GC (mean ± σ):  0.67% ±  0.98%

                       ▂▃▅▆▇█▆▅▃▁▁                               
  ▁▁▁▁▁▁▁▁▁▁▁▁▂▁▂▂▃▄▆▇█████████████▇▇▆▆▆▆▆▇▆▆▅▅▄▄▃▃▃▂▃▃▂▂▂▂▂▂▂▁ ▃
  250 μs           Histogram: frequency by time          336 μs &lt;

 Memory estimate: 41.94 KiB, allocs estimate: 320.</code></pre><p>As said, this is precise but a bit expensive from a computational point of view. What about Gauss-Lobatto?</p><article class="docstring"><header><a class="docstring-binding" id="Effort.apply_AP" href="#Effort.apply_AP"><code>Effort.apply_AP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_AP(k_grid::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array, q_par,
q_perp)</code></pre><p>Given the Monopole, the Quadrupole, the Hexadecapole, and the k-grid, this function apply the AP effect using the Gauss-Lobatto quadrature. Fast but accurate,  well tested against adaptive Gauss-Kronrod integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/71bce3a2ee122cac7b21286ba9814d94576fc2cb/src/projection.jl#L127-L133">source</a></section></article><pre><code class="language-julia hljs">import Effort
Effort.apply_AP(k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  24.279 μs …  18.688 ms  ┊ GC (min … max): 0.00% … 99.57%
 Time  (median):     31.257 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   33.686 μs ± 186.622 μs  ┊ GC (mean ± σ):  5.52% ±  1.00%

             ▄█▇▆▅▂▁                                            
  ▂▃▅█▇▃▁▁▂▃▇███████▇▄▄▄▃▃▃▃▂▃▃▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  24.3 μs         Histogram: frequency by time         53.8 μs &lt;

 Memory estimate: 33.09 KiB, allocs estimate: 274.</code></pre><p>This is ten times faster than the adaptive integration, but is also very accurate! A comparison with the GK-based rule show a percentual relative difference of about <span>$10^{-11}\%$</span> for the Hexadecapole, with a higher precision for the other two multipoles.</p><p><img src="https://user-images.githubusercontent.com/58727599/210110289-ec61612c-5ef2-4691-87fb-386f186f5e5e.png" alt="gk_gl_residuals"/></p><h2 id="Growth-factor"><a class="docs-heading-anchor" href="#Growth-factor">Growth factor</a><a id="Growth-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Growth-factor" title="Permalink"></a></h2><p>A quantity required to compute EFTofLSS observables is the growth rate, <span>$f$</span>. While other emulator packages employ an emulator also for <span>$f$</span> (or equivalently emulate the growth factor <span>$D$</span>), we choose a different approach, using the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DiffEq.jl</a> library to efficiently solve the equation for the growth factor, as written in <a href="https://arxiv.org/abs/astro-ph/0305286">Jenkins &amp; Linder (2003)</a></p><p class="math-container">\[D^{\prime \prime}+\frac{3}{2}\left[1-\frac{w(a)}{1+X(a)}\right] \frac{D^{\prime}}{a}-\frac{3}{2} \frac{X(a)}{1+X(a)} \frac{D}{a^2}=0\]</p><p>Performing the sostitution <span>$G=D/a$</span>, the previous equation becomes</p><p class="math-container">\[G^{\prime \prime}+\left[\frac{7}{2}-\frac{3}{2} \frac{w_{DE}(a)}{1+X(a)}\right] \frac{G^{\prime}}{a}+\frac{3}{2} \frac{1-w_{DE}(a)}{1+X(a)} \frac{G}{a^{2}}=0\]</p><p>Since we start solving the equation deep in the matter dominated era, when <span>$G(a)\sim 1$</span>, we can set as initial conditions</p><p class="math-container">\[G(z_i) = 1\]</p><p class="math-container">\[G&#39;(z_i)=0\]</p><p>Solving the previous equation is quite fast, as the benchmark shows</p><pre><code class="language-julia hljs">@benchmark Effort._D_z($z, $ΩM, $w0, $wa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  24.279 μs …  18.688 ms  ┊ GC (min … max): 0.00% … 99.57%
 Time  (median):     31.257 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   33.686 μs ± 186.622 μs  ┊ GC (mean ± σ):  5.52% ±  1.00%

             ▄█▇▆▅▂▁                                            
  ▂▃▅█▇▃▁▁▂▃▇███████▇▄▄▄▃▃▃▃▂▃▃▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  24.3 μs         Histogram: frequency by time         53.8 μs &lt;

 Memory estimate: 33.09 KiB, allocs estimate: 274.</code></pre><p>The result is also quite accurate; here is a check against the CLASS computation both for the growth factor and the growth rate</p><p><img src="https://user-images.githubusercontent.com/58727599/210219849-09646729-365a-4ab9-9372-d72e0a808c78.png" alt="growth_check_class"/></p><p>Comparing Fig. 5 of <a href="https://arxiv.org/abs/2109.15236">Donald-McCann et al. (2021)</a>, we see that the error is comparable to the one they obtained, with the advantage that we are not doing any emulation. However, if required, we may as well include an emulator for <span>$D(z)$</span> and <span>$f(z)$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 2 January 2023 11:01">Monday 2 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
