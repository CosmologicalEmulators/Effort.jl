var documenterSearchIndex = {"docs":
[{"location":"api_external/#External-API","page":"External API","title":"External API","text":"","category":"section"},{"location":"api_external/","page":"External API","title":"External API","text":"This section documents the public functions intended for users.","category":"page"},{"location":"api_external/#Effort.q_par_perp-Tuple{Any, AbstractCosmology, AbstractCosmology}","page":"External API","title":"Effort.q_par_perp","text":"q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)\n\nCalculates the parallel (q_par) and perpendicular (q_perp) Alcock-Paczynski (AP) parameters at a given redshift z, comparing a varying cosmology to a reference cosmology.\n\nThe AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.\n\nArguments\n\nz: The redshift at which to calculate the AP parameters.\ncosmo_mcmc: An AbstractCosmology struct representing the varying cosmology (e.g., from an MCMC chain).\ncosmo_ref: An AbstractCosmology struct representing the reference cosmology used for measurements.\n\nReturns\n\nA tuple (q_par, q_perp) containing the calculated parallel and perpendicular AP parameters at redshift z.\n\nDetails\n\nThe parallel AP parameter q_par is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter q_perp is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.\n\nFormula\n\nThe formulas for the Alcock-Paczynski parameters are:\n\nq_parallel(z) = fracE_textref(z)E_textmcmc(z)\n\nq_perp(z) = fractilded_Atextmcmc(z)tilded_Atextref(z)\n\nwhere E(z) is the normalized Hubble parameter and tilded_A(z) is the conformal angular diameter distance.\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.apply_AP","page":"External API","title":"Effort.apply_AP","text":"apply_AP(k_input::Array, k_output::Array, mono::Array, quad::Array, hexa::Array, q_par, q_perp; n_GL_points=8)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, using arrays of true multipole moments provided on an input wavenumber grid k_input, and employing Gauss-Lobatto quadrature.\n\nThis is the standard, faster implementation for applying the Alcock-Paczynski (AP) effect to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.\n\nArguments\n\nk_input: An array of wavenumber values on which the input true multipole moments (mono, quad, hexa) are defined.\nk_output: An array of observed wavenumber values at which to calculate the output observed multipoles.\nmono: An array containing the values of the true monopole moment I_0(k) on the k_input grid.\nquad: An array containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nhexa: An array containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nKeyword Arguments\n\nn_GL_points: The number of Gauss-Lobatto points to use for the integration over μ. The actual number of nodes used corresponds to 2 * n_GL_points. Defaults to 8.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is an array containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in k_output.\n\nDetails\n\nThe function applies the AP and RSD effects by integrating the observed anisotropic power spectrum P_textobs(k_o mu_o) over the observed cosine of the angle to the line-of-sight mu_o in 0 1 (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial mathcalL_ell(mu_o).\n\nThe process involves:\n\nDetermine Gauss-Lobatto nodes and weights for the interval [0, 1].\nFor each observed wavenumber k_o in the input k_output array and each μ_o node: a. Calculate the true wavenumber k_t(k_o mu_o) using _k_true. b. Calculate the true angle cosine mu_t(mu_o) using _μ_true. c. Interpolate the true multipole moments I_ell(k_t) using _akima_spline_legacy, interpolating from the k_input grid to the new k_t values. d. Calculate the true Legendre polynomials mathcalL_ell(mu_t) using _Legendre_0, _Legendre_2, _Legendre_4. e. Reconstruct the true power spectrum P(k_t mu_t) using _Pk_recon. f. Calculate the observed power spectrum P_textobs(k_o mu_o) = P(k_t mu_t)  (q_parallel q_perp^2).\nPerform the weighted sum (quadrature) over the μ_o nodes to get the observed multipoles P_ell(k_o) on the k_output grid.\n\nThis function is the standard, performant implementation for applying AP compared to the slower apply_AP_check.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The integral is approximated using Gauss-Lobatto quadrature.\n\nSee Also\n\napply_AP_check: The slower, check version using generic numerical integration.\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n_akima_spline: Interpolates the true multipole moments.\n_Pk_recon: Reconstructs the true power spectrum on a grid.\ngausslobatto: Function used to get quadrature nodes and weights.\n\n\n\n\n\napply_AP(k_input::Array, k_output::Array, mono::Matrix, quad::Matrix, hexa::Matrix, q_par, q_perp; n_GL_points=8)\n\nBatch version of apply_AP for processing multiple columns simultaneously.\n\nThis method applies the Alcock-Paczynski effect to multiple sets of multipole moments (e.g., multiple Jacobian columns or parameter variations) in a single call.\n\nArguments\n\nk_input::Array: Input wavenumber grid.\nk_output::Array: Output wavenumber grid.\nmono::Matrix: Monopole moments with shape (n_k, n_cols).\nquad::Matrix: Quadrupole moments with shape (n_k, n_cols).\nhexa::Matrix: Hexadecapole moments with shape (n_k, n_cols).\nq_par: Parallel AP parameter.\nq_perp: Perpendicular AP parameter.\n\nKeyword Arguments\n\nn_GL_points::Int: Number of Gauss-Lobatto points. Default: 8.\n\nReturns\n\nA tuple (mono_AP, quad_AP, hexa_AP) where each is a matrix of shape (n_k_output, n_cols) containing the AP-corrected multipoles for all input columns.\n\nDetails\n\nThis function iterates over each column of the input matrices, applies the AP effect using the single-column apply_AP method, and stacks the results back into matrices.\n\nThis is particularly useful for computing Jacobians where each column represents the derivative with respect to a different parameter.\n\nSee Also\n\napply_AP(k_input::Array, k_output::Array, mono::Array, quad::Array, hexa::Array, q_par, q_perp): Single-column version.\n\n\n\n\n\n","category":"function"},{"location":"api_external/#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::Array{T, 4}, v::Matrix) where {T}\n\nApplies a 4-dimensional window function or kernel W to a 2-dimensional input matrix v.\n\nThis operation performs a transformation or generalized convolution, summing over the j and l indices of the inputs to produce a 2D result indexed by i and k. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.\n\nArguments\n\nW: A 4-dimensional array representing the window function or kernel.\nv: A 2-dimensional matrix representing the input data.\n\nReturns\n\nA 2-dimensional matrix representing the result of the convolution or transformation.\n\nDetails\n\nThe function implements the summation using the @tullio macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.\n\nFormula\n\nThe operation is defined as:\n\nC_ik = sum_jl W_ijkl v_jl\n\nSee Also\n\nwindow_convolution(W::AbstractMatrix, v::AbstractVector): Method for a matrix kernel and vector input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::AbstractMatrix, v::AbstractVector)\n\nPerforms matrix-vector multiplication, where the matrix W acts as a linear transformation or window applied to the vector input v.\n\nArguments\n\nW: An abstract matrix representing the linear transformation or window.\nv: An abstract vector representing the input data.\n\nReturns\n\nAn abstract vector representing the result of the matrix-vector multiplication.\n\nDetails\n\nThis method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix W to the vector v.\n\nFormula\n\nThe operation is defined as:\n\nmathbfc = mathbfW mathbfv\n\nor element-wise:\n\nc_i = sum_j W_ij v_j\n\nSee Also\n\nwindow_convolution(W::Array{T, 4}, v::Matrix) where {T}: Method for a 4D kernel and matrix input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#API-reference","page":"Internal API","title":"API reference","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"This section documents the functions intended for internal usage by the package.","category":"page"},{"location":"api_internal/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Pages = [\"api_internal.md\"]","category":"page"},{"location":"api_internal/#Neural-Networks","page":"Internal API","title":"Neural Networks","text":"","category":"section"},{"location":"api_internal/#Effort.AbstractComponentEmulators","page":"Internal API","title":"Effort.AbstractComponentEmulators","text":"AbstractComponentEmulators\n\nAbstract type for component-level emulators that represent individual parts of the power spectrum calculation (e.g., P11, Ploop, Pct).\n\nAll concrete subtypes must implement the necessary fields to enable neural network evaluation, normalization, and postprocessing.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.ComponentEmulator","page":"Internal API","title":"Effort.ComponentEmulator","text":"ComponentEmulator <: AbstractComponentEmulators\n\nA complete emulator for a single power spectrum component, combining neural network predictions with normalization and physics-based postprocessing.\n\nFields\n\nTrainedEmulator::AbstractTrainedEmulators: The trained neural network (Lux or SimpleChains).\nkgrid::Array: Wavenumber grid on which the component is evaluated (in h/Mpc).\nInMinMax::Matrix{Float64}: Min-max normalization parameters for inputs (n_params × 2).\nOutMinMax::Array{Float64}: Min-max normalization parameters for outputs (n_k × 2).\nPostprocessing::Function: Function to apply physics transformations to raw NN output.\n\nDetails\n\nThe typical evaluation flow is:\n\nNormalize input parameters using InMinMax.\nEvaluate neural network to get normalized output.\nDenormalize output using OutMinMax.\nApply postprocessing (e.g., multiply by D² for P11).\n\nExample Postprocessing\n\n# For linear power spectrum component\npostprocess_P11 = (params, output, D, emu) -> output .* D^2\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.get_component","page":"Internal API","title":"Effort.get_component","text":"get_component(input_params, D, comp_emu::AbstractComponentEmulators)\n\nEvaluate a component emulator to obtain power spectrum component values.\n\nArguments\n\ninput_params: Array of input parameters (e.g., cosmological parameters).\nD: Growth factor at the redshift of interest.\ncomp_emu::AbstractComponentEmulators: The component emulator to evaluate.\n\nReturns\n\nA matrix of shape (n_k, n_samples) containing the evaluated power spectrum component values on the emulator's k-grid.\n\nDetails\n\nThis function performs the full evaluation pipeline:\n\nCopy input parameters to avoid mutation.\nApply min-max normalization to inputs.\nRun neural network inference.\nDenormalize network output.\nApply component-specific postprocessing (using D and emulator metadata).\nReshape to match k-grid dimensions.\n\nThe postprocessing step typically includes physics-based transformations such as scaling by powers of the growth factor.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.AbstractPℓEmulators","page":"Internal API","title":"Effort.AbstractPℓEmulators","text":"AbstractPℓEmulators\n\nAbstract type for complete power spectrum multipole emulators.\n\nConcrete subtypes must combine multiple component emulators (P11, Ploop, Pct) with bias models to compute full power spectrum multipoles P_ell(k) for ell in 0 2 4.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.PℓEmulator","page":"Internal API","title":"Effort.PℓEmulator","text":"PℓEmulator <: AbstractPℓEmulators\n\nComplete emulator for power spectrum multipoles in the Effective Field Theory of Large Scale Structure (EFTofLSS) framework.\n\nFields\n\nP11::ComponentEmulator: Emulator for the linear theory power spectrum component.\nPloop::ComponentEmulator: Emulator for the one-loop corrections.\nPct::ComponentEmulator: Emulator for the counterterm contributions.\nStochModel::Function: Function to compute stochastic (shot noise) terms.\nBiasCombination::Function: Function mapping bias parameters to linear combination weights.\nJacobianBiasCombination::Function: Analytical Jacobian of BiasCombination w.r.t. bias parameters.\n\nDetails\n\nThe power spectrum multipole is computed as:\n\nP_ell(k) = sum_i c_i(b_1 b_2 ) P_i(k)\n\nwhere:\n\nP_i(k) are the component power spectra (P11, Ploop, Pct, stochastic terms)\nc_i(b_1 b_2 ) are coefficients from the bias expansion\n\nThe BiasCombination function encodes the EFT bias model, while JacobianBiasCombination provides analytical derivatives for efficient gradient-based inference.\n\nExample Usage\n\n# Load pre-trained emulator\nemu = trained_emulators[\"PyBirdmnuw0wacdm\"][\"0\"]  # monopole\n\n# Evaluate power spectrum\ncosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]\nbias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]\nD = 0.8  # growth factor\n\nP0 = get_Pℓ(cosmology, D, bias, emu)\n\nSee Also\n\nget_Pℓ: Evaluate the power spectrum.\nget_Pℓ_jacobian: Evaluate power spectrum and its Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#EFT-Commands","page":"Internal API","title":"EFT Commands","text":"","category":"section"},{"location":"api_internal/#Effort.get_Pℓ_jacobian","page":"Internal API","title":"Effort.get_Pℓ_jacobian","text":"get_Pℓ_jacobian(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators; stoch_kwargs...)\n\nCompute both the power spectrum multipole P_ell(k) and its Jacobian with respect to bias parameters.\n\nArguments\n\ncosmology::Array: Array of cosmological parameters (format depends on the emulator training).\nD: Growth factor value at the redshift of interest.\nbs::Array: Array of bias parameters.\ncosmoemu::AbstractPℓEmulators: The multipole emulator containing P11, Ploop, Pct components.\n\nKeyword Arguments\n\nstoch_kwargs...: Additional keyword arguments passed to the stochastic model (e.g., shot noise parameters).\n\nReturns\n\nA tuple (Pℓ, ∂Pℓ_∂b) where:\n\nPℓ: Power spectrum multipole values evaluated on the emulator's k-grid.\n∂Pℓ_∂b: Jacobian matrix of the power spectrum with respect to bias parameters.\n\nDetails\n\nThis function is optimized for inference workflows where both the power spectrum and its derivatives are needed (e.g., gradient-based MCMC, Fisher forecasts). It computes both quantities in a single pass, avoiding redundant neural network evaluations.\n\nThe Jacobian is computed using the analytical derivative of the bias combination function, which is significantly faster than automatic differentiation for this specific operation.\n\nSee Also\n\nget_Pℓ: Compute only the power spectrum without Jacobian.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Projection","page":"Internal API","title":"Projection","text":"","category":"section"},{"location":"api_internal/#Effort._Pkμ","page":"Internal API","title":"Effort._Pkμ","text":"_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)\n\nReconstructs the anisotropic power spectrum P(k mu) at a given wavenumber k and cosine of the angle to the line-of-sight μ, using its Legendre multipole moments.\n\nArguments\n\nk: The wavenumber.\nμ: The cosine of the angle to the line-of-sight.\nInt_Mono: A function or interpolant that provides the monopole moment I_0(k) at wavenumber k.\nInt_Quad: A function or interpolant that provides the quadrupole moment I_2(k) at wavenumber k.\nInt_Hexa: A function or interpolant that provides the hexadecapole moment I_4(k) at wavenumber k.\n\nReturns\n\nThe value of the anisotropic power spectrum P(k mu) at the given k and μ.\n\nDetails\n\nThe anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at μ. The function uses the 0th, 2nd, and 4th order Legendre polynomials.\n\nFormula\n\nThe formula used is:\n\nP(k mu) = I_0(k) mathcalL_0(mu) + I_2(k) mathcalL_2(mu) + I_4(k) mathcalL_4(mu)\n\nwhere I_l(k) are the multipole moments and mathcalL_l(mu) are the Legendre polynomials of order l.\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._k_true-NTuple{4, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o, μ_o, q_perp, F)\n\nCalculates the true (physical) wavenumber k from the observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by q_perp and F.\n\nArguments\n\nk_o: The observed wavenumber (scalar).\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true wavenumber k (scalar).\n\nFormula\n\nThe formula used is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o::Array, μ_o::Array, q_perp, F): Method for arrays of observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._k_true-Tuple{Array, Array, Any, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o::Array, μ_o::Array, q_perp, F)\n\nCalculates the true (physical) wavenumber k for arrays of observed wavenumbers k_o and observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by q_perp and F.\n\nArguments\n\nk_o: An array of observed wavenumbers.\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nA vector containing the calculated true wavenumbers k for the given input arrays.\n\nDetails\n\nThe function calculates k for pairs or combinations of values from the input arrays k_o and μ_o using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.\n\nFormula\n\nThe underlying transformation for each pair of k_o and μ_o is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o, μ_o, q_perp, F): Method for scalar observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Any, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ from the observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by F.\n\nArguments\n\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true cosine of the angle to the line-of-sight μ (scalar).\n\nFormula\n\nThe formula used is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o::Array, F): Method for an array of observed values.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Array, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o::Array, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ for an array of observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by F.\n\nArguments\n\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nAn array containing the calculated true cosines of the angle to the line-of-sight μ.\n\nDetails\n\nThe function calculates μ for each value in the input array μ_o using a formula derived from anisotropic scaling. Broadcasting (@.) is used to apply the calculation element-wise.\n\nFormula\n\nThe underlying transformation for each μ_o is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o, F): Method for a scalar observed value.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._P_obs","page":"Internal API","title":"Effort._P_obs","text":"_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)\n\nCalculates the observed power spectrum P_textobs(k_o mu_o) at a given observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.\n\nArguments\n\nk_o: The observed wavenumber.\nμ_o: The observed cosine of the angle to the line-of-sight.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nInt_Mono: An interpolation function for the monopole moment I_0(k) in true k.\nInt_Quad: An interpolation function for the quadrupole moment I_2(k) in true k.\nInt_Hexa: An interpolation function for the hexadecapole moment I_4(k) in true k.\n\nReturns\n\nThe value of the observed power spectrum P_textobs(k_o mu_o).\n\nDetails\n\nThe observed coordinates (k_o mu_o) are transformed to true coordinates (k_t mu_t) using the _k_true and _μ_true functions, with F = q_parallel  q_perp. The true power spectrum P(k_t mu_t) is then reconstructed using _Pkμ and the provided multipole interpolants. Finally, the result is scaled by 1  (q_parallel q_perp^2).\n\nFormula\n\nThe formula used is:\n\nP_textobs(k_o mu_o) = frac1q_parallel q_perp^2 P(k_t mu_t)\n\nwhere\n\nk_t = text_k_true(k_o mu_o q_perp F)\n\nmu_t = text_μ_true(mu_o F)\n\nand\n\nF = q_parallel  q_perp\n\nSee Also\n\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Pkμ: Reconstructs the true power spectrum from multipole moments.\ninterp_Pℓs: Creates the multipole interpolants.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.interp_Pℓs","page":"Internal API","title":"Effort.interp_Pℓs","text":"interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)\n\nCreates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.\n\nThese interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers k.\n\nArguments\n\nMono_array: An array containing the values of the monopole moment I_0(k).\nQuad_array: An array containing the values of the quadrupole moment I_2(k).\nHexa_array: An array containing the values of the hexadecapole moment I_4(k).\nk_grid: An array containing the corresponding wavenumber k values for the multipole arrays.\n\nReturns\n\nA tuple containing three interpolation functions: (Int_Mono, Int_Quad, Int_Hexa).\n\nDetails\n\nThe function uses AkimaInterpolation from the Interpolations.jl package to create the interpolants. Extrapolation is set to ExtrapolationType.Extension, which means the interpolant will use the nearest data points to extrapolate outside the provided k_grid range. Note that extrapolation can sometimes introduce errors.\n\nSee Also\n\n_Pkμ: Uses the interpolation functions to reconstruct the anisotropic power spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}","page":"Internal API","title":"Effort.apply_AP_check","text":"apply_AP_check(k_input::Array, k_output::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array, q_par, q_perp)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, from arrays of true multipole moments provided on an input wavenumber grid k_input, using numerical integration.\n\nThis is a check version, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle μ.\n\nArguments\n\nk_input: An array of wavenumber values on which the input true multipole moments (Mono_array, Quad_array, Hexa_array) are defined.\nk_output: An array of observed wavenumber values at which to calculate the output observed multipoles.\nMono_array: An array containing the values of the true monopole moment I_0(k) on the k_input grid.\nQuad_array: An array containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nHexa_array: An array containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is an array containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in k_output.\n\nDetails\n\nThis method first creates interpolation functions for the true multipole moments using interp_Pℓs based on the k_input grid. It then calls the core apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp) method, passing k_output as the grid at which to calculate the observed multipoles.\n\nThis function is a slower check implementation and should not be used in performance-critical code.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The observed power spectrum P_textobs(k_o mu_o) is calculated using _P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa).\n\nSee Also\n\napply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp): The core method performing the integration.\ninterp_Pℓs: Creates the interpolation functions for the true multipoles.\n_P_obs: Calculates the observed power spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._Pk_recon","page":"Internal API","title":"Effort._Pk_recon","text":"_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)\n\nReconstructs the anisotropic power spectrum P(k mu) on a grid of wavenumbers k and cosines of the angle to the line-of-sight μ, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.\n\nThis function is designed to efficiently reconstruct the 2D power spectrum for multiple k and μ values simultaneously, assuming the multipole moments are provided as matrices (e.g., N_k x 1) and Legendre polynomials as vectors (e.g., N_μ).\n\nArguments\n\nmono: A matrix containing the monopole moment I_0(k) values (expected dimensions N_k x 1).\nquad: A matrix containing the quadrupole moment I_2(k) values (expected dimensions N_k x 1).\nhexa: A matrix containing the hexadecapole moment I_4(k) values (expected dimensions N_k x 1).\nl0: A vector containing the 0th order Legendre polynomial mathcalL_0(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl2: A vector containing the 2nd order Legendre polynomial mathcalL_2(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl4: A vector containing the 4th order Legendre polynomial mathcalL_4(mu) values evaluated at the desired μ values (expected dimensions N_μ).\n\nReturns\n\nA matrix representing the anisotropic power spectrum P(k mu) on the N_k x N_μ grid.\n\nDetails\n\nThe function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input k (from the rows of the moment matrices) and μ (from the elements of the Legendre polynomial vectors).\n\nFormula\n\nThe formula used for each element (i j) of the output matrix (corresponding to the i-th wavenumber and j-th angle cosine) is:\n\nP(k_i mu_j) = I_0(k_i) mathcalL_0(mu_j) + I_2(k_i) mathcalL_2(mu_j) + I_4(k_i) mathcalL_4(mu_j)\n\nSee Also\n\n_Pkμ: Reconstructs P(k mu) for single k and μ.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Utils","page":"Internal API","title":"Utils","text":"","category":"section"},{"location":"api_internal/#Effort._transformed_weights","page":"Internal API","title":"Effort._transformed_weights","text":"_transformed_weights(quadrature_rule, order, a, b)\n\nTransforms the points and weights of a standard quadrature rule from the interval [-1, 1] to a specified interval [a, b].\n\nThis is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals [a, b].\n\nArguments\n\nquadrature_rule: A function that takes an order and returns a tuple (points, weights)                    for the standard interval [-1, 1].\norder: The order of the quadrature rule (number of points).\na: The lower bound of the target interval.\nb: The upper bound of the target interval.\n\nReturns\n\nA tuple (transformed_points, transformed_weights) for the interval [a, b].\n\nDetails\n\nThe transformation is applied to the standard points x_i^textstd and weights w_i^textstd obtained from the quadrature_rule:\n\nTransformed points: x_i = fracb - a2 x_i^textstd + fracb + a2\nTransformed weights: w_i = fracb - a2 w_i^textstd\n\nFormula\n\nThe transformation formulas are: Points: x_i = fracb - a2 x_i^textstd + fracb + a2 Weights: w_i = fracb - a2 w_i^textstd\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_0","page":"Internal API","title":"Effort._Legendre_0","text":"_Legendre_0(x)\n\nCalculates the 0th order Legendre polynomial, mathcalL_0(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 0th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 0th order Legendre polynomial is:\n\nmathcalL_0(x) = 1\n\nSee Also\n\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_2","page":"Internal API","title":"Effort._Legendre_2","text":"_Legendre_2(x)\n\nCalculates the 2nd order Legendre polynomial, mathcalL_2(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 2nd order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 2nd order Legendre polynomial is:\n\nmathcalL_2(x) = frac12 (3x^2 - 1)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_4","page":"Internal API","title":"Effort._Legendre_4","text":"_Legendre_4(x)\n\nCalculates the 4th order Legendre polynomial, mathcalL_4(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 4th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 4th order Legendre polynomial is:\n\nmathcalL_4(x) = frac18 (35x^4 - 30x^2 + 3)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._cubic_spline","page":"Internal API","title":"Effort._cubic_spline","text":"_cubic_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply a cubic spline interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating a CubicSpline interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.CubicSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates a cubic spline interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.CubicSpline: The underlying interpolation function.\n_quadratic_spline: Wrapper for quadratic spline interpolation.\n_akima_spline: Wrapper for Akima interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._quadratic_spline","page":"Internal API","title":"Effort._quadratic_spline","text":"_quadratic_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply a quadratic spline interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating a QuadraticSpline interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.QuadraticSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates a quadratic spline interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.QuadraticSpline: The underlying interpolation function.\n_cubic_spline: Wrapper for cubic spline interpolation.\n_akima_spline: Wrapper for Akima interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._akima_spline","page":"Internal API","title":"Effort._akima_spline","text":"_akima_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply an Akima interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating an AkimaInterpolation interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.AkimaInterpolation(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates an Akima interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.AkimaInterpolation: The underlying interpolation function.\n_cubic_spline: Wrapper for cubic spline interpolation.\n_quadratic_spline: Wrapper for quadratic spline interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._akima_spline_legacy","page":"Internal API","title":"Effort._akima_spline_legacy","text":"_akima_spline_legacy(u, t, t_new)\n\nEvaluates the one-dimensional Akima spline that interpolates the data points (t_i u_i) at new abscissae t_new.\n\nArguments\n\nu: Ordinates (function values) u_i at the data nodes.\nt: Strictly increasing abscissae (knots) t_i associated with u. length(t) must equal length(u).\nt_new: The query point(s) where the spline is to be evaluated.\n\nReturns\n\nThe interpolated value(s) at t_new. A scalar input returns a scalar; a vector input returns a vector of the same length.\n\nDetails\n\nThis routine implements the original Akima piecewise-cubic method (T. Akima, 1970). On each interval t_j t_j+1, a cubic polynomial is constructed. The method uses a weighted average of slopes to determine the derivative at each node, which effectively dampens oscillations without explicit shape constraints. The resulting spline is C^1 continuous (its first derivative is continuous) but generally not C^2.\n\nFormulae\n\nThe spline on the interval t_j t_j+1 is a cubic polynomial: [ Sj(w) = uj + bj w + cj w^{2} + dj w^{3}, \\qquad w = t - tj ] The derivative b_j at each node is determined by Akima's weighting of local slopes m_j=(u_j-u_j-1)(t_j-t_j-1): [ bj = \\frac{|m{j+1}-m{j}|\\,m{j-1} + |m{j-1}-m{j-2}|\\,m{j}}             {|m{j+1}-m{j}| + |m{j-1}-m{j-2}|} ] The remaining coefficients, ``cjanddj``, are found by enforcing continuity of the first derivative: [ cj = \\frac{3mj - 2bj - b{j+1}}{t{j+1}-tj} ] [ dj = \\frac{bj + b{j+1} - 2mj}{(t{j+1}-t_j)^2} ]\n\nAutomatic Differentiation\n\nThe implementation is free of mutation on the inputs and uses only element-wise arithmetic, making the returned value differentiable with both ForwardDiff.jl (dual numbers) and Zygote.jl (reverse-mode AD). You can therefore embed _akima_spline_legacy in optimization or machine-learning pipelines and back-propagate through the interpolation seamlessly.\n\nNotes\n\nThe algorithm and numerical results are equivalent to the Akima spline in DataInterpolations.jl, but this routine is self-contained and avoids any package dependency.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.load_component_emulator","page":"Internal API","title":"Effort.load_component_emulator","text":"load_component_emulator(path::String; emu=LuxEmulator, k_file=\"k.npy\", weights_file=\"weights.npy\", inminmax_file=\"inminmax.npy\", outminmax_file=\"outminmax.npy\", nn_setup_file=\"nn_setup.json\", postprocessing_file=\"postprocessing_file.jl\")\n\nLoad a trained component emulator from disk.\n\nArguments\n\npath::String: Directory path containing the emulator files.\n\nKeyword Arguments\n\nemu: Emulator type to initialize (LuxEmulator or SimpleChainsEmulator). Default: LuxEmulator.\nk_file::String: Filename for the wavenumber grid. Default: \"k.npy\".\nweights_file::String: Filename for neural network weights. Default: \"weights.npy\".\ninminmax_file::String: Filename for input normalization parameters. Default: \"inminmax.npy\".\noutminmax_file::String: Filename for output normalization parameters. Default: \"outminmax.npy\".\nnn_setup_file::String: Filename for network architecture configuration. Default: \"nn_setup.json\".\npostprocessing_file::String: Filename for postprocessing function. Default: \"postprocessing_file.jl\".\n\nReturns\n\nA ComponentEmulator instance ready for evaluation.\n\nDetails\n\nThis function loads all necessary files to reconstruct a trained component emulator:\n\nNeural network architecture from JSON configuration.\nTrained weights from NumPy binary format.\nNormalization parameters for inputs and outputs.\nWavenumber grid.\nPostprocessing function dynamically loaded from Julia file.\n\nThe postprocessing function is evaluated in an isolated scope to prevent namespace pollution.\n\nExample\n\nP11_emu = load_component_emulator(\"/path/to/emulator/11/\")\n\nFile Structure\n\nThe expected directory structure is:\n\npath/\n├── k.npy                    # Wavenumber grid\n├── weights.npy              # Neural network weights\n├── inminmax.npy            # Input normalization (n_params × 2)\n├── outminmax.npy           # Output normalization (n_k × 2)\n├── nn_setup.json           # Network architecture\n└── postprocessing_file.jl  # Postprocessing function\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.load_multipole_emulator","page":"Internal API","title":"Effort.load_multipole_emulator","text":"load_multipole_emulator(path; emu=LuxEmulator, k_file=\"k.npy\", weights_file=\"weights.npy\", inminmax_file=\"inminmax.npy\", outminmax_file=\"outminmax.npy\", nn_setup_file=\"nn_setup.json\", postprocessing_file=\"postprocessing.jl\", stochmodel_file=\"stochmodel.jl\", biascombination_file=\"biascombination.jl\", jacbiascombination_file=\"jacbiascombination.jl\")\n\nLoad a complete power spectrum multipole emulator from disk.\n\nArguments\n\npath: Directory path containing the multipole emulator structure.\n\nKeyword Arguments\n\nemu: Emulator type to initialize (LuxEmulator or SimpleChainsEmulator). Default: LuxEmulator.\nk_file::String: Filename for the wavenumber grid. Default: \"k.npy\".\nweights_file::String: Filename for neural network weights. Default: \"weights.npy\".\ninminmax_file::String: Filename for input normalization parameters. Default: \"inminmax.npy\".\noutminmax_file::String: Filename for output normalization parameters. Default: \"outminmax.npy\".\nnn_setup_file::String: Filename for network architecture configuration. Default: \"nn_setup.json\".\npostprocessing_file::String: Filename for postprocessing function. Default: \"postprocessing.jl\".\nstochmodel_file::String: Filename for stochastic model function. Default: \"stochmodel.jl\".\nbiascombination_file::String: Filename for bias combination function. Default: \"biascombination.jl\".\njacbiascombination_file::String: Filename for bias Jacobian function. Default: \"jacbiascombination.jl\".\n\nReturns\n\nA PℓEmulator instance containing all three components (P11, Ploop, Pct) and bias models.\n\nDetails\n\nThis function loads a complete multipole emulator by:\n\nLoading three component emulators (P11, Ploop, Pct) from subdirectories.\nLoading the stochastic model function (shot noise terms).\nLoading the bias combination function (maps bias parameters to weights).\nLoading the analytical Jacobian of the bias combination.\n\nAll functions are evaluated in isolated scopes to prevent namespace conflicts between different emulator components.\n\nExample\n\n# Load monopole emulator\nmonopole_emu = load_multipole_emulator(\"/path/to/artifact/0/\")\n\n# Evaluate\ncosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]\nbias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]\nD = 0.8\nP0 = get_Pℓ(cosmology, D, bias, monopole_emu)\n\nFile Structure\n\nThe expected directory structure is:\n\npath/\n├── 11/                       # P11 component\n│   ├── k.npy\n│   ├── weights.npy\n│   ├── inminmax.npy\n│   ├── outminmax.npy\n│   ├── nn_setup.json\n│   └── postprocessing.jl\n├── loop/                     # Ploop component\n│   └── ... (same structure)\n├── ct/                       # Pct component\n│   └── ... (same structure)\n├── stochmodel.jl            # Stochastic model function\n├── biascombination.jl       # Bias combination function\n└── jacbiascombination.jl    # Bias Jacobian function\n\nSee Also\n\nload_component_emulator: Load individual component emulators.\nget_Pℓ: Evaluate the loaded emulator.\n\n\n\n\n\n","category":"function"},{"location":"#Effort.jl","page":"Home","title":"Effort.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is a Julia package designed to emulate the computation of the Effective Field Theory of Large Scale Structure, as computed by PyBird. An emulator is a surrogate model, a computational technique that can mimick the behaviour of computationally expensive functions, with a speedup of several orders of magnitude.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example page shows how to use Effort, while showing its computational performance.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marco Bonici, PostDoctoral Researcher at Waterloo Centre for Astrophysics\nGuido D'Amico, Associate Professor at Università Degli Studi di Parma","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Free usage of the software in this repository is provided, given that you cite our release paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Bonici, G. D'Amico, J. Bel, C. Carbone, Effort.jl: a fast and differentiable emulator for the Effective Field Theory of the Large Scale Structure of the Universe","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code has been used in the following publications:","category":"page"},{"location":"","page":"Home","title":"Home","text":"H. Zhang, M. Bonici, A. Rocher, W. J. Percival, A. de Mattia, et al., Enhancing DESI DR1 Full-Shape analyses using HOD-informed priors\nH. Zhang, M. Bonici, G. D'Amico, S. Paradiso, W. J. Percival, HOD-informed prior for EFT-based full-shape analyses of LSS\nS. Paradiso, M. Bonici, M. Chen, W. J. Percival, G. D'Amico, H. Zhang, G. McGee, Reducing nuisance prior sensitivity via non-linear reparameterization, with application to EFT analyses of large-scale structure\nA. Baleato Lizancos, U. Seljak, M. Karamanis, M. Bonici, S. Ferraro, Selecting samples of galaxies with fewer Fingers-of-God","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In order to use Effort.jl you need a trained emulator. There are two different categories of trained emulators:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"single component emulators (e.g.  P_11, P_mathrmloop, P_mathrmct)\ncomplete emulators, containing all the three different component emulators","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In this section we are going to show how to:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"obtain a multipole power spectrum, using a trained emulator\napply the Alcock-Paczyński effect\ncompute stochastic term contribution","category":"page"},{"location":"example/#Basic-usage","page":"Example","title":"Basic usage","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Let us show how to use Effort.jl to compute Power Spectrum Multipoles.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"First of all, we need some trained emulators, then we can use the Effort.get_Pℓ function","category":"page"},{"location":"example/#Effort.get_Pℓ","page":"Example","title":"Effort.get_Pℓ","text":"get_Pℓ(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators; stoch_kwargs...)\n\nCompute the power spectrum multipole P_ell(k) given cosmological parameters, bias parameters, and growth factor.\n\nArguments\n\ncosmology::Array: Array of cosmological parameters (format depends on the emulator training).\nD: Growth factor value at the redshift of interest.\nbs::Array: Array of bias parameters.\ncosmoemu::AbstractPℓEmulators: The multipole emulator containing P11, Ploop, Pct components.\n\nKeyword Arguments\n\nstoch_kwargs...: Additional keyword arguments passed to the stochastic model (e.g., shot noise parameters).\n\nReturns\n\nPower spectrum multipole values evaluated on the emulator's k-grid.\n\nDetails\n\nThis function computes the power spectrum by:\n\nEvaluating the P11, Ploop, and Pct components using the trained neural network emulators.\nComputing the stochastic contribution.\nCombining all components via the bias combination function.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Example","title":"Example","text":"info: Trained emulators\nRight now we do not provide any emulator, but with the paper publication we will release several trained emulators on Zenodo.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nPct_comp_array = Effort.compute_component(input_test, Pct_Mono_emu) #compute the components of Pct without the bias\nPct_array_Effort = Array{Float64}(zeros(length(Pct_comp_array[1,:]))) #allocate final array\nEffort.bias_multiplication!(Pct_array_Effort, bct, Pct_comp_array) #components multiplied by bias\nEffort.get_Pℓ(input_test, bs, f, Pℓ_Mono_emu) # whole multipole computation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Here we are using a ComponentEmulator, which can compute one of the components as predicted by PyBird, and a MultipoleEmulator, which emulates an entire multipole.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This computation is quite fast: a benchmark performed locally, gives the following result for a multipole computation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"benchmark[1][\"Effort\"][\"Monopole\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result of these computations look like this (Image: effort)","category":"page"},{"location":"example/#Alcock-Paczyński-effect","page":"Example","title":"Alcock-Paczyński effect","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Here we are going to write down the equations related to the AP effect, following the Ivanov et al. (2019) and D'Amico et al. (2020) notation.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In particular, we are going to use:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"rmref, for the quantities evaluated in the reference cosmology used to perform the measurements\nrmtrue, for the quantities evaluated in the true cosmology used to perform the theoretical predictions\nmathrmobs, for the observed quantities after applying the AP effect","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The wavenumbers parallel and perpendicular to the line of sight (k^mathrmtrue_parallel k^mathrmtrue_perp) are related to the ones of the reference cosmology as (k^mathrmref_parallel k^mathrmref_perp) as:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"k_^text ref =q_ k^mathrmtrue_ quad k_perp^mathrmref=q_perp k^mathrmtrue_perp","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the distortion parameters are defined by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"q_=fracD^mathrmtrue_A(z) H^mathrmtrue(z=0)D_A^mathrmref(z) H^mathrmref(z=0) quad q_perp=fracH^mathrmref(z)  H^mathrmref(z=0)H^mathrmtrue(z)  H^mathrmtrue(z=0)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where D^A, H are the angular diameter distance and Hubble parameter, respectively. In terms of these parameters, the power spectrum multipoles in the reference cosmology is given by the multipole projection integral","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"P_ell mathrmAP(k)=frac2 ell+12 int_-1^1 d mu_mathrmobs P_mathrmobsleft(k_mathrmobs mu_mathrmobsright) cdot mathcalP_ellleft(mu_mathrmobsright)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The observed P_mathrmobsleft(k_mathrmobs mu_mathrmobsright), when including the AP effect, is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"P_mathrmobsleft(k_mathrmobs mu_mathrmobsright)= frac1q_ q_perp^2 cdot P_gleft(k_text true leftk_mathrmobs mu_mathrmobsright mu_text true leftk_text obs  mu_mathrmobsrightright)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In the Effort.jl workflow, the Alcock-Paczyński (AP) effect can be included in two different ways:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"by training the emulators using spectra where the AP effect has already been applied\nby using standard trained emulators and applying analitycally the AP effect","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"While the former approach is computationally faster (there is no overhead from the NN point-of-view), the latter is more flexible, since the reference cosmology for the AP effect computation can be changed at runtime.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Regarding the second approach, the most important choice regards the algorithm employed to compute the multipole projection integral. Here we implement two different approaches, based on","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"QuadGK.jl. This approach is the most precise, since it uses an adaptive method to compute the integral.\nFastGaussQuadrature.jl. This approach is the fastest, since we are going to employ only 5 points to compute the integral, taking advantage of the Gauss-Lobatto quadrature rule.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In order to understand why it is possible to use few points to evaluate the AP projection integral, it is intructive to plot the mu dependence of the integrand","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: mu_dependence)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The ell=4 integrand, the most complicated one, can be accurately fit with a n=8 polynomial","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: polyfit_residuals)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since a n Gauss-Lobatto rule can integrate exactly 2n  3 degree polynomials,  we expect that a GL rule with 10 points can perform the integral with high precision.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we can show how to use Effort.jl to compute the AP effect using the GK adaptive integration","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nEffort.apply_AP_check(k_test, k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP_check\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"As said, this is precise but a bit expensive from a computational point of view. What about Gauss-Lobatto?","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nEffort.apply_AP(k_test, k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This is 200 times faster than the adaptive integration, but is also very accurate! A comparison with the GK-based rule shows a percentual relative difference of about 10^-11 for the Hexadecapole, with a higher precision for the other two multipoles.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: gk_gl_residuals)","category":"page"},{"location":"example/#Growth-factor","page":"Example","title":"Growth factor","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"A quantity required to compute EFTofLSS observables is the growth rate, f. While other emulator packages employ an emulator also for f (or equivalently emulate the growth factor D), we choose a different approach, using the DiffEq.jl library to efficiently solve the equation for the growth factor, as written in Bayer, Banerjee & Feng (2021)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(a)+left(2+fracE(a)E(a)right)D(a)=frac32Omega_m(a)D(a)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where E(a) is the adimensional Hubble factor, whose expression is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"E(a)=leftOmega_gamma 0 a^-4+Omega_c 0 a^-3+Omega_nu(a) E^2(a)+Omega_mathrmDE(a)right^1  2","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since we start solving the equation deep in the matter dominated era, when D(a)sim a, we can set as initial conditions","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(z_i) = a_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(z_i)=a_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In E(a), we precisely take into account radiation, non-relativistic matter, massive neutrinos, evolving Dark Energy. Regarding massive neutrinos, their energy density is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Omega_nu(a) E^2(a)=frac15pi^4 Gamma_nu^4 fracOmega_gamma 0a^4 sum_j=1^N_nu mathcalFleft(fracm_j ak_B T_nu 0right)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"with","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mathcalF(y) equiv int_0^infty d x fracx^2 sqrtx^2+y^21+e^x","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Regarding Dark Energy, its contribution to the Hubble is","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Omega_mathrmDE(a)=Omega_mathrmDE0(1+z)^3left(1+w_0+w_aright) e^-3 w_a z (1+z)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Solving the previous equation is quite fast, as the benchmark shows","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@benchmark Effort._D_z($z, $ΩM, $h)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"Growth\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result is also quite accurate; here is a check against the CLASS computation both for the growth factor and the growth rate","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: growth_check_class)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since the final goal is to embedd Effort in bayesian analysis pipelines which need gradient computations, emphasis has been put on its compatibility with AD tools such as ForwardDiff and Enzyme. In particular, for the ODE solution, this is guaranteed by the SciMLSensitivity stack.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Comparing with Fig. 5 of Donald-McCann et al. (2021), we see that the error is similar to the one they obtained, with the advantage that we don't have the restriction of an emulation range. However, if required, we may as well include an emulator for D(z) and f(z).","category":"page"},{"location":"example/#Automatic-Differentiation","page":"Example","title":"Automatic Differentiation","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Great care has been devoted to ensure that Effort is compatible with AD systems. Here, in particular, we are going to show the performance of backward-AD as implemented in Zygote.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@benchmark Zygote.gradient(k_test->sum(Effort.apply_AP(k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)), k_test)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP & Zygote\"] # hide","category":"page"}]
}
