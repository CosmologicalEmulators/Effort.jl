var documenterSearchIndex = {"docs":
[{"location":"implementation_details/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"This page provides technical details about the algorithms and numerical methods implemented in Effort.jl.","category":"page"},{"location":"implementation_details/#Overview","page":"Implementation Details","title":"Overview","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The package implements efficient computational methods for:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Background cosmology - ODE solvers for growth factors\nNeural network emulation - Fast prediction of power spectrum multipoles\nAlcock-Paczynski corrections - Geometric distortions from cosmological parameters\nWindow convolution - Survey geometry effects","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#1.-Background-Cosmology-and-Growth-Factors","page":"Implementation Details","title":"1. Background Cosmology and Growth Factors","text":"","category":"section"},{"location":"implementation_details/#Normalized-Hubble-Parameter","page":"Implementation Details","title":"Normalized Hubble Parameter","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The normalized Hubble parameter E(z) quantifies the expansion rate of the universe as a function of redshift:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"E(z) = fracH(z)H_0 = sqrtOmega_m(1+z)^3 + Omega_k(1+z)^2 + Omega_DE(z)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"For the w0waCDM model, the dark energy density parameter evolves as:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Omega_DE(z) = Omega_DE0 (1+z)^3(1 + w_0 + w_a) expleft(-frac3w_a z1+zright)","category":"page"},{"location":"implementation_details/#Growth-Factor-D(z)","page":"Implementation Details","title":"Growth Factor D(z)","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The linear growth factor D(z) describes the growth of matter perturbations and is computed by solving the ODE:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"fracd^2 Dda^2 + left(frac3a + fracdln Hdaright)fracdDda = frac3Omega_m(a)2a^2 D","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"where a = 1(1+z) is the scale factor. This is solved using high-order Runge-Kutta methods (Tsit5) from OrdinaryDiffEq.jl.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Initial conditions: At high redshift (z = 1000), the growth factor is normalized such that D(z=0) = 1 in the fiducial cosmology.","category":"page"},{"location":"implementation_details/#Growth-Rate-f(z)","page":"Implementation Details","title":"Growth Rate f(z)","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The logarithmic derivative of the growth factor is the growth rate:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"f(z) = fracd ln Dd ln a = -(1+z) fracdDdzD","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"This parameter appears in redshift-space distortions and affects the quadrupole and hexadecapole multipoles.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#2.-Power-Spectrum-Emulation","page":"Implementation Details","title":"2. Power Spectrum Emulation","text":"","category":"section"},{"location":"implementation_details/#Neural-Network-Architecture","page":"Implementation Details","title":"Neural Network Architecture","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The emulators use feedforward neural networks to predict power spectrum components:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Input: 9 cosmological parameters z ln(10^10A_mathrms) n_mathrms H_0 omega_b omega_mathrmcdm Sigma m_nu w_0 w_a\nHidden layers: Multiple hidden layers with activation functions\nOutput: Three components of the power spectrum:\nP_11: Linear-linear contribution\nP_textloop: One-loop contribution\nP_ct: Counter-term contribution","category":"page"},{"location":"implementation_details/#Bias-Expansion","page":"Implementation Details","title":"Bias Expansion","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The observed galaxy power spectrum is related to the matter power spectrum through bias parameters b_i:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"P_g(k mu) = D^2 sum_i=1^N_textbias b_i cdot mathcalB_i(k mu P_11 P_textloop P_ct)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"where mathcalB_i are basis functions combining the emulated components with geometric factors.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Standard setup: 11 bias parameters, including:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"b_1: Linear bias\nb_2 b_3 ldots: Higher-order bias terms\nb_8 = f(z): Growth rate (for RSD)\nb_9 b_10 b_11: Stochastic and shot noise terms","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#3.-Alcock-Paczynski-Effect","page":"Implementation Details","title":"3. Alcock-Paczynski Effect","text":"","category":"section"},{"location":"implementation_details/#Physical-Interpretation","page":"Implementation Details","title":"Physical Interpretation","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The Alcock-Paczynski (AP) effect arises when the assumed reference cosmology differs from the true cosmology. Observations are made in redshift space (k_o mu_o), but the true clustering is in real space (k_t mu_t).","category":"page"},{"location":"implementation_details/#AP-Parameters","page":"Implementation Details","title":"AP Parameters","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The distortion is quantified by two parameters:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"q_parallel(z) = fracH_textref(z)H_texttrue(z) = fracE_textref(z)E_texttrue(z)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"q_perp(z) = fracd_Atexttrue(z)d_Atextref(z) = fractilded_Atexttrue(z)tilded_Atextref(z)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"where d_A is the angular diameter distance and tilded_A is the conformal angular diameter distance.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Physical meaning:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"q_parallel  1: Reference cosmology overestimates radial distances → clustering appears compressed along line-of-sight\nq_perp  1: Reference cosmology overestimates transverse distances → clustering appears compressed perpendicular to line-of-sight","category":"page"},{"location":"implementation_details/#Coordinate-Transformation","page":"Implementation Details","title":"Coordinate Transformation","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The transformation from observed to true coordinates:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"k_t = frack_oq_perp sqrt1 + mu_o^2 left(fracq_perp^2q_parallel^2 - 1right)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"mu_t = fracmu_o q_perpq_parallel sqrt1 + mu_o^2 left(fracq_perp^2q_parallel^2 - 1right)","category":"page"},{"location":"implementation_details/#Observed-Power-Spectrum","page":"Implementation Details","title":"Observed Power Spectrum","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The observed power spectrum in redshift space is:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"P_textobs(k_o mu_o) = frac1q_parallel q_perp^2 P_texttrue(k_t mu_t)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The factor 1(q_parallel q_perp^2) accounts for the volume distortion.","category":"page"},{"location":"implementation_details/#Multipole-Projection","page":"Implementation Details","title":"Multipole Projection","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"To obtain the observed multipoles, we integrate over the angular dependence:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"P_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o)  dmu_o","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"where mathcalL_ell(mu) are Legendre polynomials:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"beginaligned\nmathcalL_0(mu) = 1 \nmathcalL_2(mu) = frac12(3mu^2 - 1) \nmathcalL_4(mu) = frac18(35mu^4 - 30mu^2 + 3)\nendaligned","category":"page"},{"location":"implementation_details/#Numerical-Implementation","page":"Implementation Details","title":"Numerical Implementation","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Effort.jl provides two implementations:","category":"page"},{"location":"implementation_details/#1.-Standard-Implementation-(apply_AP)","page":"Implementation Details","title":"1. Standard Implementation (apply_AP)","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Uses Gauss-Lobatto quadrature for fast integration:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Compute quadrature nodes mu_1 ldots mu_n and weights w_1 ldots w_n\nFor each k_o and each mu_i:\nTransform to true coordinates: (k_t mu_t) = f(k_o mu_i q_parallel q_perp)\nInterpolate true multipoles at k_t using Akima splines\nReconstruct P_texttrue(k_t mu_t) from multipoles\nScale by volume factor: P_textobs = P_texttrue  (q_parallel q_perp^2)\nCompute weighted sum: P_ell(k_o) = (2ell+1) sum_i w_i P_textobs(k_o mu_i) mathcalL_ell(mu_i)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Typical performance: ~30 μs for 3 multipoles at 50 k-points (8 Gauss-Lobatto nodes)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Exploiting symmetry: Since the integrand is even in mu for even multipoles (ell = 0 2 4), we only integrate over 0 1 instead of -1 1, halving the number of evaluations.","category":"page"},{"location":"implementation_details/#2.-Check-Implementation-(apply_AP_check)","page":"Implementation Details","title":"2. Check Implementation (apply_AP_check)","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Uses adaptive quadrature (QuadGK) for validation:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Higher accuracy (textreltol = 10^-12)\n~10-100× slower than Gauss-Lobatto\nUseful for testing and verification","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#4.-Interpolation:-Akima-Splines","page":"Implementation Details","title":"4. Interpolation: Akima Splines","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Multipole moments are defined on a discrete k-grid, but AP corrections require evaluation at arbitrary k_t values. Effort.jl uses Akima interpolation for this purpose.","category":"page"},{"location":"implementation_details/#Why-Akima?","page":"Implementation Details","title":"Why Akima?","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Compared to cubic splines:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Local: Each interval depends only on 5 nearby points (vs. global for cubic splines)\nNo oscillations: Avoids Runge's phenomenon near steep gradients\nFast: Efficient for repeated evaluations","category":"page"},{"location":"implementation_details/#Mathematical-Form","page":"Implementation Details","title":"Mathematical Form","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"For data points (k_1 P_1) ldots (k_n P_n), Akima constructs a piecewise cubic polynomial:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"P(k) = a_i + b_i(k - k_i) + c_i(k - k_i)^2 + d_i(k - k_i)^3 quad k in k_i k_i+1","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Coefficients are determined by local slopes that minimize oscillations.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Extrapolation: Uses nearest-neighbor extension (constant extrapolation beyond data range).","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#5.-Window-Convolution","page":"Implementation Details","title":"5. Window Convolution","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Survey geometry introduces correlations between different k modes through the window function W(k k):","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"P_ell^textobs(k) = sum_k W_ellell(k k) P_ell^texttrue(k)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"For 2D analyses (k and multipole ell), this generalizes to a 4D kernel:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"C_ik = sum_jl W_ijkl v_jl","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"This is efficiently computed using the @tullio macro for tensor contractions.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Applications:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Fiber collisions\nAngular selection functions\nSurvey boundaries","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Reference: Beutler et al. 2019 (arXiv:1810.05051)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#6.-Differentiation:-Automatic-vs-Analytical","page":"Implementation Details","title":"6. Differentiation: Automatic vs Analytical","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Effort.jl provides two complementary differentiation strategies, each optimized for specific use cases in cosmological inference.","category":"page"},{"location":"implementation_details/#6.1-Automatic-Differentiation-(AD)","page":"Implementation Details","title":"6.1 Automatic Differentiation (AD)","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The package is fully compatible with Julia's AD ecosystem:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"ForwardDiff.jl: Forward-mode AD for efficient gradients (explicitly tested)\nZygote.jl: Reverse-mode AD for large parameter spaces (explicitly tested)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Use case: Gradient-based MCMC (HMC, NUTS) and maximum likelihood optimization.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"When performing MCMC or variational inference, you can differentiate the likelihood function directly through the entire pipeline (ODE solvers → emulators → AP corrections). This works seamlessly because:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Custom ChainRules: Hand-written adjoints for Akima interpolation, window convolution, and other critical operations\nSciMLSensitivity: Efficient gradients through ODE solvers via sensitivity analysis\nNon-mutating code: All functions avoid in-place mutations (Zygote-compatible)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Example derivatives:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"fracpartial mathcalLpartial theta_i quad textwhere  theta in h omega_c w_0 ldots","category":"page"},{"location":"implementation_details/#6.2-Analytical-Jacobians","page":"Implementation Details","title":"6.2 Analytical Jacobians","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The package also provides analytical Jacobian implementations for derivatives with respect to bias parameters:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"J_ki = fracpartial P_ell(k)partial b_i","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Use case: Fisher Information Matrix computation for Jeffreys priors and survey forecasts.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Why not use AD? When computing Fisher matrices during MCMC analysis, using AD for Jacobians would require:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Computing Jacobian via AD: J = nabla_b P_ell(k b)\nDifferentiating likelihood (which uses J) via AD: nabla_theta mathcalL(theta J)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"This is AD over AD (nested differentiation), which is:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Computationally expensive\nNumerically unstable\nDifficult to debug","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Solution: Analytical Jacobians avoid this by providing closed-form derivatives. These are:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Fast: Direct computation without AD overhead\nMemory-efficient: Optimized matrix operations\nValidated: Tested against both Computer Algebra Systems (symbolic differentiation) and AD (numerical validation)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The validation ensures:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"J_textanalytical approx J_textAD approx J_textCAS quad (textwithin numerical precision)","category":"page"},{"location":"implementation_details/#6.3-Implementation-Details","page":"Implementation Details","title":"6.3 Implementation Details","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"AD-compatible operations:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Neural network evaluation (matrix operations)\nODE solvers with SciMLSensitivity\nAkima interpolation with custom ChainRules\nWindow convolution via Tullio.jl (AD-aware)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Analytical Jacobian features:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Batched computation for all 11 bias parameters simultaneously\nMatrix interface compatible with apply_AP for efficient AP corrections\nExplicit tests in test/test_pipeline.jl validate against ForwardDiff, Zygote, and FiniteDifferences","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#7.-Performance-Optimizations","page":"Implementation Details","title":"7. Performance Optimizations","text":"","category":"section"},{"location":"implementation_details/#Batch-Processing","page":"Implementation Details","title":"Batch Processing","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The apply_AP function supports matrix inputs, allowing multiple columns (e.g., Jacobian columns) to be processed simultaneously:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"apply_AP(k_in, k_out, mono_matrix, quad_matrix, hexa_matrix, q_par, q_perp)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Speedup: ~2.5× faster than column-by-column processing by using optimized matrix Akima interpolation.","category":"page"},{"location":"implementation_details/#Memory-Efficiency","page":"Implementation Details","title":"Memory Efficiency","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Preallocated arrays for intermediate computations\nIn-place operations where possible (avoiding allocations)\nBroadcasting for vectorized operations","category":"page"},{"location":"implementation_details/#Numerical-Stability","page":"Implementation Details","title":"Numerical Stability","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Logarithmic extrapolation for power spectra (prevents negative values)\nRelative tolerances adapted to physical scales\nRobust handling of edge cases (q approx 1, mu approx 0)","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#Summary","page":"Implementation Details","title":"Summary","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Feature Method Performance\nGrowth factors D(z), f(z) ODE solve (Tsit5) ~160-180 μs\nMultipole emulation Neural network ~26 μs per multipole\nAP corrections Gauss-Lobatto quadrature ~33 μs (3 multipoles)\nInterpolation Akima splines <1 μs per evaluation\nWindow convolution Tensor contraction Varies with kernel size","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"All timings are approximate and depend on hardware (see Example page for system specifications).","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"implementation_details/#Further-Reading","page":"Implementation Details","title":"Further Reading","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"EFTofLSS theory: Baumann et al. 2012 (arXiv:1004.2488)\nPyBird code: D'Amico et al. 2020 (arXiv:1909.05271)\nAlcock-Paczynski effect: Alcock & Paczynski 1979\nNeural network emulation: Nishimichi et al. 2019 (arXiv:1811.09504)\nWindow convolution: Beutler et al. 2019 (arXiv:1810.05051)","category":"page"},{"location":"api_external/#External-API","page":"External API","title":"External API","text":"","category":"section"},{"location":"api_external/","page":"External API","title":"External API","text":"This section documents the public functions intended for users.","category":"page"},{"location":"api_external/#Effort.q_par_perp-Tuple{Any, AbstractCosmology, AbstractCosmology}","page":"External API","title":"Effort.q_par_perp","text":"q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)\n\nCalculates the parallel (q_par) and perpendicular (q_perp) Alcock-Paczynski (AP) parameters at a given redshift z, comparing a varying cosmology to a reference cosmology.\n\nThe AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.\n\nArguments\n\nz: The redshift at which to calculate the AP parameters.\ncosmo_mcmc: An AbstractCosmology struct representing the varying cosmology (e.g., from an MCMC chain).\ncosmo_ref: An AbstractCosmology struct representing the reference cosmology used for measurements.\n\nReturns\n\nA tuple (q_par, q_perp) containing the calculated parallel and perpendicular AP parameters at redshift z.\n\nDetails\n\nThe parallel AP parameter q_par is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter q_perp is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.\n\nFormula\n\nThe formulas for the Alcock-Paczynski parameters are:\n\nq_parallel(z) = fracE_textref(z)E_textmcmc(z)\n\nq_perp(z) = fractilded_Atextmcmc(z)tilded_Atextref(z)\n\nwhere E(z) is the normalized Hubble parameter and tilded_A(z) is the conformal angular diameter distance.\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.apply_AP","page":"External API","title":"Effort.apply_AP","text":"apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp; n_GL_points=8)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, using arrays of true multipole moments provided on an input wavenumber grid k_input, and employing Gauss-Lobatto quadrature.\n\nThis is the standard, faster implementation for applying the Alcock-Paczynski (AP) effect to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.\n\nArguments\n\nk_input: A vector of wavenumber values on which the input true multipole moments (mono, quad, hexa) are defined.\nk_output: A vector of observed wavenumber values at which to calculate the output observed multipoles.\nmono: A vector containing the values of the true monopole moment I_0(k) on the k_input grid.\nquad: A vector containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nhexa: A vector containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nKeyword Arguments\n\nn_GL_points: The number of Gauss-Lobatto points to use for the integration over μ. The actual number of nodes used corresponds to 2 * n_GL_points. Defaults to 8.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in k_output.\n\nDetails\n\nThe function applies the AP and RSD effects by integrating the observed anisotropic power spectrum P_textobs(k_o mu_o) over the observed cosine of the angle to the line-of-sight mu_o in 0 1 (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial mathcalL_ell(mu_o).\n\nThe process involves:\n\nDetermine Gauss-Lobatto nodes and weights for the interval [0, 1].\nFor each observed wavenumber k_o in the input k_output array and each μ_o node: a. Calculate the true wavenumber k_t(k_o mu_o) using _k_true. b. Calculate the true angle cosine mu_t(mu_o) using _μ_true. c. Interpolate the true multipole moments I_ell(k_t) using _akima_interpolation, interpolating from the k_input grid to the new k_t values. d. Calculate the true Legendre polynomials mathcalL_ell(mu_t) using _Legendre_0, _Legendre_2, _Legendre_4. e. Reconstruct the true power spectrum P(k_t mu_t) using _Pk_recon. f. Calculate the observed power spectrum P_textobs(k_o mu_o) = P(k_t mu_t)  (q_parallel q_perp^2).\nPerform the weighted sum (quadrature) over the μ_o nodes to get the observed multipoles P_ell(k_o) on the k_output grid.\n\nThis function is the standard, performant implementation for applying AP compared to the slower apply_AP_check.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The integral is approximated using Gauss-Lobatto quadrature.\n\nSee Also\n\napply_AP_check: The slower, check version using generic numerical integration.\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n_akima_interpolation: Interpolates the true multipole moments.\n_Pk_recon: Reconstructs the true power spectrum on a grid.\ngausslobatto: Function used to get quadrature nodes and weights.\n\n\n\n\n\napply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractMatrix, quad::AbstractMatrix, hexa::AbstractMatrix, q_par, q_perp; n_GL_points=8)\n\nBatch version of apply_AP for processing multiple columns simultaneously using optimized matrix Akima interpolation.\n\nThis method applies the Alcock-Paczynski effect to multiple sets of multipole moments (e.g., multiple Jacobian columns or parameter variations) in a single call. It leverages the optimized matrix Akima spline implementation to interpolate all columns at once, providing significant performance improvements over column-by-column processing.\n\nArguments\n\nk_input::AbstractVector: Input wavenumber grid.\nk_output::AbstractVector: Output wavenumber grid.\nmono::AbstractMatrix: Monopole moments with shape (n_k, n_cols).\nquad::AbstractMatrix: Quadrupole moments with shape (n_k, n_cols).\nhexa::AbstractMatrix: Hexadecapole moments with shape (n_k, n_cols).\nq_par: Parallel AP parameter.\nq_perp: Perpendicular AP parameter.\n\nKeyword Arguments\n\nn_GL_points::Int: Number of Gauss-Lobatto points. Default: 8.\n\nReturns\n\nA tuple (mono_AP, quad_AP, hexa_AP) where each is a matrix of shape (n_k_output, n_cols) containing the AP-corrected multipoles for all input columns.\n\nDetails\n\nThis optimized implementation uses matrix Akima interpolation to process all columns simultaneously rather than iterating column-by-column. For N columns, this reduces 3×N Akima calls to just 3 matrix Akima calls, providing a ~2-3× speedup.\n\nThis is particularly useful for computing Jacobians where each column represents the derivative with respect to a different parameter (typically 11 bias parameters).\n\nPerformance\n\nFor typical DESI-like scenarios (50 input k-points, 100 output k-points, 11 columns):\n\nOld implementation: ~6 ms (33 scalar Akima calls)\nNew implementation: ~2 ms (3 matrix Akima calls)\nSpeedup: ~2.5-3×\n\nSee Also\n\napply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp): Single-column version.\n_akima_interpolation(u::AbstractMatrix, t, t_new): Optimized matrix Akima interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_external/#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::Array{T, 4}, v::Matrix) where {T}\n\nApplies a 4-dimensional window function or kernel W to a 2-dimensional input matrix v.\n\nThis operation performs a transformation or generalized convolution, summing over the j and l indices of the inputs to produce a 2D result indexed by i and k. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.\n\nArguments\n\nW: A 4-dimensional array representing the window function or kernel.\nv: A 2-dimensional matrix representing the input data.\n\nReturns\n\nA 2-dimensional matrix representing the result of the convolution or transformation.\n\nDetails\n\nThe function implements the summation using the @tullio macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.\n\nFormula\n\nThe operation is defined as:\n\nC_ik = sum_jl W_ijkl v_jl\n\nSee Also\n\nwindow_convolution(W::AbstractMatrix, v::AbstractVector): Method for a matrix kernel and vector input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::AbstractMatrix, v::AbstractVector)\n\nPerforms matrix-vector multiplication, where the matrix W acts as a linear transformation or window applied to the vector input v.\n\nArguments\n\nW: An abstract matrix representing the linear transformation or window.\nv: An abstract vector representing the input data.\n\nReturns\n\nAn abstract vector representing the result of the matrix-vector multiplication.\n\nDetails\n\nThis method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix W to the vector v.\n\nFormula\n\nThe operation is defined as:\n\nmathbfc = mathbfW mathbfv\n\nor element-wise:\n\nc_i = sum_j W_ij v_j\n\nSee Also\n\nwindow_convolution(W::Array{T, 4}, v::Matrix) where {T}: Method for a 4D kernel and matrix input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#API-reference","page":"Internal API","title":"API reference","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"This section documents the functions intended for internal usage by the package.","category":"page"},{"location":"api_internal/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Pages = [\"api_internal.md\"]","category":"page"},{"location":"api_internal/#Neural-Networks","page":"Internal API","title":"Neural Networks","text":"","category":"section"},{"location":"api_internal/#Effort.AbstractComponentEmulators","page":"Internal API","title":"Effort.AbstractComponentEmulators","text":"AbstractComponentEmulators\n\nAbstract type for component-level emulators that represent individual parts of the power spectrum calculation (e.g., P11, Ploop, Pct).\n\nAll concrete subtypes must implement the necessary fields to enable neural network evaluation, normalization, and postprocessing.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.ComponentEmulator","page":"Internal API","title":"Effort.ComponentEmulator","text":"ComponentEmulator <: AbstractComponentEmulators\n\nA complete emulator for a single power spectrum component, combining neural network predictions with normalization and physics-based postprocessing.\n\nFields\n\nTrainedEmulator::AbstractTrainedEmulators: The trained neural network (Lux or SimpleChains).\nkgrid::Array: Wavenumber grid on which the component is evaluated (in h/Mpc).\nInMinMax::Matrix{Float64}: Min-max normalization parameters for inputs (n_params × 2).\nOutMinMax::Array{Float64}: Min-max normalization parameters for outputs (n_k × 2).\nPostprocessing::Function: Function to apply physics transformations to raw NN output.\n\nDetails\n\nThe typical evaluation flow is:\n\nNormalize input parameters using InMinMax.\nEvaluate neural network to get normalized output.\nDenormalize output using OutMinMax.\nApply postprocessing (e.g., multiply by D² for P11).\n\nExample Postprocessing\n\n# For linear power spectrum component\npostprocess_P11 = (params, output, D, emu) -> output .* D^2\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.get_component","page":"Internal API","title":"Effort.get_component","text":"get_component(input_params, D, comp_emu::AbstractComponentEmulators)\n\nEvaluate a component emulator to obtain power spectrum component values.\n\nArguments\n\ninput_params: Array of input parameters (e.g., cosmological parameters).\nD: Growth factor at the redshift of interest.\ncomp_emu::AbstractComponentEmulators: The component emulator to evaluate.\n\nReturns\n\nA matrix of shape (n_k, n_samples) containing the evaluated power spectrum component values on the emulator's k-grid.\n\nDetails\n\nThis function performs the full evaluation pipeline:\n\nCopy input parameters to avoid mutation.\nApply min-max normalization to inputs.\nRun neural network inference.\nDenormalize network output.\nApply component-specific postprocessing (using D and emulator metadata).\nReshape to match k-grid dimensions.\n\nThe postprocessing step typically includes physics-based transformations such as scaling by powers of the growth factor.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.AbstractPℓEmulators","page":"Internal API","title":"Effort.AbstractPℓEmulators","text":"AbstractPℓEmulators\n\nAbstract type for complete power spectrum multipole emulators.\n\nConcrete subtypes must combine multiple component emulators (P11, Ploop, Pct) with bias models to compute full power spectrum multipoles P_ell(k) for ell in 0 2 4.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#Effort.PℓEmulator","page":"Internal API","title":"Effort.PℓEmulator","text":"PℓEmulator <: AbstractPℓEmulators\n\nComplete emulator for power spectrum multipoles in the Effective Field Theory of Large Scale Structure (EFTofLSS) framework.\n\nFields\n\nP11::ComponentEmulator: Emulator for the linear theory power spectrum component.\nPloop::ComponentEmulator: Emulator for the one-loop corrections.\nPct::ComponentEmulator: Emulator for the counterterm contributions.\nStochModel::Function: Function to compute stochastic (shot noise) terms.\nBiasCombination::Function: Function mapping bias parameters to linear combination weights.\nJacobianBiasCombination::Function: Analytical Jacobian of BiasCombination w.r.t. bias parameters.\n\nDetails\n\nThe power spectrum multipole is computed as:\n\nP_ell(k) = sum_i c_i(b_1 b_2 ) P_i(k)\n\nwhere:\n\nP_i(k) are the component power spectra (P11, Ploop, Pct, stochastic terms)\nc_i(b_1 b_2 ) are coefficients from the bias expansion\n\nThe BiasCombination function encodes the EFT bias model, while JacobianBiasCombination provides analytical derivatives for efficient gradient-based inference.\n\nExample Usage\n\n# Load pre-trained emulator\nemu = trained_emulators[\"PyBirdmnuw0wacdm\"][\"0\"]  # monopole\n\n# Evaluate power spectrum\ncosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]\nbias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]\nD = 0.8  # growth factor\n\nP0 = get_Pℓ(cosmology, D, bias, emu)\n\nSee Also\n\nget_Pℓ: Evaluate the power spectrum.\nget_Pℓ_jacobian: Evaluate power spectrum and its Jacobian.\n\n\n\n\n\n","category":"type"},{"location":"api_internal/#EFT-Commands","page":"Internal API","title":"EFT Commands","text":"","category":"section"},{"location":"api_internal/#Effort.get_Pℓ_jacobian","page":"Internal API","title":"Effort.get_Pℓ_jacobian","text":"get_Pℓ_jacobian(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators; stoch_kwargs...)\n\nCompute both the power spectrum multipole P_ell(k) and its Jacobian with respect to bias parameters.\n\nArguments\n\ncosmology::Array: Array of cosmological parameters (format depends on the emulator training).\nD: Growth factor value at the redshift of interest.\nbs::Array: Array of bias parameters.\ncosmoemu::AbstractPℓEmulators: The multipole emulator containing P11, Ploop, Pct components.\n\nKeyword Arguments\n\nstoch_kwargs...: Additional keyword arguments passed to the stochastic model (e.g., shot noise parameters).\n\nReturns\n\nA tuple (Pℓ, ∂Pℓ_∂b) where:\n\nPℓ: Power spectrum multipole values evaluated on the emulator's k-grid.\n∂Pℓ_∂b: Jacobian matrix of the power spectrum with respect to bias parameters.\n\nDetails\n\nThis function is optimized for inference workflows where both the power spectrum and its derivatives are needed (e.g., gradient-based MCMC, Fisher forecasts). It computes both quantities in a single pass, avoiding redundant neural network evaluations.\n\nThe Jacobian is computed using the analytical derivative of the bias combination function, which is significantly faster than automatic differentiation for this specific operation.\n\nSee Also\n\nget_Pℓ: Compute only the power spectrum without Jacobian.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Projection","page":"Internal API","title":"Projection","text":"","category":"section"},{"location":"api_internal/#Effort._Pkμ","page":"Internal API","title":"Effort._Pkμ","text":"_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)\n\nReconstructs the anisotropic power spectrum P(k mu) at a given wavenumber k and cosine of the angle to the line-of-sight μ, using its Legendre multipole moments.\n\nArguments\n\nk: The wavenumber.\nμ: The cosine of the angle to the line-of-sight.\nInt_Mono: A function or interpolant that provides the monopole moment I_0(k) at wavenumber k.\nInt_Quad: A function or interpolant that provides the quadrupole moment I_2(k) at wavenumber k.\nInt_Hexa: A function or interpolant that provides the hexadecapole moment I_4(k) at wavenumber k.\n\nReturns\n\nThe value of the anisotropic power spectrum P(k mu) at the given k and μ.\n\nDetails\n\nThe anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at μ. The function uses the 0th, 2nd, and 4th order Legendre polynomials.\n\nFormula\n\nThe formula used is:\n\nP(k mu) = I_0(k) mathcalL_0(mu) + I_2(k) mathcalL_2(mu) + I_4(k) mathcalL_4(mu)\n\nwhere I_l(k) are the multipole moments and mathcalL_l(mu) are the Legendre polynomials of order l.\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._k_true-NTuple{4, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o, μ_o, q_perp, F)\n\nCalculates the true (physical) wavenumber k from the observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by q_perp and F.\n\nArguments\n\nk_o: The observed wavenumber (scalar).\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true wavenumber k (scalar).\n\nFormula\n\nThe formula used is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o::Array, μ_o::Array, q_perp, F): Method for arrays of observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._k_true-Tuple{Array, Array, Any, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o::Array, μ_o::Array, q_perp, F)\n\nCalculates the true (physical) wavenumber k for arrays of observed wavenumbers k_o and observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by q_perp and F.\n\nArguments\n\nk_o: An array of observed wavenumbers.\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nA vector containing the calculated true wavenumbers k for the given input arrays.\n\nDetails\n\nThe function calculates k for pairs or combinations of values from the input arrays k_o and μ_o using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.\n\nFormula\n\nThe underlying transformation for each pair of k_o and μ_o is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o, μ_o, q_perp, F): Method for scalar observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Any, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ from the observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by F.\n\nArguments\n\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true cosine of the angle to the line-of-sight μ (scalar).\n\nFormula\n\nThe formula used is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o::Array, F): Method for an array of observed values.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Array, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o::Array, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ for an array of observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by F.\n\nArguments\n\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nAn array containing the calculated true cosines of the angle to the line-of-sight μ.\n\nDetails\n\nThe function calculates μ for each value in the input array μ_o using a formula derived from anisotropic scaling. Broadcasting (@.) is used to apply the calculation element-wise.\n\nFormula\n\nThe underlying transformation for each μ_o is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o, F): Method for a scalar observed value.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._P_obs","page":"Internal API","title":"Effort._P_obs","text":"_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)\n\nCalculates the observed power spectrum P_textobs(k_o mu_o) at a given observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.\n\nArguments\n\nk_o: The observed wavenumber.\nμ_o: The observed cosine of the angle to the line-of-sight.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nInt_Mono: An interpolation function for the monopole moment I_0(k) in true k.\nInt_Quad: An interpolation function for the quadrupole moment I_2(k) in true k.\nInt_Hexa: An interpolation function for the hexadecapole moment I_4(k) in true k.\n\nReturns\n\nThe value of the observed power spectrum P_textobs(k_o mu_o).\n\nDetails\n\nThe observed coordinates (k_o mu_o) are transformed to true coordinates (k_t mu_t) using the _k_true and _μ_true functions, with F = q_parallel  q_perp. The true power spectrum P(k_t mu_t) is then reconstructed using _Pkμ and the provided multipole interpolants. Finally, the result is scaled by 1  (q_parallel q_perp^2).\n\nFormula\n\nThe formula used is:\n\nP_textobs(k_o mu_o) = frac1q_parallel q_perp^2 P(k_t mu_t)\n\nwhere\n\nk_t = text_k_true(k_o mu_o q_perp F)\n\nmu_t = text_μ_true(mu_o F)\n\nand\n\nF = q_parallel  q_perp\n\nSee Also\n\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Pkμ: Reconstructs the true power spectrum from multipole moments.\ninterp_Pℓs: Creates the multipole interpolants.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.interp_Pℓs","page":"Internal API","title":"Effort.interp_Pℓs","text":"interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)\n\nCreates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.\n\nThese interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers k.\n\nArguments\n\nMono_array: An array containing the values of the monopole moment I_0(k).\nQuad_array: An array containing the values of the quadrupole moment I_2(k).\nHexa_array: An array containing the values of the hexadecapole moment I_4(k).\nk_grid: An array containing the corresponding wavenumber k values for the multipole arrays.\n\nReturns\n\nA tuple containing three interpolation functions: (Int_Mono, Int_Quad, Int_Hexa).\n\nDetails\n\nThe function uses AkimaInterpolation from the Interpolations.jl package to create the interpolants. Extrapolation is set to ExtrapolationType.Extension, which means the interpolant will use the nearest data points to extrapolate outside the provided k_grid range. Note that extrapolation can sometimes introduce errors.\n\nSee Also\n\n_Pkμ: Uses the interpolation functions to reconstruct the anisotropic power spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.q_par_perp","page":"Internal API","title":"Effort.q_par_perp","text":"q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)\n\nCalculates the parallel (q_par) and perpendicular (q_perp) Alcock-Paczynski (AP) parameters at a given redshift z, comparing a varying cosmology to a reference cosmology.\n\nThe AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.\n\nArguments\n\nz: The redshift at which to calculate the AP parameters.\ncosmo_mcmc: An AbstractCosmology struct representing the varying cosmology (e.g., from an MCMC chain).\ncosmo_ref: An AbstractCosmology struct representing the reference cosmology used for measurements.\n\nReturns\n\nA tuple (q_par, q_perp) containing the calculated parallel and perpendicular AP parameters at redshift z.\n\nDetails\n\nThe parallel AP parameter q_par is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter q_perp is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.\n\nFormula\n\nThe formulas for the Alcock-Paczynski parameters are:\n\nq_parallel(z) = fracE_textref(z)E_textmcmc(z)\n\nq_perp(z) = fractilded_Atextmcmc(z)tilded_Atextref(z)\n\nwhere E(z) is the normalized Hubble parameter and tilded_A(z) is the conformal angular diameter distance.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}","page":"Internal API","title":"Effort.apply_AP_check","text":"apply_AP_check(k_input::AbstractVector, k_output::AbstractVector, Mono_array::AbstractVector, Quad_array::AbstractVector, Hexa_array::AbstractVector, q_par, q_perp)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, from vectors of true multipole moments provided on an input wavenumber grid k_input, using numerical integration.\n\nThis is a check version, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle μ.\n\nArguments\n\nk_input: A vector of wavenumber values on which the input true multipole moments (Mono_array, Quad_array, Hexa_array) are defined.\nk_output: A vector of observed wavenumber values at which to calculate the output observed multipoles.\nMono_array: A vector containing the values of the true monopole moment I_0(k) on the k_input grid.\nQuad_array: A vector containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nHexa_array: A vector containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in k_output.\n\nDetails\n\nThis method first creates interpolation functions for the true multipole moments using interp_Pℓs based on the k_input grid. It then calls the core apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp) method, passing k_output as the grid at which to calculate the observed multipoles.\n\nThis function is a slower check implementation and should not be used in performance-critical code.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The observed power spectrum P_textobs(k_o mu_o) is calculated using _P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa).\n\nSee Also\n\napply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp): The core method performing the integration.\ninterp_Pℓs: Creates the interpolation functions for the true multipoles.\n_P_obs: Calculates the observed power spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}","page":"Internal API","title":"Effort.apply_AP","text":"apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp; n_GL_points=8)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, using arrays of true multipole moments provided on an input wavenumber grid k_input, and employing Gauss-Lobatto quadrature.\n\nThis is the standard, faster implementation for applying the Alcock-Paczynski (AP) effect to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.\n\nArguments\n\nk_input: A vector of wavenumber values on which the input true multipole moments (mono, quad, hexa) are defined.\nk_output: A vector of observed wavenumber values at which to calculate the output observed multipoles.\nmono: A vector containing the values of the true monopole moment I_0(k) on the k_input grid.\nquad: A vector containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nhexa: A vector containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nKeyword Arguments\n\nn_GL_points: The number of Gauss-Lobatto points to use for the integration over μ. The actual number of nodes used corresponds to 2 * n_GL_points. Defaults to 8.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in k_output.\n\nDetails\n\nThe function applies the AP and RSD effects by integrating the observed anisotropic power spectrum P_textobs(k_o mu_o) over the observed cosine of the angle to the line-of-sight mu_o in 0 1 (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial mathcalL_ell(mu_o).\n\nThe process involves:\n\nDetermine Gauss-Lobatto nodes and weights for the interval [0, 1].\nFor each observed wavenumber k_o in the input k_output array and each μ_o node: a. Calculate the true wavenumber k_t(k_o mu_o) using _k_true. b. Calculate the true angle cosine mu_t(mu_o) using _μ_true. c. Interpolate the true multipole moments I_ell(k_t) using _akima_interpolation, interpolating from the k_input grid to the new k_t values. d. Calculate the true Legendre polynomials mathcalL_ell(mu_t) using _Legendre_0, _Legendre_2, _Legendre_4. e. Reconstruct the true power spectrum P(k_t mu_t) using _Pk_recon. f. Calculate the observed power spectrum P_textobs(k_o mu_o) = P(k_t mu_t)  (q_parallel q_perp^2).\nPerform the weighted sum (quadrature) over the μ_o nodes to get the observed multipoles P_ell(k_o) on the k_output grid.\n\nThis function is the standard, performant implementation for applying AP compared to the slower apply_AP_check.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The integral is approximated using Gauss-Lobatto quadrature.\n\nSee Also\n\napply_AP_check: The slower, check version using generic numerical integration.\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n_akima_interpolation: Interpolates the true multipole moments.\n_Pk_recon: Reconstructs the true power spectrum on a grid.\ngausslobatto: Function used to get quadrature nodes and weights.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix, Any, Any}","page":"Internal API","title":"Effort.apply_AP","text":"apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractMatrix, quad::AbstractMatrix, hexa::AbstractMatrix, q_par, q_perp; n_GL_points=8)\n\nBatch version of apply_AP for processing multiple columns simultaneously using optimized matrix Akima interpolation.\n\nThis method applies the Alcock-Paczynski effect to multiple sets of multipole moments (e.g., multiple Jacobian columns or parameter variations) in a single call. It leverages the optimized matrix Akima spline implementation to interpolate all columns at once, providing significant performance improvements over column-by-column processing.\n\nArguments\n\nk_input::AbstractVector: Input wavenumber grid.\nk_output::AbstractVector: Output wavenumber grid.\nmono::AbstractMatrix: Monopole moments with shape (n_k, n_cols).\nquad::AbstractMatrix: Quadrupole moments with shape (n_k, n_cols).\nhexa::AbstractMatrix: Hexadecapole moments with shape (n_k, n_cols).\nq_par: Parallel AP parameter.\nq_perp: Perpendicular AP parameter.\n\nKeyword Arguments\n\nn_GL_points::Int: Number of Gauss-Lobatto points. Default: 8.\n\nReturns\n\nA tuple (mono_AP, quad_AP, hexa_AP) where each is a matrix of shape (n_k_output, n_cols) containing the AP-corrected multipoles for all input columns.\n\nDetails\n\nThis optimized implementation uses matrix Akima interpolation to process all columns simultaneously rather than iterating column-by-column. For N columns, this reduces 3×N Akima calls to just 3 matrix Akima calls, providing a ~2-3× speedup.\n\nThis is particularly useful for computing Jacobians where each column represents the derivative with respect to a different parameter (typically 11 bias parameters).\n\nPerformance\n\nFor typical DESI-like scenarios (50 input k-points, 100 output k-points, 11 columns):\n\nOld implementation: ~6 ms (33 scalar Akima calls)\nNew implementation: ~2 ms (3 matrix Akima calls)\nSpeedup: ~2.5-3×\n\nSee Also\n\napply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp): Single-column version.\n_akima_interpolation(u::AbstractMatrix, t, t_new): Optimized matrix Akima interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._Pk_recon","page":"Internal API","title":"Effort._Pk_recon","text":"_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)\n\nReconstructs the anisotropic power spectrum P(k mu) on a grid of wavenumbers k and cosines of the angle to the line-of-sight μ, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.\n\nThis function is designed to efficiently reconstruct the 2D power spectrum for multiple k and μ values simultaneously, assuming the multipole moments are provided as matrices (e.g., N_k x 1) and Legendre polynomials as vectors (e.g., N_μ).\n\nArguments\n\nmono: A matrix containing the monopole moment I_0(k) values (expected dimensions N_k x 1).\nquad: A matrix containing the quadrupole moment I_2(k) values (expected dimensions N_k x 1).\nhexa: A matrix containing the hexadecapole moment I_4(k) values (expected dimensions N_k x 1).\nl0: A vector containing the 0th order Legendre polynomial mathcalL_0(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl2: A vector containing the 2nd order Legendre polynomial mathcalL_2(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl4: A vector containing the 4th order Legendre polynomial mathcalL_4(mu) values evaluated at the desired μ values (expected dimensions N_μ).\n\nReturns\n\nA matrix representing the anisotropic power spectrum P(k mu) on the N_k x N_μ grid.\n\nDetails\n\nThe function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input k (from the rows of the moment matrices) and μ (from the elements of the Legendre polynomial vectors).\n\nFormula\n\nThe formula used for each element (i j) of the output matrix (corresponding to the i-th wavenumber and j-th angle cosine) is:\n\nP(k_i mu_j) = I_0(k_i) mathcalL_0(mu_j) + I_2(k_i) mathcalL_2(mu_j) + I_4(k_i) mathcalL_4(mu_j)\n\nSee Also\n\n_Pkμ: Reconstructs P(k mu) for single k and μ.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.window_convolution","page":"Internal API","title":"Effort.window_convolution","text":"window_convolution(W::Array{T, 4}, v::Matrix) where {T}\n\nApplies a 4-dimensional window function or kernel W to a 2-dimensional input matrix v.\n\nThis operation performs a transformation or generalized convolution, summing over the j and l indices of the inputs to produce a 2D result indexed by i and k. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.\n\nArguments\n\nW: A 4-dimensional array representing the window function or kernel.\nv: A 2-dimensional matrix representing the input data.\n\nReturns\n\nA 2-dimensional matrix representing the result of the convolution or transformation.\n\nDetails\n\nThe function implements the summation using the @tullio macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.\n\nFormula\n\nThe operation is defined as:\n\nC_ik = sum_jl W_ijkl v_jl\n\nSee Also\n\nwindow_convolution(W::AbstractMatrix, v::AbstractVector): Method for a matrix kernel and vector input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\nwindow_convolution(W::AbstractMatrix, v::AbstractVector)\n\nPerforms matrix-vector multiplication, where the matrix W acts as a linear transformation or window applied to the vector input v.\n\nArguments\n\nW: An abstract matrix representing the linear transformation or window.\nv: An abstract vector representing the input data.\n\nReturns\n\nAn abstract vector representing the result of the matrix-vector multiplication.\n\nDetails\n\nThis method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix W to the vector v.\n\nFormula\n\nThe operation is defined as:\n\nmathbfc = mathbfW mathbfv\n\nor element-wise:\n\nc_i = sum_j W_ij v_j\n\nSee Also\n\nwindow_convolution(W::Array{T, 4}, v::Matrix) where {T}: Method for a 4D kernel and matrix input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Utils","page":"Internal API","title":"Utils","text":"","category":"section"},{"location":"api_internal/#Effort._transformed_weights","page":"Internal API","title":"Effort._transformed_weights","text":"_transformed_weights(quadrature_rule, order, a, b)\n\nTransforms the points and weights of a standard quadrature rule from the interval [-1, 1] to a specified interval [a, b].\n\nThis is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals [a, b].\n\nArguments\n\nquadrature_rule: A function that takes an order and returns a tuple (points, weights)                    for the standard interval [-1, 1].\norder: The order of the quadrature rule (number of points).\na: The lower bound of the target interval.\nb: The upper bound of the target interval.\n\nReturns\n\nA tuple (transformed_points, transformed_weights) for the interval [a, b].\n\nDetails\n\nThe transformation is applied to the standard points x_i^textstd and weights w_i^textstd obtained from the quadrature_rule:\n\nTransformed points: x_i = fracb - a2 x_i^textstd + fracb + a2\nTransformed weights: w_i = fracb - a2 w_i^textstd\n\nFormula\n\nThe transformation formulas are: Points: x_i = fracb - a2 x_i^textstd + fracb + a2 Weights: w_i = fracb - a2 w_i^textstd\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_0","page":"Internal API","title":"Effort._Legendre_0","text":"_Legendre_0(x)\n\nCalculates the 0th order Legendre polynomial, mathcalL_0(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 0th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 0th order Legendre polynomial is:\n\nmathcalL_0(x) = 1\n\nSee Also\n\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_2","page":"Internal API","title":"Effort._Legendre_2","text":"_Legendre_2(x)\n\nCalculates the 2nd order Legendre polynomial, mathcalL_2(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 2nd order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 2nd order Legendre polynomial is:\n\nmathcalL_2(x) = frac12 (3x^2 - 1)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_4","page":"Internal API","title":"Effort._Legendre_4","text":"_Legendre_4(x)\n\nCalculates the 4th order Legendre polynomial, mathcalL_4(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 4th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 4th order Legendre polynomial is:\n\nmathcalL_4(x) = frac18 (35x^4 - 30x^2 + 3)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._akima_interpolation-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._akima_interpolation","text":"_akima_interpolation(u, t, t_new)\n\nEvaluates the one-dimensional Akima spline that interpolates the data points (t_i u_i) at new abscissae t_new.\n\nArguments\n\nu: Ordinates (function values) u_i at the data nodes.\nt: Strictly increasing abscissae (knots) t_i associated with u. length(t) must equal length(u).\nt_new: The query point(s) where the spline is to be evaluated.\n\nReturns\n\nThe interpolated value(s) at t_new. A scalar input returns a scalar; a vector input returns a vector of the same length.\n\nDetails\n\nThis routine implements the original Akima piecewise-cubic method (T. Akima, 1970). On each interval t_j t_j+1, a cubic polynomial is constructed. The method uses a weighted average of slopes to determine the derivative at each node, which effectively dampens oscillations without explicit shape constraints. The resulting spline is C^1 continuous (its first derivative is continuous) but generally not C^2.\n\nFormulae\n\nThe spline on the interval t_j t_j+1 is a cubic polynomial: [ Sj(w) = uj + bj w + cj w^{2} + dj w^{3}, \\qquad w = t - tj ] The derivative b_j at each node is determined by Akima's weighting of local slopes m_j=(u_j-u_j-1)(t_j-t_j-1): [ bj = \\frac{|m{j+1}-m{j}|\\,m{j-1} + |m{j-1}-m{j-2}|\\,m{j}}             {|m{j+1}-m{j}| + |m{j-1}-m{j-2}|} ] The remaining coefficients, ``cjanddj``, are found by enforcing continuity of the first derivative: [ cj = \\frac{3mj - 2bj - b{j+1}}{t{j+1}-tj} ] [ dj = \\frac{bj + b{j+1} - 2mj}{(t{j+1}-t_j)^2} ]\n\nAutomatic Differentiation\n\nThe implementation is free of mutation on the inputs and uses only element-wise arithmetic, making the returned value differentiable with both ForwardDiff.jl (dual numbers) and Zygote.jl (reverse-mode AD). You can therefore embed _akima_interpolation in optimization or machine-learning pipelines and back-propagate through the interpolation seamlessly.\n\nNotes\n\nThe algorithm and numerical results are equivalent to the Akima spline in DataInterpolations.jl, but this routine is self-contained and avoids any package dependency.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}","page":"Internal API","title":"Effort._akima_interpolation","text":"_akima_interpolation(u::AbstractMatrix, t, t_new)\n\nAkima spline interpolation for multiple data series sharing the same x-coordinates. Uses a simple comprehension-based approach that is compatible with automatic differentiation.\n\nArguments\n\nu::AbstractMatrix: Data values with shape (n_points, n_columns).\nt: X-coordinates shared by all columns.\nt_new: Query points.\n\nReturns\n\nMatrix of interpolated values with shape (length(t_new), n_columns).\n\nExample\n\n# Interpolate 11 Jacobian columns at 100 k-points\nk_in = range(0.01, 0.3, length=50)\nk_out = range(0.01, 0.3, length=100)\njacobian = randn(50, 11)  # 11 parameters\n\nresult = _akima_interpolation(jacobian, k_in, k_out)  # (100, 11)\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._akima_slopes-Tuple{AbstractMatrix, Any}","page":"Internal API","title":"Effort._akima_slopes","text":"_akima_slopes(u::AbstractMatrix, t)\n\nOptimized version of _akima_slopes for matrix input where each column represents a different data series but all share the same x-coordinates t.\n\nPerformance Optimization\n\nComputes dt = diff(t) once and reuses it for all columns, avoiding redundant computation.\n\nArguments\n\nu::AbstractMatrix: Data values with shape (n_points, n_columns).\nt: X-coordinates (same for all columns).\n\nReturns\n\nMatrix of slopes with shape (n_points + 3, n_columns).\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._akima_coefficients-Tuple{Any, AbstractMatrix}","page":"Internal API","title":"Effort._akima_coefficients","text":"_akima_coefficients(t, m::AbstractMatrix)\n\nOptimized version of _akima_coefficients for matrix input where each column represents coefficients for a different spline series.\n\nPerformance Optimization\n\nComputes dt = diff(t) once and reuses it for all columns.\n\nArguments\n\nt: X-coordinates.\nm::AbstractMatrix: Slopes matrix with shape (n_points + 3, n_columns).\n\nReturns\n\nTuple (b, c, d) where:\n\nb is a matrix of shape (n_points, n_columns)\nc and d are matrices of shape (n_points - 1, n_columns)\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._akima_eval-Tuple{AbstractMatrix, Any, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractArray}","page":"Internal API","title":"Effort._akima_eval","text":"_akima_eval(u::AbstractMatrix, t, b::AbstractMatrix, c::AbstractMatrix, d::AbstractMatrix, tq::AbstractArray)\n\nOptimized version of _akima_eval for matrix input where each column represents a different spline series.\n\nPerformance Optimization\n\nFinds intervals once per query point (not per column)\nComputes polynomial weights once per query point\nBroadcasts evaluation across all columns simultaneously\n\nThis is significantly faster than calling the vector version in a loop.\n\nArguments\n\nu::AbstractMatrix: Data values with shape (n_points, n_columns).\nt: X-coordinates.\nb::AbstractMatrix, c::AbstractMatrix, d::AbstractMatrix: Spline coefficients.\ntq::AbstractArray: Query points.\n\nReturns\n\nMatrix of interpolated values with shape (length(tq), n_columns).\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort.load_component_emulator","page":"Internal API","title":"Effort.load_component_emulator","text":"load_component_emulator(path::String; emu=LuxEmulator, k_file=\"k.npy\", weights_file=\"weights.npy\", inminmax_file=\"inminmax.npy\", outminmax_file=\"outminmax.npy\", nn_setup_file=\"nn_setup.json\", postprocessing_file=\"postprocessing_file.jl\")\n\nLoad a trained component emulator from disk.\n\nArguments\n\npath::String: Directory path containing the emulator files.\n\nKeyword Arguments\n\nemu: Emulator type to initialize (LuxEmulator or SimpleChainsEmulator). Default: LuxEmulator.\nk_file::String: Filename for the wavenumber grid. Default: \"k.npy\".\nweights_file::String: Filename for neural network weights. Default: \"weights.npy\".\ninminmax_file::String: Filename for input normalization parameters. Default: \"inminmax.npy\".\noutminmax_file::String: Filename for output normalization parameters. Default: \"outminmax.npy\".\nnn_setup_file::String: Filename for network architecture configuration. Default: \"nn_setup.json\".\npostprocessing_file::String: Filename for postprocessing function. Default: \"postprocessing_file.jl\".\n\nReturns\n\nA ComponentEmulator instance ready for evaluation.\n\nDetails\n\nThis function loads all necessary files to reconstruct a trained component emulator:\n\nNeural network architecture from JSON configuration.\nTrained weights from NumPy binary format.\nNormalization parameters for inputs and outputs.\nWavenumber grid.\nPostprocessing function dynamically loaded from Julia file.\n\nThe postprocessing function is evaluated in an isolated scope to prevent namespace pollution.\n\nExample\n\nP11_emu = load_component_emulator(\"/path/to/emulator/11/\")\n\nFile Structure\n\nThe expected directory structure is:\n\npath/\n├── k.npy                    # Wavenumber grid\n├── weights.npy              # Neural network weights\n├── inminmax.npy            # Input normalization (n_params × 2)\n├── outminmax.npy           # Output normalization (n_k × 2)\n├── nn_setup.json           # Network architecture\n└── postprocessing_file.jl  # Postprocessing function\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.load_multipole_emulator","page":"Internal API","title":"Effort.load_multipole_emulator","text":"load_multipole_emulator(path; emu=LuxEmulator, k_file=\"k.npy\", weights_file=\"weights.npy\", inminmax_file=\"inminmax.npy\", outminmax_file=\"outminmax.npy\", nn_setup_file=\"nn_setup.json\", postprocessing_file=\"postprocessing.jl\", stochmodel_file=\"stochmodel.jl\", biascombination_file=\"biascombination.jl\", jacbiascombination_file=\"jacbiascombination.jl\")\n\nLoad a complete power spectrum multipole emulator from disk.\n\nArguments\n\npath: Directory path containing the multipole emulator structure.\n\nKeyword Arguments\n\nemu: Emulator type to initialize (LuxEmulator or SimpleChainsEmulator). Default: LuxEmulator.\nk_file::String: Filename for the wavenumber grid. Default: \"k.npy\".\nweights_file::String: Filename for neural network weights. Default: \"weights.npy\".\ninminmax_file::String: Filename for input normalization parameters. Default: \"inminmax.npy\".\noutminmax_file::String: Filename for output normalization parameters. Default: \"outminmax.npy\".\nnn_setup_file::String: Filename for network architecture configuration. Default: \"nn_setup.json\".\npostprocessing_file::String: Filename for postprocessing function. Default: \"postprocessing.jl\".\nstochmodel_file::String: Filename for stochastic model function. Default: \"stochmodel.jl\".\nbiascombination_file::String: Filename for bias combination function. Default: \"biascombination.jl\".\njacbiascombination_file::String: Filename for bias Jacobian function. Default: \"jacbiascombination.jl\".\n\nReturns\n\nA PℓEmulator instance containing all three components (P11, Ploop, Pct) and bias models.\n\nDetails\n\nThis function loads a complete multipole emulator by:\n\nLoading three component emulators (P11, Ploop, Pct) from subdirectories.\nLoading the stochastic model function (shot noise terms).\nLoading the bias combination function (maps bias parameters to weights).\nLoading the analytical Jacobian of the bias combination.\n\nAll functions are evaluated in isolated scopes to prevent namespace conflicts between different emulator components.\n\nExample\n\n# Load monopole emulator\nmonopole_emu = load_multipole_emulator(\"/path/to/artifact/0/\")\n\n# Evaluate\ncosmology = [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]\nbias = [b1, b2, b3, b4, b5, b6, b7, f, cϵ0, cϵ1, cϵ2]\nD = 0.8\nP0 = get_Pℓ(cosmology, D, bias, monopole_emu)\n\nFile Structure\n\nThe expected directory structure is:\n\npath/\n├── 11/                       # P11 component\n│   ├── k.npy\n│   ├── weights.npy\n│   ├── inminmax.npy\n│   ├── outminmax.npy\n│   ├── nn_setup.json\n│   └── postprocessing.jl\n├── loop/                     # Ploop component\n│   └── ... (same structure)\n├── ct/                       # Pct component\n│   └── ... (same structure)\n├── stochmodel.jl            # Stochastic model function\n├── biascombination.jl       # Bias combination function\n└── jacbiascombination.jl    # Bias Jacobian function\n\nSee Also\n\nload_component_emulator: Load individual component emulators.\nget_Pℓ: Evaluate the loaded emulator.\n\n\n\n\n\n","category":"function"},{"location":"assets/plots/README/#Documentation-Plots","page":"Documentation Plots","title":"Documentation Plots","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"This directory contains static plots for the Effort.jl documentation.","category":"page"},{"location":"assets/plots/README/#Generating-Plots","page":"Documentation Plots","title":"Generating Plots","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"To regenerate all plots, run:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"julia --project=docs docs/generate_plots.jl","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"This will create/update the following files in this directory:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"multipoles_no_ap.png - Power spectrum multipoles (monopole, quadrupole, hexadecapole)\nap_effect_comparison.png - Before/after Alcock-Paczynski corrections\nap_relative_difference.png - Relative impact of AP effect","category":"page"},{"location":"assets/plots/README/#Plot-Specifications","page":"Documentation Plots","title":"Plot Specifications","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"All plots use:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Resolution: 300 DPI (publication quality)\nSize: 800×500 pixels\nFont: Computer Modern (LaTeX style)\nFormat: PNG with transparency","category":"page"},{"location":"assets/plots/README/#Uploading-to-Cloud-Storage","page":"Documentation Plots","title":"Uploading to Cloud Storage","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"For CI/CD efficiency, these plots should be uploaded to cloud storage and referenced by URL in the documentation. Recommended options:","category":"page"},{"location":"assets/plots/README/#Option-1:-GitHub-Release-Assets","page":"Documentation Plots","title":"Option 1: GitHub Release Assets","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Create a new release or use an existing one\nUpload the PNG files as release assets\nGet permanent URLs like:\nhttps://github.com/CosmologicalEmulators/Effort.jl/releases/download/v0.4.1/multipoles_no_ap.png","category":"page"},{"location":"assets/plots/README/#Option-2:-Zenodo","page":"Documentation Plots","title":"Option 2: Zenodo","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Create a Zenodo record (same as the trained emulators)\nUpload PNG files\nGet DOI-backed permanent URLs","category":"page"},{"location":"assets/plots/README/#Option-3:-Repository-Assets-(Current-Setup)","page":"Documentation Plots","title":"Option 3: Repository Assets (Current Setup)","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Keep plots in docs/src/assets/plots/ and reference them relatively:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"![Description](assets/plots/filename.png)","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Note: This is the current setup. Plots are version-controlled in the repository.","category":"page"},{"location":"assets/plots/README/#Updating-Documentation","page":"Documentation Plots","title":"Updating Documentation","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"If you change the plot generation script or cosmology parameters:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Regenerate plots: julia --project=docs docs/generate_plots.jl\nCommit the updated PNG files\nIf using cloud storage, upload new versions and update URLs in docs/src/example.md","category":"page"},{"location":"assets/plots/README/#Cosmology-Parameters-Used","page":"Documentation Plots","title":"Cosmology Parameters Used","text":"","category":"section"},{"location":"assets/plots/README/#Fiducial-Cosmology","page":"Documentation Plots","title":"Fiducial Cosmology","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"ln10^10 A_s = 3.044\nn_s = 0.9649\nh = 0.6736\nω_b = 0.02237\nω_c = 0.12\nΣm_ν = 0.06 eV\nw_0 = -1.0\nw_a = 0.0\nω_k = 0.0","category":"page"},{"location":"assets/plots/README/#Reference-Cosmology-(for-AP-effect)","page":"Documentation Plots","title":"Reference Cosmology (for AP effect)","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"ln10^10 A_s = 3.0\nn_s = 0.96\nh = 0.70 ⭐ different\nω_b = 0.022\nω_c = 0.115 ⭐ different\nΣm_ν = 0.06 eV\nw_0 = -0.95 ⭐ different (non-ΛCDM)\nw_a = 0.0\nω_k = 0.0","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Resulting AP parameters: q∥ ≈ 0.98, q⊥ ≈ 0.99 (visible effect!)","category":"page"},{"location":"assets/plots/README/#File-Sizes","page":"Documentation Plots","title":"File Sizes","text":"","category":"section"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Typical sizes:","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"multipoles_no_ap.png: ~180 KB\nap_effect_comparison.png: ~200 KB\nap_relative_difference.png: ~140 KB","category":"page"},{"location":"assets/plots/README/","page":"Documentation Plots","title":"Documentation Plots","text":"Total: ~520 KB for all plots","category":"page"},{"location":"#Effort.jl","page":"Home","title":"Effort.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is a Julia package designed to emulate the computation of the Effective Field Theory of Large Scale Structure, as computed by PyBird. An emulator is a surrogate model, a computational technique that can mimick the behaviour of computationally expensive functions, with a speedup of several orders of magnitude.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example page shows how to use Effort, while showing its computational performance.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marco Bonici, PostDoctoral Researcher at Waterloo Centre for Astrophysics\nGuido D'Amico, Associate Professor at Università Degli Studi di Parma","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Free usage of the software in this repository is provided, given that you cite our release paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Bonici, G. D'Amico, J. Bel, C. Carbone, Effort.jl: a fast and differentiable emulator for the Effective Field Theory of the Large Scale Structure of the Universe","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code has been used in the following publications:","category":"page"},{"location":"","page":"Home","title":"Home","text":"H. Zhang, M. Bonici, A. Rocher, W. J. Percival, A. de Mattia, et al., Enhancing DESI DR1 Full-Shape analyses using HOD-informed priors\nH. Zhang, M. Bonici, G. D'Amico, S. Paradiso, W. J. Percival, HOD-informed prior for EFT-based full-shape analyses of LSS\nS. Paradiso, M. Bonici, M. Chen, W. J. Percival, G. D'Amico, H. Zhang, G. McGee, Reducing nuisance prior sensitivity via non-linear reparameterization, with application to EFT analyses of large-scale structure\nA. Baleato Lizancos, U. Seljak, M. Karamanis, M. Bonici, S. Ferraro, Selecting samples of galaxies with fewer Fingers-of-God","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"},{"location":"example/#Example-Usage","page":"Example","title":"Example Usage","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This page demonstrates how to use Effort.jl to efficiently compute power spectrum multipoles for the Effective Field Theory of Large Scale Structure (EFTofLSS).","category":"page"},{"location":"example/#Overview","page":"Example","title":"Overview","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Effort.jl provides a complete, differentiable pipeline for computing galaxy power spectrum multipoles:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Define cosmology - Set cosmological parameters\nCompute growth factors - Solve ODEs for D(z) and f(z)\nPredict multipoles - Use pre-trained neural network emulators\nApply AP corrections - Account for Alcock-Paczynski effects (optional)\nWindow convolution - Apply survey window functions (optional)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The package ships with pre-trained emulators for the PyBird code, trained on the mnuw0wacdm cosmology (9 parameters: redshift z, ln(10^10A_mathrms), n_mathrms, H_0, omega_b, omega_mathrmcdm, Sigma m_nu, w_0, w_a).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-1:-Load-Pre-trained-Emulators","page":"Example","title":"Step 1: Load Pre-trained Emulators","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Effort.jl automatically loads pre-trained emulators during package initialization. The emulators are stored in the trained_emulators dictionary:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Effort\n\n# Access the monopole (ℓ=0), quadrupole (ℓ=2), and hexadecapole (ℓ=4) emulators\nmonopole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"0\"]\nquadrupole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"2\"]\nhexadecapole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"4\"]\n\nprintln(\"Available emulators: \", keys(Effort.trained_emulators))\nprintln(\"Monopole emulator loaded successfully!\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Each multipole emulator contains three component emulators (P11, Ploop, Pct) plus bias combination functions. Let's inspect the k-grid:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"k_grid = vec(monopole_emu.P11.kgrid)\nprintln(\"k-grid range: [$(minimum(k_grid)), $(maximum(k_grid))] h/Mpc\")\nprintln(\"Number of k-points: $(length(k_grid))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-2:-Define-Cosmology","page":"Example","title":"Step 2: Define Cosmology","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Create a cosmology object using the w0waCDMCosmology type. This includes standard ΛCDM parameters plus extensions for massive neutrinos, dark energy equation of state, and spatial curvature:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Fiducial Planck-like cosmology (flat universe)\ncosmology = Effort.w0waCDMCosmology(\n    ln10Aₛ = 3.044,     # Log primordial amplitude: ln(10^10 A_s)\n    nₛ = 0.9649,        # Spectral index\n    h = 0.6736,         # Reduced Hubble constant: H0 = 100h km/s/Mpc\n    ωb = 0.02237,       # Physical baryon density: Ωb h²\n    ωc = 0.12,          # Physical cold dark matter density: Ωcdm h²\n    mν = 0.06,          # Sum of neutrino masses [eV]\n    w0 = -1.0,          # Dark energy EOS at z=0\n    wa = 0.0,           # Dark energy EOS evolution parameter\n    ωk = 0.0            # Physical curvature density: Ωk h² (default: 0.0 for flat)\n)\n\n# Reference cosmology for AP corrections (intentionally different to show AP effect)\ncosmo_ref = Effort.w0waCDMCosmology(\n    ln10Aₛ = 3.0, nₛ = 0.96, h = 0.70,      # Different h\n    ωb = 0.022, ωc = 0.115, mν = 0.06,      # Different ωc\n    w0 = -0.95, wa = 0.0, ωk = 0.0          # Different w0 (non-ΛCDM)\n)\n\nprintln(\"Cosmology defined successfully!\")\nprintln(\"  Flat universe: ωk = $(cosmology.ωk)\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Non-flat Universes\nThe w0waCDMCosmology type supports non-flat universes through the ωk parameter:ωk = 0.0: Flat universe (Ωk = 0) - default\nωk > 0.0: Open universe (Ωk > 0, negative spatial curvature)\nωk < 0.0: Closed universe (Ωk < 0, positive spatial curvature)The curvature affects the Hubble parameter E(z) and all distance measures (dA, dL, etc.).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-3:-Compute-Growth-Factor-and-Growth-Rate","page":"Example","title":"Step 3: Compute Growth Factor and Growth Rate","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The growth factor D(z) and growth rate f(z) are computed by solving the differential equation:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(a) + left(2 + fracE(a)E(a)right)D(a) = frac32Omega_m(a)D(a)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where E(a) is the normalized Hubble parameter including radiation, matter, massive neutrinos, and dark energy.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Redshift of interest\nz = 0.8\n\n# Compute growth factor and growth rate simultaneously\nD, f = Effort.D_f_z(z, cosmology)\n\nprintln(\"At redshift z = $z:\")\nprintln(\"  Growth factor D(z) = $D\")\nprintln(\"  Growth rate f(z) = $f\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This computation is extremely fast (both D and f computed together in a single ODE solve) and includes full support for automatic differentiation:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"D_f_z\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The ODE solver accurately accounts for all cosmological components:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"✓ Photon radiation (Ω_γ) - computed from CMB temperature\n✓ Cold dark matter + baryons (Ω_cb) - from ωb and ωc\n✓ Massive neutrinos (Ω_ν) - includes accurate phase-space integrals for energy density\n✓ Evolving dark energy - w(z) = w0 + wa(1-a) parametrization\n✓ Spatial curvature (Ω_k) - supports open, closed, and flat universes via ωk parameter","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-4:-Define-Bias-Parameters","page":"Example","title":"Step 4: Define Bias Parameters","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"With \"bias parameters\" we loosely refer to biases, counterterms, and stochastic contributions. The galaxy power spectrum depends on 11 such parameters in the EFTofLSS framework:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Bias parameters: [b1, b2, b3, b4, cct, cr1, cr2, f, ce0, cemono, cequad]\nbias_params = [\n    2.0,    # b1\n    -0.5,   # b2\n    0.3,    # b3\n    0.5,    # b4\n    0.5,    # cct\n    0.5,    # cr1\n    0.5,    # cr2\n    f,      # f\n    1.0,    # ce0\n    1.0,    # cemono\n    1.0     # cequad\n]\n\nprintln(\"Bias parameters defined (including f = $f)\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-5:-Predict-Power-Spectrum-Multipoles","page":"Example","title":"Step 5: Predict Power Spectrum Multipoles","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Now we can predict the power spectrum multipoles using the emulators. The emulator expects input in the format: [z, ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Build emulator input array\nemulator_input = [\n    z,\n    cosmology.ln10Aₛ,\n    cosmology.nₛ,\n    cosmology.h * 100,  # Convert h to H0\n    cosmology.ωb,\n    cosmology.ωc,\n    cosmology.mν,\n    cosmology.w0,\n    cosmology.wa\n]\n\n# Predict monopole, quadrupole, and hexadecapole\nP0 = Effort.get_Pℓ(emulator_input, D, bias_params, monopole_emu)\nP2 = Effort.get_Pℓ(emulator_input, D, bias_params, quadrupole_emu)\nP4 = Effort.get_Pℓ(emulator_input, D, bias_params, hexadecapole_emu)\n\nprintln(\"Multipoles computed successfully!\")\nprintln(\"  Monopole P0: $(length(P0)) k-points\")\nprintln(\"  Quadrupole P2: $(length(P2)) k-points\")\nprintln(\"  Hexadecapole P4: $(length(P4)) k-points\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Let's visualize the results:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"<img width=\"800\" alt=\"Power Spectrum Multipoles\" src=\"https://github.com/user-attachments/assets/55d84c98-65ca-429f-b782-52c5da5d6200\" />","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Figure 1: Power spectrum multipoles at z = 0.8. The monopole (ℓ=0) dominates, with subdominant contributions from the quadrupole (ℓ=2) and hexadecapole (ℓ=4).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This computation is extremely fast - evaluating a single multipole takes only ~28 μs:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"monopole\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Step-6:-Apply-Alcock-Paczynski-(AP)-Corrections","page":"Example","title":"Step 6: Apply Alcock-Paczynski (AP) Corrections","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"When the assumed reference cosmology differs from the true cosmology, observations are distorted by the Alcock-Paczynski effect. The observed power spectrum is related to the true power spectrum by:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"P_mathrmobs(k_mathrmobs mu_mathrmobs) = frac1q_parallel q_perp^2 cdot P_g(k_texttrue mu_texttrue)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the distortion parameters are:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"q_parallel = fracE_mathrmref(z)E_mathrmtrue(z) quad q_perp = fracd_Amathrmtrue(z)d_Amathrmref(z)","category":"page"},{"location":"example/#Compute-AP-parameters","page":"Example","title":"Compute AP parameters","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"# Compute q_parallel and q_perpendicular\nq_par, q_perp = Effort.q_par_perp(z, cosmology, cosmo_ref)\n\nprintln(\"Alcock-Paczynski parameters:\")\nprintln(\"  q_∥ (parallel) = $q_par\")\nprintln(\"  q_⊥ (perpendicular) = $q_perp\")\nnothing # hide","category":"page"},{"location":"example/#Apply-AP-effect-using-fast-Gauss-Lobatto-quadrature","page":"Example","title":"Apply AP effect using fast Gauss-Lobatto quadrature","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Effort.jl implements two methods for applying the AP effect:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"apply_AP - Fast Gauss-Lobatto quadrature (recommended)\napply_AP_check - Adaptive QuadGK integration (for validation)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The Gauss-Lobatto method is ~200× faster with negligible accuracy loss (<10⁻¹¹% difference):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Apply AP corrections to all three multipoles\nP0_AP, P2_AP, P4_AP = Effort.apply_AP(\n    k_grid,          # Input k-grid\n    k_grid,          # Output k-grid (can be different)\n    P0, P2, P4,      # Input multipoles\n    q_par, q_perp,   # AP parameters\n    n_GL_points=8    # Number of Gauss-Lobatto points (default: 8)\n)\n\nprintln(\"AP corrections applied successfully!\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Compare before and after AP corrections:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"<img width=\"800\" alt=\"AP Effect Comparison\" src=\"https://github.com/user-attachments/assets/9840dde2-1387-40c6-a4f8-f18abca1c3a4\" />","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Figure 2: Effect of Alcock-Paczynski corrections on the monopole and quadrupole. The reference cosmology has h = 0.70 (vs. 0.6736), ωc = 0.115 (vs. 0.12), and w0 = -0.95 (vs. -1.0), producing distortion parameters q∥ ≈ 0.98 and q⊥ ≈ 0.99. The AP effect is most pronounced at low k.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For a clearer view of the AP effect magnitude:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"<img width=\"800\" alt=\"AP Relative Difference\" src=\"https://github.com/user-attachments/assets/34d3cf9b-0585-491f-b621-17ac8ce6e885\" />","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Figure 3: Relative difference between AP-corrected and uncorrected multipoles. The AP effect can cause percent-level shifts in the power spectrum, particularly important for precision cosmology.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance benchmark:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"apply_AP\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The AP correction for all three multipoles adds only ~32 μs to the computation!","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Complete-Pipeline:-From-Cosmology-to-Observables","page":"Example","title":"Complete Pipeline: From Cosmology to Observables","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Let's put everything together in a single function that goes from cosmological parameters to AP-corrected multipoles:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function compute_multipoles(cosmology, z, bias_params, cosmo_ref=cosmology)\n    # Step 1: Compute growth factors simultaneously\n    D, f = Effort.D_f_z(z, cosmology)\n\n    # Step 2: Update bias parameters with computed f\n    bias_with_f = copy(bias_params)\n    bias_with_f[8] = f  # 8th parameter is the growth rate\n\n    # Step 3: Build emulator input\n    emulator_input = [\n        z, cosmology.ln10Aₛ, cosmology.nₛ, cosmology.h * 100,\n        cosmology.ωb, cosmology.ωc, cosmology.mν, cosmology.w0, cosmology.wa\n    ]\n\n    # Step 4: Predict multipoles\n    monopole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"0\"]\n    quadrupole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"2\"]\n    hexadecapole_emu = Effort.trained_emulators[\"PyBirdmnuw0wacdm\"][\"4\"]\n\n    P0 = Effort.get_Pℓ(emulator_input, D, bias_with_f, monopole_emu)\n    P2 = Effort.get_Pℓ(emulator_input, D, bias_with_f, quadrupole_emu)\n    P4 = Effort.get_Pℓ(emulator_input, D, bias_with_f, hexadecapole_emu)\n\n    # Step 5: Apply AP corrections if reference cosmology differs\n    if cosmology !== cosmo_ref\n        q_par, q_perp = Effort.q_par_perp(z, cosmology, cosmo_ref)\n        k_grid = vec(monopole_emu.P11.kgrid)\n        P0, P2, P4 = Effort.apply_AP(k_grid, k_grid, P0, P2, P4, q_par, q_perp)\n    end\n\n    return P0, P2, P4\nend\n\n# Test the complete pipeline\nP0_full, P2_full, P4_full = compute_multipoles(cosmology, z, bias_params, cosmo_ref)\n\nprintln(\"Complete pipeline executed successfully!\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance: Let's benchmark the complete end-to-end pipeline with AP corrections:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"complete_pipeline\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This is the actual measured performance of the complete function, including all overhead. The total time (~308 μs) includes:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Growth factors D(z) & f(z): ~169 μs\nMultipole emulation (×3): ~75 μs total\nAP corrections: ~32 μs\nFunction call overhead and array operations: ~32 μs","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Less than 0.31 milliseconds for the complete pipeline from cosmological parameters to AP-corrected observables! This is orders of magnitude faster than traditional Boltzmann codes like CLASS or CAMB combined with PyBird.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Differentiation-and-Jacobians:-Two-Use-Cases","page":"Example","title":"Differentiation and Jacobians: Two Use Cases","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Effort.jl provides two complementary approaches for computing derivatives, optimized for different scenarios in cosmological parameter inference.","category":"page"},{"location":"example/#Use-Case-1:-Automatic-Differentiation-for-Gradient-Based-Inference","page":"Example","title":"Use Case 1: Automatic Differentiation for Gradient-Based Inference","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"When performing MCMC or maximum likelihood estimation with gradient-based algorithms (e.g., Hamiltonian Monte Carlo, variational inference), you can use automatic differentiation (AD) directly through the entire pipeline.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Effort.jl is fully compatible with Julia's AD ecosystem:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ForwardDiff.jl: Forward-mode AD for efficient gradients\nZygote.jl: Reverse-mode AD for large parameter spaces","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This works seamlessly because the package includes:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Custom ChainRules: Hand-written adjoints for critical operations (Akima interpolation, window convolution)\nSciMLSensitivity: Efficient gradients through ODE solvers (growth factors)\nNon-mutating operations: All functions are Zygote-compatible","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Example - Differentiating the complete pipeline:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using ForwardDiff\n\n# Define a loss function over ALL parameters (cosmological + bias)\nfunction full_pipeline_loss(all_params)\n    # Unpack: first 8 are cosmological, next 11 are bias parameters\n    cosmo_local = Effort.w0waCDMCosmology(\n        ln10Aₛ = all_params[1], nₛ = all_params[2], h = all_params[3],\n        ωb = all_params[4], ωc = all_params[5], mν = all_params[6],\n        w0 = all_params[7], wa = all_params[8], ωk = 0.0\n    )\n\n    # Run complete pipeline: ODE solve → emulator → power spectrum\n    D_local, f_local = Effort.D_f_z(z, cosmo_local)\n\n    # Bias parameters (9-19) with f replaced at index 8\n    bias_local = [all_params[9:16]..., f_local, all_params[17:19]...]\n\n    emulator_input_local = [\n        z, cosmo_local.ln10Aₛ, cosmo_local.nₛ, cosmo_local.h * 100,\n        cosmo_local.ωb, cosmo_local.ωc, cosmo_local.mν, cosmo_local.w0, cosmo_local.wa\n    ]\n\n    P0_local = Effort.get_Pℓ(emulator_input_local, D_local, bias_local, monopole_emu)\n    return sum(abs2, P0_local)  # L2 norm\nend\n\n# Pack ALL parameters (8 cosmological + 11 bias = 19 total)\nall_params = vcat(\n    [cosmology.ln10Aₛ, cosmology.nₛ, cosmology.h,\n     cosmology.ωb, cosmology.ωc, cosmology.mν,\n     cosmology.w0, cosmology.wa],\n    bias_params\n)\n\n# Compute gradient using ForwardDiff (19 parameters: 8 cosmo + 11 bias)\ngrad_all = ForwardDiff.gradient(full_pipeline_loss, all_params)\nprintln(\"Gradient via ForwardDiff (w.r.t. all 19 parameters):\")\nprintln(\"  ∂L/∂h = $(grad_all[3])\")\nprintln(\"  ∂L/∂ωc = $(grad_all[5])\")\nprintln(\"  ∂L/∂b1 = $(grad_all[9])\")\nprintln(\"  All gradients finite: $(all(isfinite, grad_all))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance - ForwardDiff (19 parameters):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"forwarddiff_gradient\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"You can also use Zygote for reverse-mode AD:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Zygote\n\n# Compute gradient using Zygote\ngrad_zygote = Zygote.gradient(full_pipeline_loss, all_params)[1]\nprintln(\"Gradient via Zygote (w.r.t. all 19 parameters):\")\nprintln(\"  ∂L/∂h = $(grad_zygote[3])\")\nprintln(\"  ∂L/∂ωc = $(grad_zygote[5])\")\nprintln(\"  ∂L/∂b1 = $(grad_zygote[9])\")\nprintln(\"  All gradients finite: $(all(isfinite, grad_zygote))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance - Zygote (19 parameters):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"zygote_gradient\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"What do these timings mean?","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"These benchmarks show the time to compute all 19 gradients (∂L/∂ln10Aₛ, ∂L/∂nₛ, ∂L/∂h, ∂L/∂ωb, ∂L/∂ωc, ∂L/∂mν, ∂L/∂w0, ∂L/∂wa, plus all 11 bias parameter gradients) in a single call. The gradient computation includes:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Differentiating through the ODE solver (growth factors D and f)\nDifferentiating through the neural network emulator\nDifferentiating through the bias expansion","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ForwardDiff (~1 ms) is generally faster for problems with fewer parameters, while Zygote (~2 ms) is more memory-efficient for large-scale problems. Both are fast enough for gradient-based MCMC sampling.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Both ForwardDiff and Zygote are explicitly tested to ensure reliability. This enables:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Hamiltonian Monte Carlo (HMC) for efficient MCMC sampling\nVariational Inference (VI) for fast posterior approximation\nGradient-based optimization for maximum likelihood estimation","category":"page"},{"location":"example/#Use-Case-2:-Analytical-Jacobians-for-Fisher-Information-Matrices","page":"Example","title":"Use Case 2: Analytical Jacobians for Fisher Information Matrices","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"When computing Fisher Information Matrices (needed for survey forecasts, Jeffreys priors, or error propagation), we need Jacobians of the power spectrum with respect to bias parameters.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"While these Jacobians could be computed with AD, doing so during an MCMC analysis would require AD over AD (differentiating the Jacobian computation itself to get likelihood gradients). This is inefficient and numerically unstable.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Instead, Effort.jl provides analytical Jacobian implementations optimized for this use case:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Compute power spectrum AND its Jacobian w.r.t. bias parameters\nP0_jac, J0 = Effort.get_Pℓ_jacobian(emulator_input, D, bias_params, monopole_emu)\n\nprintln(\"Analytical Jacobian computed!\")\nprintln(\"  Shape: $(size(J0)) (k-points × bias parameters)\")\nprintln(\"  P0 from get_Pℓ_jacobian matches get_Pℓ: $(P0 ≈ P0_jac)\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"These analytical Jacobians can also be AP-corrected efficiently:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Compute Jacobians for all three multipoles\n_, J0 = Effort.get_Pℓ_jacobian(emulator_input, D, bias_params, monopole_emu)\n_, J2 = Effort.get_Pℓ_jacobian(emulator_input, D, bias_params, quadrupole_emu)\n_, J4 = Effort.get_Pℓ_jacobian(emulator_input, D, bias_params, hexadecapole_emu)\n\n# Apply AP corrections (matrix version is optimized for multiple columns)\nJ0_AP, J2_AP, J4_AP = Effort.apply_AP(k_grid, k_grid, J0, J2, J4, q_par, q_perp)\n\nprintln(\"AP-corrected Jacobians computed!\")\nprintln(\"  Each Jacobian shape: $(size(J0_AP))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Reliability: These analytical Jacobians are tested against:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Computer Algebra Systems (CAS): Symbolic differentiation for exact reference\nAutomatic Differentiation: Numerical validation with ForwardDiff/Zygote","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This ensures correctness while maintaining performance, making them ideal for:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Fisher matrix forecasts for survey optimization\nJeffreys priors computation in Bayesian analyses\nEfficient MCMC when combined with AD for cosmological parameters","category":"page"},{"location":"example/#Example:-Full-Pipeline-Differentiation","page":"Example","title":"Example: Full Pipeline Differentiation","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"You can also differentiate through the complete pipeline (ODE solvers + emulators + AP corrections) with respect to cosmological parameters:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using ForwardDiff, Zygote\n\nfunction full_loss(cosmo_params)\n    # Unpack: [ln10As, ns, H0, ωb, ωcdm, mν, w0, wa]\n    ln10As, ns, H0, ωb, ωcdm, mν, w0, wa = cosmo_params\n\n    cosmo = Effort.w0waCDMCosmology(\n        ln10Aₛ=ln10As, nₛ=ns, h=H0/100, ωb=ωb, ωc=ωcdm,\n        mν=mν, w0=w0, wa=wa, ωk=0.0\n    )\n\n    # Full pipeline: ODE → Emulator → AP\n    P0, P2, P4 = compute_multipoles(cosmo, z, bias_params, cosmo_ref)\n\n    return sum(abs2, P0) + sum(abs2, P2) + sum(abs2, P4)\nend\n\n# Both ForwardDiff and Zygote work!\ngrad_fd = ForwardDiff.gradient(full_loss, cosmo_params)\ngrad_zy = Zygote.gradient(full_loss, cosmo_params)[1]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"See the test suite in test/test_pipeline.jl for complete working examples with all AD backends (ForwardDiff, Zygote, FiniteDifferences).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Multi-Redshift-Analysis","page":"Example","title":"Multi-Redshift Analysis","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Real cosmological analyses often require computing power spectra at multiple redshifts simultaneously. Effort.jl efficiently handles this by solving the growth ODE only once for all redshifts.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Example: 5 redshifts from z=0.8 to z=1.9","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Define multiple redshifts\nz_array = range(0.8, 1.9, length=5)\nprintln(\"Analyzing $(length(z_array)) redshifts: $(collect(z_array))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The key advantage is that D_f_z accepts vector inputs, solving the ODE once and evaluating at all redshifts:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Compute growth factors for ALL redshifts at once (single ODE solve!)\nD_array, f_array = Effort.D_f_z(z_array, cosmology)\n\nprintln(\"Growth factors computed for all redshifts:\")\nfor (i, z_i) in enumerate(z_array)\n    println(\"  z = $(round(z_i, digits=2)): D = $(round(D_array[i], digits=4)), f = $(round(f_array[i], digits=4))\")\nend\nnothing # hide","category":"page"},{"location":"example/#Multi-Redshift-Forward-Pass","page":"Example","title":"Multi-Redshift Forward Pass","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Here's a complete multi-redshift pipeline that computes power spectra at all 5 redshifts:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"function multi_z_pipeline(all_params_multi)\n    # Unpack: first 8 are cosmological, next 55 are bias (11 × 5 redshifts)\n    cosmo_local = Effort.w0waCDMCosmology(\n        ln10Aₛ = all_params_multi[1], nₛ = all_params_multi[2], h = all_params_multi[3],\n        ωb = all_params_multi[4], ωc = all_params_multi[5], mν = all_params_multi[6],\n        w0 = all_params_multi[7], wa = all_params_multi[8], ωk = 0.0\n    )\n\n    # Compute D and f for ALL redshifts at once (single ODE solve!)\n    D_array, f_array = Effort.D_f_z(z_array, cosmo_local)\n\n    # Compute power spectra for all redshifts\n    total_loss = 0.0\n    for (i, z_i) in enumerate(z_array)\n        # Bias parameters for this redshift\n        bias_start = 8 + (i-1)*11 + 1\n        bias_end = 8 + i*11\n        bias_this_z = [all_params_multi[bias_start:bias_start+6]...,\n                       f_array[i],\n                       all_params_multi[bias_start+7:bias_end]...]\n\n        emulator_input_local = [\n            z_i, cosmo_local.ln10Aₛ, cosmo_local.nₛ, cosmo_local.h * 100,\n            cosmo_local.ωb, cosmo_local.ωc, cosmo_local.mν, cosmo_local.w0, cosmo_local.wa\n        ]\n\n        P0_local = Effort.get_Pℓ(emulator_input_local, D_array[i], bias_this_z, monopole_emu)\n        total_loss += sum(abs2, P0_local)\n    end\n\n    return total_loss\nend\n\n# Parameters: 8 cosmo + 55 bias (11 × 5 redshifts) = 63 total\nall_params_multi = vcat(\n    [cosmology.ln10Aₛ, cosmology.nₛ, cosmology.h,\n     cosmology.ωb, cosmology.ωc, cosmology.mν,\n     cosmology.w0, cosmology.wa],\n    repeat(bias_params, 5)\n)\n\nresult = multi_z_pipeline(all_params_multi)\nprintln(\"Multi-redshift pipeline executed successfully!\")\nprintln(\"Total parameters: $(length(all_params_multi)) (8 cosmo + 55 bias)\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"multi_z_forward\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Computing power spectra for 5 redshifts takes only ~368 μs - barely more than a single redshift (~313 μs)! This is because the expensive ODE solve is done only once.","category":"page"},{"location":"example/#Multi-Redshift-Differentiation","page":"Example","title":"Multi-Redshift Differentiation","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The multi-redshift pipeline is fully differentiable with both ForwardDiff and Zygote:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using ForwardDiff, Zygote\n\n# ForwardDiff: all 63 gradients\ngrad_fd = ForwardDiff.gradient(multi_z_pipeline, all_params_multi)\nprintln(\"ForwardDiff gradient computed!\")\nprintln(\"  Gradient shape: $(length(grad_fd)) (8 cosmo + 55 bias)\")\nprintln(\"  ∂L/∂h = $(grad_fd[3])\")\nprintln(\"  All gradients finite: $(all(isfinite, grad_fd))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance - ForwardDiff (63 parameters):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"multi_z_forwarddiff\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Zygote: all 63 gradients\ngrad_zy = Zygote.gradient(multi_z_pipeline, all_params_multi)[1]\nprintln(\"Zygote gradient computed!\")\nprintln(\"  Gradient shape: $(length(grad_zy)) (8 cosmo + 55 bias)\")\nprintln(\"  ∂L/∂h = $(grad_zy[3])\")\nprintln(\"  All gradients finite: $(all(isfinite, grad_zy))\")\nnothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Performance - Zygote (63 parameters):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"show_benchmark(\"multi_z_zygote\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Key Observations:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Zygote (~6 ms) is 2× faster than ForwardDiff (~13 ms) for 63 parameters\nZygote's reverse-mode AD becomes more efficient as parameter count increases\nBoth are fast enough for multi-redshift MCMC analyses","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Performance-Summary","page":"Example","title":"Performance Summary","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Here's a summary of computational timings for key operations:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Operation Time Memory Allocs Speedup vs PyBird\nGrowth factors D(z) & f(z) 183 μs 276 KB 11,805 ~1000×\nSingle multipole (ℓ=0) 25 μs 92 KB 186 ~10,000×\nSingle multipole (ℓ=2) 25 μs 93 KB 188 ~10,000×\nSingle multipole (ℓ=4) 25 μs 90 KB 180 ~10,000×\nAP correction (3 multipoles) 32 μs 86 KB 208 ~100×\nComplete pipeline (1z) 313 μs 650 KB 12,961 ~10,000×\nForwardDiff gradient (19 params) 1.06 ms 4.30 MB 21,095 -\nZygote gradient (19 params) 1.97 ms 2.91 MB 42,803 -\nMulti-z forward (5z, 63 params) 368 μs 744 KB 12,921 ~9,000×\nMulti-z ForwardDiff (63 params) 12.70 ms 39.80 MB 69,630 -\nMulti-z Zygote (63 params) 6.04 ms 18.98 MB 59,243 -","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Display system information for reproducibility\nusing JSON\nmetadata_file = joinpath(@__DIR__, \"assets\", \"benchmark_metadata.json\")\nif isfile(metadata_file)\n    metadata = JSON.parsefile(metadata_file)\n    println(\"Benchmark Hardware Information:\")\n    println(\"  Julia version: \", get(metadata, \"julia_version\", \"N/A\"))\n    println(\"  CPU: \", get(metadata, \"cpu_info\", \"N/A\"))\n    println(\"  Cores: \", get(metadata, \"ncores\", \"N/A\"))\n    println(\"  Timestamp: \", get(metadata, \"timestamp\", \"N/A\"))\nelse\n    println(\"System Information:\")\n    println(\"  Julia version: \", VERSION)\n    println(\"  CPU: \", Sys.cpu_info()[1].model)\n    println(\"  Cores: \", Sys.CPU_THREADS)\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"note: Benchmark Details\nThese benchmarks were run locally and saved to avoid recomputing during CI/CD. To regenerate on your hardware:julia --project=docs docs/run_benchmarks.jlThe script will display your system information and save detailed results (min/max/mean statistics) to docs/src/assets/effort_benchmark.json.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The entire pipeline is differentiable and extremely fast, making it ideal for:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Large-scale MCMC analysis (DESI, Euclid, LSST)\nReal-time parameter inference\nFisher forecasts and survey optimization\nGradient-based inference methods (HMC, VI)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/#Summary","page":"Example","title":"Summary","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This tutorial demonstrated the complete workflow for using Effort.jl:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"✅ Load pre-trained emulators from artifacts\n✅ Define cosmological parameters\n✅ Compute growth factors by solving ODEs\n✅ Predict power spectrum multipoles using neural networks\n✅ Apply Alcock-Paczynski corrections\n✅ Compute Jacobians for efficient inference\n✅ Differentiate through the entire pipeline with AD","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The package achieves ~10,000× speedup compared to traditional codes while maintaining full differentiability, enabling next-generation inference methods for cosmological surveys.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For more details on the API, see the API Documentation pages in the sidebar.","category":"page"}]
}
