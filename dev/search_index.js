var documenterSearchIndex = {"docs":
[{"location":"api_external/#External-API","page":"External API","title":"External API","text":"","category":"section"},{"location":"api_external/","page":"External API","title":"External API","text":"This section documents the public functions intended for users.","category":"page"},{"location":"api_external/","page":"External API","title":"External API","text":"Effort.w0waCDMCosmology\nEffort.q_par_perp(z, cosmo_mcmc::Effort.AbstractCosmology, cosmo_ref::Effort.AbstractCosmology)\nEffort.apply_AP\nEffort.window_convolution(W::Array{T, 4}, v::Matrix) where {T}\nEffort.window_convolution(W::AbstractMatrix, v::AbstractVector)","category":"page"},{"location":"api_external/#Effort.w0waCDMCosmology","page":"External API","title":"Effort.w0waCDMCosmology","text":"w0waCDMCosmology(ln10Aₛ::Number, nₛ::Number, h::Number, ωb::Number, ωc::Number, mν::Number=0., w0::Number=-1., wa::Number=0.)\n\nThis struct contains the value of the cosmological parameters for w_0 w_aCDM cosmologies.\n\nKeyword arguments\n\nln10Aₛ and nₛ, the amplitude and the tilt of the primordial power spectrum fluctuations\nh, the value of the reduced Hubble paramater\nωb and ωc, the physical energy densities of baryons and cold dark matter\nmν, the sum of the neutrino masses in eV\nw₀ and wₐ, the Dark Energy equation of state parameters in the CPL parameterization\n\n\n\n\n\n","category":"type"},{"location":"api_external/#Effort.q_par_perp-Tuple{Any, Effort.AbstractCosmology, Effort.AbstractCosmology}","page":"External API","title":"Effort.q_par_perp","text":"q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)\n\nCalculates the parallel (q_par) and perpendicular (q_perp) Alcock-Paczynski (AP) parameters at a given redshift z, comparing a varying cosmology to a reference cosmology.\n\nThe AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.\n\nArguments\n\nz: The redshift at which to calculate the AP parameters.\ncosmo_mcmc: An AbstractCosmology struct representing the varying cosmology (e.g., from an MCMC chain).\ncosmo_ref: An AbstractCosmology struct representing the reference cosmology used for measurements.\n\nReturns\n\nA tuple (q_par, q_perp) containing the calculated parallel and perpendicular AP parameters at redshift z.\n\nDetails\n\nThe parallel AP parameter q_par is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter q_perp is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.\n\nThe Hubble parameter E(z) is calculated using _E_z, and the conformal angular diameter distance d̃_A(z) is calculated using _d̃A_z.\n\nFormula\n\nThe formulas for the Alcock-Paczynski parameters are:\n\nq_parallel(z) = fracE_textref(z)E_textmcmc(z)\n\nq_perp(z) = fractilded_Atextmcmc(z)tilded_Atextref(z)\n\nwhere E(z) is the normalized Hubble parameter and tilded_A(z) is the conformal angular diameter distance.\n\nSee Also\n\n_E_z: Calculates the normalized Hubble parameter.\n_d̃A_z: Calculates the conformal angular diameter distance.\nAbstractCosmology: The abstract type for cosmology structs.\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.apply_AP","page":"External API","title":"Effort.apply_AP","text":"apply_AP(k_input::Array, k_output::Array, mono::Array, quad::Array, hexa::Array, q_par, q_perp; n_GL_points=8)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, using arrays of true multipole moments provided on an input wavenumber grid k_input, and employing Gauss-Lobatto quadrature.\n\nThis is the standard, faster implementation for applying the Alcock-Paczynski (AP) effect and redshift-space distortions (RSD) to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.\n\nArguments\n\nk_input: An array of wavenumber values on which the input true multipole moments (mono, quad, hexa) are defined.\nk_output: An array of observed wavenumber values at which to calculate the output observed multipoles.\nmono: An array containing the values of the true monopole moment I_0(k) on the k_input grid.\nquad: An array containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nhexa: An array containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nKeyword Arguments\n\nn_GL_points: The number of Gauss-Lobatto points to use for the integration over μ. The actual number of nodes used corresponds to 2 * n_GL_points. Defaults to 8.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is an array containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in k_output.\n\nDetails\n\nThe function applies the AP and RSD effects by integrating the observed anisotropic power spectrum P_textobs(k_o mu_o) over the observed cosine of the angle to the line-of-sight mu_o in 0 1 (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial mathcalL_ell(mu_o).\n\nThe process involves:\n\nDetermine Gauss-Lobatto nodes and weights for the interval [0, 1].\nFor each observed wavenumber k_o in the input k_output array and each μ_o node: a. Calculate the true wavenumber k_t(k_o mu_o) using _k_true. b. Calculate the true angle cosine mu_t(mu_o) using _μ_true. c. Interpolate the true multipole moments I_ell(k_t) using _akima_spline, interpolating from the k_input grid to the new k_t values. d. Calculate the true Legendre polynomials mathcalL_ell(mu_t) using _Legendre_0, _Legendre_2, _Legendre_4. e. Reconstruct the true power spectrum P(k_t mu_t) using _Pk_recon. f. Calculate the observed power spectrum P_textobs(k_o mu_o) = P(k_t mu_t)  (q_parallel q_perp^2).\nPerform the weighted sum (quadrature) over the μ_o nodes to get the observed multipoles P_ell(k_o) on the k_output grid.\n\nThis function is the standard, performant implementation for applying AP and RSD compared to the slower apply_AP_check.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The integral is approximated using Gauss-Lobatto quadrature.\n\nSee Also\n\napply_AP_check: The slower, check version using generic numerical integration.\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n_akima_spline: Interpolates the true multipole moments.\n_Pk_recon: Reconstructs the true power spectrum on a grid.\ngausslobatto: Function used to get quadrature nodes and weights.\n\n\n\n\n\n","category":"function"},{"location":"api_external/#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::Array{T, 4}, v::Matrix) where {T}\n\nApplies a 4-dimensional window function or kernel W to a 2-dimensional input matrix v.\n\nThis operation performs a transformation or generalized convolution, summing over the j and l indices of the inputs to produce a 2D result indexed by i and k. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.\n\nArguments\n\nW: A 4-dimensional array representing the window function or kernel.\nv: A 2-dimensional matrix representing the input data.\n\nReturns\n\nA 2-dimensional matrix representing the result of the convolution or transformation.\n\nDetails\n\nThe function implements the summation using the @tullio macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.\n\nFormula\n\nThe operation is defined as:\n\nC_ik = sum_jl W_ijkl v_jl\n\nSee Also\n\nwindow_convolution(W::AbstractMatrix, v::AbstractVector): Method for a matrix kernel and vector input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_external/#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}","page":"External API","title":"Effort.window_convolution","text":"window_convolution(W::AbstractMatrix, v::AbstractVector)\n\nPerforms matrix-vector multiplication, where the matrix W acts as a linear transformation or window applied to the vector input v.\n\nArguments\n\nW: An abstract matrix representing the linear transformation or window.\nv: An abstract vector representing the input data.\n\nReturns\n\nAn abstract vector representing the result of the matrix-vector multiplication.\n\nDetails\n\nThis method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix W to the vector v.\n\nFormula\n\nThe operation is defined as:\n\nmathbfc = mathbfW mathbfv\n\nor element-wise:\n\nc_i = sum_j W_ij v_j\n\nSee Also\n\nwindow_convolution(W::Array{T, 4}, v::Matrix) where {T}: Method for a 4D kernel and matrix input.\n\nReferences\n\nThe methodology for this type of window measurement is discussed in: arXiv:1810.05051\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#API-reference","page":"Internal API","title":"API reference","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"This section documents the functions intended for internal usage by the package.","category":"page"},{"location":"api_internal/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Pages = [\"api_internal.md\"]","category":"page"},{"location":"api_internal/#Background","page":"Internal API","title":"Background","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Effort._F\nEffort._dFdy\nEffort._get_y\nEffort._ΩνE2(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\nEffort._ΩνE2(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\nEffort._dΩνE2da(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\nEffort._dΩνE2da(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\nEffort._a_z\nEffort._ρDE_a\nEffort._ρDE_z\nEffort._dρDEda\nEffort._E_a(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._E_a(a, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._E_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._E_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._dlogEdloga\nEffort._Ωma(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._Ωma(a, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._r̃_z_check\nEffort._r̃_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._r̃_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._r_z_check(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._r_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._r_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._d̃A_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._d̃A_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._dA_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._dA_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._growth!\nEffort._growth_solver(Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._growth_solver(w0wacosmo::Effort.w0waCDMCosmology)\nEffort._growth_solver(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._growth_solver(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._D_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._D_z(z::AbstractVector, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\nEffort._D_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._f_z(z::AbstractVector, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\nEffort._f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\nEffort._f_z(z, w0wacosmo::Effort.w0waCDMCosmology)\nEffort._D_f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\nEffort._D_f_z(z, w0wacosmo::Effort.w0waCDMCosmology)","category":"page"},{"location":"api_internal/#Effort._F","page":"Internal API","title":"Effort._F","text":"_F(y)\n\nArguments\n\ny: The value of the parameter y for which the integral is calculated.\n\nReturns\n\nThe value of the definite integral for the given y.\n\nDetails\n\nThe integrand is defined as: f(x y) = x^2 cdot sqrtx^2 + y^2  (1 + e^x)\n\nThe integration is performed over the domain (0, Inf) for the variable x. A relative tolerance of 1e-12 is used for the integration solver.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._dFdy","page":"Internal API","title":"Effort._dFdy","text":"_dFdy(y)\n\nCalculates the definite integral of the function f(x y) = x^2  ((1 + e^x) cdot sqrtx^2 + y^2) with respect to x from 0 to Inf, and then multiplies the result by y.\n\nThis function is the derivative of the integral function _F(y) with respect to y.\n\nArguments\n\ny: The value of the parameter y used in the integrand and as a multiplicative factor.\n\nReturns\n\nThe value of the definite integral multiplied by y for the given y.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._get_y","page":"Internal API","title":"Effort._get_y","text":"_get_y(mν, a; kB=8.617342e-5, Tν=0.71611 * 2.7255)\n\nCalculates the dimensionless parameter y used in the integral function _F(y).\n\nThe parameter y is calculated based on the neutrino mass, scale factor, Boltzmann constant, and neutrino temperature according to the formula:\n\ny = mν * a / (kB * Tν)\n\nArguments\n\nmν: Neutrino mass (in units where kB and Tν are defined).\na: Scale factor.\n\nKeyword Arguments\n\nkB: Boltzmann constant (default: 8.617342e-5 eV/K).\nTν: Neutrino temperature (default: 0.71611 * 2.7255 K).\n\nReturns\n\nThe calculated dimensionless parameter y.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._ΩνE2-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._ΩνE2","text":"_ΩνE2(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\n\nCalculates the energy density of relic neutrinos, scaled by the critical density, at a given scale factor a, for a single neutrino mass.\n\nThis function accounts for the contribution of a single neutrino mass mν to the total energy density. It uses _F(y) to incorporate the effect of neutrino mass and temperature.\n\nArguments\n\na: The scale factor.\nΩγ0: The photon density parameter today.\nmν: The neutrino mass (a single value).\n\nKeyword Arguments\n\nkB: Boltzmann constant (default: 8.617342e-5 eV/K).\nTν: Neutrino temperature (default: 0.71611 * 2.7255 K).\nNeff: Effective number of neutrino species (default: 3.044).\n\nReturns\n\nThe calculated neutrino energy density parameter ΩνE2 at scale factor a for the given mass.\n\nDetails\n\nThe calculation involves a factor Γν derived from Neff and the ratio of neutrino to photon temperatures. The main term is proportional to Ωγ0 / a^4 multiplied by F_interpolant(_get_y(mν, a)).\n\nThe parameter y passed to F_interpolant is calculated using _get_y(mν, a).\n\nFormula\n\nThe formula used is: ΩνE2 = (15 / π^4) * Γν^4 * (Ωγ0 / a^4) * F(y) where Γν = (4/11)^(1/3) * (Neff/3)^(1/4) and y = mν * a / (kB * Tν).\n\nSee Also\n\n_get_y(mν, a): Calculates the y parameter.\n_F(y): The integral function used as F_interpolant.\n_ΩνE2(a, Ωγ0, mν::AbstractVector): Method for a vector of neutrino masses.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._ΩνE2-Tuple{Any, Any, AbstractVector}","page":"Internal API","title":"Effort._ΩνE2","text":"_ΩνE2(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\n\nCalculates the energy density of relic neutrinos, scaled by the critical density, at a given scale factor a, for a vector of neutrino masses.\n\nThis function accounts for the combined contribution of multiple neutrino masses to the total energy density by summing the individual contributions. It uses the F_interpolant function (which is equivalent to _F(y)) for each mass.\n\nArguments\n\na: The scale factor.\nΩγ0: The photon density parameter today.\nmν: A vector of neutrino masses (AbstractVector).\n\nKeyword Arguments\n\nkB: Boltzmann constant (default: 8.617342e-5 eV/K).\nTν: Neutrino temperature (default: 0.71611 * 2.7255 K).\nNeff: Effective number of neutrino species (default: 3.044).\n\nReturns\n\nThe calculated total neutrino energy density parameter ΩνE2 at scale factor a for the sum of contributions from all masses in the vector.\n\nDetails\n\nThe calculation involves a factor Γν derived from Neff and the ratio of neutrino to photon temperatures. The main term is proportional to Ωγ0 / a^4 multiplied by the sum of F_interpolant(_get_y(mν_i, a)) for each mass mν_i in the input vector mν.\n\nThe parameter y passed to F_interpolant for each mass is calculated using _get_y(mν_i, a).\n\nFormula\n\nThe formula used is: ΩνE2 = (15 / π^4) * Γν^4 * (Ωγ0 / a^4) * Σ F(y_i) where Γν = (4/11)^(1/3) * (Neff/3)^(1/4) and y_i = mν_i * a / (kB * Tν).\n\nSee Also\n\n_get_y(mν, a): Calculates the y parameter for each mass.\n_F(y): The integral function used as F_interpolant.\n_ΩνE2(a, Ωγ0, mν): Method for a single neutrino mass.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._dΩνE2da-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._dΩνE2da","text":"_dΩνE2da(a, Ωγ0, mν; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\n\nCalculates the derivative of the neutrino energy density parameter _ΩνE2 with respect to the scale factor a, for a single neutrino mass.\n\nThis function computes the derivative of the expression for _ΩνE2 by applying the chain rule, involving both _F(y) and _dFdy(y) functions.\n\nArguments\n\na: The scale factor.\nΩγ0: The photon density parameter today.\nmν: The neutrino mass (a single value).\n\nKeyword Arguments\n\nkB: Boltzmann constant (default: 8.617342e-5 eV/K).\nTν: Neutrino temperature (default: 0.71611 * 2.7255 K).\nNeff: Effective number of neutrino species (default: 3.044).\n\nReturns\n\nThe calculated derivative d(ΩνE2)/da at scale factor a for the given mass.\n\nDetails\n\nThe calculation is based on the derivative of the _ΩνE2 formula with respect to a.\n\nSee Also\n\n_ΩνE2(a, Ωγ0, mν): The function whose derivative is calculated.\n_get_y(mν, a): Calculates the y parameter.\n_F(y): The integral function used as F_interpolant.\n_dFdy(y): The function used as dFdy_interpolant.\n_dΩνE2da(a, Ωγ0, mν::AbstractVector): Method for a vector of neutrino masses.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._dΩνE2da-Tuple{Any, Any, AbstractVector}","page":"Internal API","title":"Effort._dΩνE2da","text":"_dΩνE2da(a, Ωγ0, mν::AbstractVector; kB=8.617342e-5, Tν=0.71611 * 2.7255, Neff=3.044)\n\nCalculates the derivative of the neutrino energy density parameter _ΩνE2 with respect to the scale factor a, for a vector of neutrino masses.\n\nThis function computes the derivative of the expression for _ΩνE2 by summing the derivatives of the contributions from each individual neutrino mass. It uses the _F(y) and _dFdy(y) functions for each mass.\n\nArguments\n\na: The scale factor.\nΩγ0: The photon density parameter today.\nmν: A vector of neutrino masses (AbstractVector).\n\nKeyword Arguments\n\nkB: Boltzmann constant (default: 8.617342e-5 eV/K).\nTν: Neutrino temperature (default: 0.71611 * 2.7255 K).\nNeff: Effective number of neutrino species (default: 3.044).\n\nReturns\n\nThe calculated total derivative d(ΩνE2)/da at scale factor a for the sum of contributions from all masses in the vector.\n\nDetails\n\nThe calculation sums the derivatives of the individual neutrino mass contributions to _ΩνE2 with respect to a.\n\nSee Also\n\n_ΩνE2(a, Ωγ0, mν::AbstractVector): The function whose derivative is calculated.\n_get_y(mν, a): Calculates the y parameter for each mass.\n_F(y): The integral function used as F_interpolant.\n_dFdy(y): The function used as dFdy_interpolant.\n_dΩνE2da(a, Ωγ0, mν): Method for a single neutrino mass.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._a_z","page":"Internal API","title":"Effort._a_z","text":"_a_z(z)\n\nCalculates the cosmological scale factor a from the redshift z.\n\nThe relationship between scale factor and redshift is given by a = 1  (1 + z).\n\nArguments\n\nz: The redshift (scalar or array).\n\nReturns\n\nThe corresponding scale factor a (scalar or array).\n\nFormula\n\nThe formula used is: a = 1  (1 + z)\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._ρDE_a","page":"Internal API","title":"Effort._ρDE_a","text":"_ρDE_a(a, w0, wa)\n\nCalculates the evolution of the dark energy density parameter relative to its value today, as a function of the scale factor a.\n\nThis function implements the standard parametrization for the dark energy equation of state w(a) = w0 + wa*(1-a).\n\nArguments\n\na: The scale factor (scalar or array).\nw0: The present-day value of the dark energy equation of state parameter.\nwa: The derivative of the dark energy equation of state parameter with respect to (1-a).\n\nReturns\n\nThe dark energy density parameter relative to its value today, ρ_DE(a) / ρ_DE(a=1), at the given scale factor a (scalar or array).\n\nFormula\n\nThe formula used is: rho_mathrmDE(a)  rho_mathrmDE(a=1) = a^(-3 * (1 + w0 + wa)) * e^3 * wa * (a - 1)\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for a.\n\nSee Also\n\n_ρDE_z(z, w0, wa): Calculates the dark energy density evolution as a function of redshift z.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._ρDE_z","page":"Internal API","title":"Effort._ρDE_z","text":"_ρDE_z(z, w0, wa)\n\nCalculates the evolution of the dark energy density parameter relative to its value today, as a function of the redshift z.\n\nThis function implements the standard parametrization for the dark energy equation of state w(a) = w0 + wa*(1-a), converted to depend on redshift z.\n\nArguments\n\nz: The redshift (scalar or array).\nw0: The present-day value of the dark energy equation of state parameter.\nwa: The derivative of the dark energy equation of state parameter with respect to (1-a).\n\nReturns\n\nThe dark energy density parameter relative to its value today, ρ_DE(z) / ρ_DE(z=0), at the given redshift z (scalar or array).\n\nFormula\n\nThe formula used is: rho_mathrmDE(z)  rho_mathrmDE(z=0) = (1 + z)^(3 * (1 + w0 + wa)) * e^-3 * wa * z  (1 + z)\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for z.\n\nSee Also\n\n_ρDE_a(a, w0, wa): Calculates the dark energy density evolution as a function of scale factor a.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._dρDEda","page":"Internal API","title":"Effort._dρDEda","text":"_dρDEda(a, w0, wa)\n\nCalculates the derivative of the dark energy density parameter evolution, d(ρ_DE(a)/ρ_DE(a=1))/da, with respect to the scale factor a.\n\nThis function computes the derivative of the formula implemented in _ρDE_a(a, w0, wa).\n\nArguments\n\na: The scale factor (scalar or array).\nw0: The present-day value of the dark energy equation of state parameter.\nwa: The derivative of the dark energy equation of state parameter with respect to (1-a).\n\nReturns\n\nThe calculated derivative of the dark energy density parameter evolution with respect to a at the given scale factor a (scalar or array).\n\nFormula\n\nThe formula used is: fracdda left( fracrho_textDE(a)rho_textDE(a=1) right) = 3 left( -frac1 + w_0 + w_aa + w_a right) fracrho_textDE(a)rho_textDE(a=1)\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for a.\n\nSee Also\n\n_ρDE_a(a, w0, wa): Calculates the dark energy density evolution.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._E_a-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._E_a","text":"_E_a(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the normalized Hubble parameter, E(a), at a given scale factor a.\n\nE(a) describes the expansion rate of the universe relative to the Hubble constant today, incorporating contributions from different energy density components: radiation (photons and massless neutrinos), cold dark matter and baryons, dark energy, and massive neutrinos.\n\nArguments\n\na: The scale factor (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: The total neutrino mass (or a vector of masses), used in the calculation of the       massive neutrino energy density. Defaults to 0.0 (massless neutrinos).\nw0: The present-day value of the dark energy equation of state parameter w(a) = w0 + wa*(1-a). Defaults to -1.0 (ΛCDM).\nwa: The derivative of the dark energy equation of state parameter with respect to (1-a). Defaults to 0.0 (ΛCDM).\n\nReturns\n\nThe calculated normalized Hubble parameter E(a) (scalar or array).\n\nDetails\n\nThe calculation includes:\n\nPhoton density Ωγ0 = 2.469e-5 / h^2.\nMassless neutrino density Ων0 (calculated from _ΩνE2 at a=1).\nDark energy density ΩΛ0 (calculated to ensure a flat universe: 1 - Ωγ0 - Ωcb0 - Ων0).\nMassive neutrino density _ΩνE2(a, Ωγ0, mν).\nDark energy evolution _ρDE_a(a, w0, wa) (density relative to today's dark energy density).\n\nThe formula used is: E(a) = sqrt(Ωγ0 * a^-4 + Ωcb0 * a^-3 + ΩΛ0 * ρDE(a) + ΩνE2(a)) where ρDE(a) is the dark energy density relative to its value today, and ΩνE2(a) is the massive neutrino energy density parameter at scale factor a.\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for a.\n\nSee Also\n\n_ΩνE2(a, Ωγ0, mν): Calculates the massive neutrino energy density.\n_ρDE_a(a, w0, wa): Calculates the dark energy density evolution (relative to today).\n_E_a(a, w0wacosmo::w0waCDMCosmology): Convenience method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._E_a-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._E_a","text":"_E_a(a, w0wacosmo::w0waCDMCosmology)\n\nCalculates the normalized Hubble parameter, E(a), at a given scale factor a, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the main _E_a function. It extracts the cold dark matter and baryon density (Ωcb0), Hubble parameter (h), neutrino mass (mν), and dark energy parameters (w0, wa) from the provided cosmology struct and passes them to the primary _E_a method.\n\nArguments\n\na: The scale factor (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated normalized Hubble parameter E(a) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _E_a(a, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_E_a(a, Ωcb0, h; mν, w0, wa): The primary method that performs the calculation.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._E_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._E_z","text":"_E_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the normalized Hubble parameter, E(z), as a function of redshift z.\n\nThis function is the redshift-dependent counterpart to _E_a(a, Ωcb0, h; mν, w0, wa). It first converts z to the scale factor a using _a_z(z) and then calls the _E_a function.\n\nArguments\n\nz: The redshift (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated normalized Hubble parameter E(z) (scalar or array).\n\nSee Also\n\n_E_a(a, Ωcb0, h; mν, w0, wa): The corresponding scale factor dependent function.\n_a_z(z): Converts redshift to scale factor.\n_E_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._E_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._E_z","text":"_E_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the normalized Hubble parameter, E(z), as a function of redshift z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis function is the redshift-dependent counterpart to _E_a(a, w0wacosmo::w0waCDMCosmology). It's a convenience method that extracts parameters from the struct and calls the primary _E_z(z, Ωcb0, h; mν, w0, wa) method.\n\nArguments\n\nz: The redshift (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated normalized Hubble parameter E(z) (scalar or array).\n\nSee Also\n\n_E_a(a, w0wacosmo::w0waCDMCosmology): The corresponding scale factor dependent function using a struct.\n_E_z(z, Ωcb0, h; mν, w0, wa): The primary method using individual parameters.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._dlogEdloga","page":"Internal API","title":"Effort._dlogEdloga","text":"_dlogEdloga(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the logarithmic derivative of the normalized Hubble parameter, fracd(log E)d(log a), with respect to the logarithm of the scale factor a.\n\nThis quantity is useful in cosmological calculations, particularly when analyzing the growth of structure. It is derived from the derivative of E(a) with respect to a.\n\nArguments\n\na: The scale factor (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated value of fracd(log E)d(log a) at the given scale factor a (scalar or array).\n\nDetails\n\nThe calculation involves the derivative of the _E_a function with respect to a. The formula is derived from fracd(log E)d(log a) = fracaE fracdEda. The derivative dE/da involves terms related to the derivatives of the density components with respect to a, including _dρDEda(a, w0, wa) and _dΩνE2da(a, Ωγ0, mν).\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for a.\n\nSee Also\n\n_E_a(a, Ωcb0, h; mν, w0, wa): The normalized Hubble parameter function.\n_dΩνE2da(a, Ωγ0, mν): Derivative of the neutrino energy density.\n_ρDE_a(a, w0, wa): Dark energy density evolution (relative to today).\n_dρDEda(a, w0, wa): Derivative of the dark energy density evolution (relative to today).\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Ωma-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._Ωma","text":"_Ωma(a, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the total matter density parameter, Ω_m(a), at a given scale factor a.\n\nThis represents the combined density of cold dark matter and baryons relative to the critical density at scale factor a.\n\nArguments\n\na: The scale factor (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es) (used in the calculation of _E_a).\nw0: Dark energy equation of state parameter (used in the calculation of _E_a).\nwa: Dark energy equation of state parameter derivative (used in the calculation of _E_a).\n\nReturns\n\nThe calculated total matter density parameter Ω_m(a) at the given scale factor a (scalar or array).\n\nFormula\n\nThe formula used is: Omega_m(a) = fracOmega_textcb0 a^-3E(a)^2 where E(a) is the normalized Hubble parameter calculated using _E_a(a, Ωcb0, h; mν, w0, wa).\n\nThis function uses broadcasting (@.) to handle scalar or array inputs for a.\n\nSee Also\n\n_E_a(a, Ωcb0, h; mν, w0, wa): The normalized Hubble parameter function.\n_Ωma(a, w0wacosmo::w0waCDMCosmology): Convenience method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._Ωma-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._Ωma","text":"_Ωma(a, w0wacosmo::w0waCDMCosmology)\n\nCalculates the total matter density parameter, Ω_m(a), at a given scale factor a, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _Ωma(a, Ωcb0, h; mν, w0, wa) function. It extracts the cold dark matter and baryon density (Ωcb0), Hubble parameter (h), neutrino mass (mν), and dark energy parameters (w0, wa) from the provided cosmology struct and passes them to the primary _Ωma method.\n\nArguments\n\na: The scale factor (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated total matter density parameter Ω_m(a) at the given scale factor a (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _Ωma(a, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_Ωma(a, Ωcb0, h; mν, w0, wa): The primary method that performs the calculation.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._r̃_z_check","page":"Internal API","title":"Effort._r̃_z_check","text":"_r̃_z_check(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the conformal distance r̃(z) to a given redshift z using numerical integration.\n\nThis is a \"check\" version, typically slower but potentially more accurate, used for verifying results from faster methods. The conformal distance is the integral of 1/E(z) with respect to z.\n\nArguments\n\nz: The redshift (scalar).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated conformal distance r̃(z) (scalar).\n\nDetails\n\nThe function calculates the integral int_0^z fracdzE(z) where E(z) is the normalized Hubble parameter at redshift z, calculated using _E_a after converting z to scale factor using _a_z. The integration is performed using IntegralProblem and the QuadGKJL() solver.\n\nFormula\n\nThe conformal distance is defined as: tilder(z) = int_0^z fracdzE(z)\n\nSee Also\n\n_r̃_z: The standard, faster method for calculating conformal distance.\n_E_a: Calculates the normalized Hubble parameter as a function of scale factor.\n_a_z: Converts redshift to scale factor.\n_r_z_check: Calculates the comoving distance using this check version.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._r̃_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._r̃_z","text":"_r̃_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the conformal distance r̃(z) to a given redshift z using Gauss-Legendre quadrature.\n\nThis is the standard, faster method for calculating the conformal distance, which is the integral of 1/E(z) with respect to z.\n\nArguments\n\nz: The redshift (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated conformal distance r̃(z) (scalar or array).\n\nDetails\n\nThe function approximates the integral int_0^z fracdzE(z) using Gauss-Legendre quadrature with a specified number of points (here, 9). It uses _transformed_weights to get the quadrature points and weights over the interval [0, z]. The integrand 1E(z) is evaluated at these points using _E_a (after converting z' to a with _a_z), and the result is a weighted sum.\n\nFormula\n\nThe conformal distance is defined as: tilder(z) = int_0^z fracdzE(z) This function computes this integral numerically.\n\nSee Also\n\n_r̃_z_check: A slower, check version using different integration.\n_E_a: Calculates the normalized Hubble parameter as a function of scale factor.\n_a_z: Converts redshift to scale factor.\n_transformed_weights: Generates quadrature points and weights.\n_r_z: Calculates the comoving distance.\n_r̃_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._r̃_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._r̃_z","text":"_r̃_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the conformal distance r̃(z) to a given redshift z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _r̃_z(z, Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nz: The redshift (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated conformal distance r̃(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _r̃_z(z, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_r̃_z(z, Ωcb0, h; mν, w0, wa): The primary method for calculating conformal distance.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_r_z: Calculates the comoving distance.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._r_z_check-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._r_z_check","text":"_r_z_check(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the comoving distance r(z) to a given redshift z using the \"check\" version of the conformal distance calculation.\n\nThe comoving distance is related to the conformal distance by a factor involving the speed of light and the Hubble parameter today. This version uses the slower, potentially more accurate _r̃_z_check for the conformal distance.\n\nArguments\n\nz: The redshift (scalar).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated comoving distance r(z) (scalar).\n\nDetails\n\nThe comoving distance is calculated by scaling the conformal distance obtained from _r̃_z_check(z, Ωcb0, h; mν, w0, wa) by the factor c_0  (100 h), where c_0 is the speed of light (in units consistent with h).\n\nFormula\n\nThe comoving distance is defined as: r(z) = fracc_0100 h tilder(z) This function uses tilder(z) = text_r_z_check(z dots).\n\nSee Also\n\n_r̃_z_check: The slower, check version of the conformal distance calculation.\n_r_z: The standard, faster method for calculating comoving distance.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._r_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._r_z","text":"_r_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the comoving distance r(z) to a given redshift z using the standard conformal distance calculation.\n\nThe comoving distance is related to the conformal distance by a factor involving the speed of light and the Hubble parameter today. This version uses the standard, faster _r̃_z for the conformal distance.\n\nArguments\n\nz: The redshift (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated comoving distance r(z) (scalar or array).\n\nDetails\n\nThe comoving distance is calculated by scaling the conformal distance obtained from _r̃_z(z, Ωcb0, h; mν, w0, wa) by the factor c_0  (100 h), where c_0 is the speed of light (in units consistent with h).\n\nFormula\n\nThe comoving distance is defined as: r(z) = fracc_0100 h tilder(z) This function uses tilder(z) = text_r_z(z dots).\n\nSee Also\n\n_r̃_z: The standard, faster method for calculating conformal distance.\n_r_z_check: A slower, check version using a different conformal distance calculation.\n_r_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._r_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._r_z","text":"_r_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the comoving distance r(z) to a given redshift z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _r_z(z, Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nz: The redshift (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated comoving distance r(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _r_z(z, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_r_z(z, Ωcb0, h; mν, w0, wa): The primary method for calculating comoving distance.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_r̃_z: Calculates the conformal distance.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._d̃A_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._d̃A_z","text":"_d̃A_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the conformal angular diameter distance d̃_A(z) to a given redshift z.\n\nThe conformal angular diameter distance is defined as the conformal comoving distance divided by (1 + z).\n\nArguments\n\nz: The redshift (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated conformal angular diameter distance d̃_A(z) (scalar or array).\n\nDetails\n\nThe function calculates the conformal comoving distance using _r̃_z(z, Ωcb0, h; mν, w0, wa) and then divides by (1 + z).\n\nFormula\n\nThe formula used is: tilded_A(z) = fractilder(z)1 + z where tilder(z) is the conformal comoving distance.\n\nSee Also\n\n_r̃_z: Calculates the conformal comoving distance.\n_dA_z: Calculates the standard angular diameter distance.\n_d̃A_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._d̃A_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._d̃A_z","text":"_d̃A_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the conformal angular diameter distance d̃_A(z) to a given redshift z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _d̃A_z(z, Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nz: The redshift (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated conformal angular diameter distance d̃_A(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _d̃A_z(z, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_d̃A_z(z, Ωcb0, h; mν, w0, wa): The primary method for calculating conformal angular diameter distance.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_dA_z: Calculates the standard angular diameter distance.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._dA_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._dA_z","text":"_dA_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the angular diameter distance d_A(z) to a given redshift z.\n\nThe angular diameter distance is defined as the comoving distance divided by (1 + z).\n\nArguments\n\nz: The redshift (scalar or array).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated angular diameter distance d_A(z) (scalar or array).\n\nDetails\n\nThe function calculates the comoving distance using _r_z(z, Ωcb0, h; mν, w0, wa) and then divides by (1 + z).\n\nFormula\n\nThe formula used is: d_A(z) = fracr(z)1 + z where r(z) is the comoving distance.\n\nSee Also\n\n_r_z: Calculates the comoving distance.\n_a_z: Converts redshift to scale factor.\n_d̃A_z: Calculates the conformal angular diameter distance.\n_dA_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._dA_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._dA_z","text":"_dA_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the angular diameter distance d_A(z) to a given redshift z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _dA_z(z, Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nz: The redshift (scalar or array).\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated angular diameter distance d_A(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _dA_z(z, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_dA_z(z, Ωcb0, h; mν, w0, wa): The primary method for calculating angular diameter distance.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_d̃A_z: Calculates the conformal angular diameter distance.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._growth!","page":"Internal API","title":"Effort._growth!","text":"_growth!(du, u, p, loga)\n\nDefines the in-place right-hand side of the second-order ordinary differential equation for the linear growth factor D(a), with log(a) as the independent variable.\n\nThe state vector u is [D(log a), dD/d(log a)]. This function calculates the derivatives du = [dD/d(log a), d^2D/d(log a)^2] based on the growth equation.\n\nArguments\n\ndu: The output vector where the calculated derivatives are stored (modified in-place).\nu: The current state vector [D(log a), dD/d(log a)].\np: A vector of parameters [Ωcb0, mν, h, w0, wa].\nloga: The natural logarithm of the scale factor, log(a).\n\nReturns\n\nModifies the du vector in-place.\n\nDetails\n\nThe function solves the second-order differential equation for the linear growth factor, often written as:\n\nfracd^2 Dd(ln a)^2 + left(2 + fracd ln Ed ln aright) fracd Dd ln a - frac32 Omega_m(a) D = 0\n\nwhere E(a) is the normalized Hubble parameter and Omega_m(a) is the matter density parameter.\n\nThe terms fracd ln Ed ln a and Omega_m(a) are calculated using _dlogEdloga and _Ωma respectively, with parameters extracted from p.\n\nThe system of first-order ODEs implemented is: fracd u1d(ln a) = u2 fracd u2d(ln a) = -left(2 + fracd ln Ed ln aright) u2 + frac32 Omega_m(a) u1\n\nSee Also\n\n_growth_solver: Functions that solve this ODE.\n_dlogEdloga: Calculates the logarithmic derivative of E(a).\n_Ωma: Calculates the matter density parameter at scale factor a.\n_E_a: Related normalized Hubble parameter.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._growth_solver-Tuple{Any, Any}","page":"Internal API","title":"Effort._growth_solver","text":"_growth_solver(Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nSolves the ODE for the linear growth factor D(a) and its derivative dD/d(log a) over a fixed range of log(a), typically from an early time to slightly past a=1.\n\nThis function sets up and solves the _growth! ODE using a standard solver.\n\nArguments\n\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA DifferentialEquations.jl solution object containing the values of D(log a) and dD/d(log a) over the solved log(a) range.\n\nDetails\n\nThe ODE is solved from log(amin) to log(1.01), where amin = 1/139. Initial conditions u₀ = [amin, amin] are used, corresponding to D(a) ≈ a at early times. The problem is solved using the Tsit5() solver with a relative tolerance of 1e-5.\n\nSee Also\n\n_growth!: Defines the growth ODE.\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Method to solve and save at specific redshifts.\n_growth_solver(w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._growth_solver-Tuple{Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._growth_solver","text":"_growth_solver(w0wacosmo::w0waCDMCosmology)\n\nSolves the ODE for the linear growth factor D(a) and its derivative dD/d(log a) using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _growth_solver(Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nA DifferentialEquations.jl solution object containing the values of D(log a) and dD/d(log a) over the solved log(a) range.\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _growth_solver(Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_growth!: Defines the growth ODE.\n_growth_solver(Ωcb0, h; mν, w0, wa): The primary solver method.\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Method to solve and save at specific redshifts.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._growth_solver-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._growth_solver","text":"_growth_solver(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nSolves the ODE for the linear growth factor D(a) and its derivative dD/d(log a) and returns the solution evaluated specifically at the given redshift(s) z.\n\nThis function solves the _growth! ODE over a range of log(a) and then extracts the solution values corresponding to the provided redshift(s).\n\nArguments\n\nz: The redshift or an array of redshifts at which to save the solution.\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA 2xN array (where N is the number of redshifts in z) containing the solution. The first row contains the growth factor D(z), and the second row contains the derivative dD/d(log a) evaluated at redshift z.\n\nDetails\n\nThe ODE is solved from log(amin) to log(1.01), where amin = 1/139. Initial conditions u₀ = [amin, amin] are used, corresponding to D(a) ≈ a at early times. The problem is solved using the Tsit5() solver with a relative tolerance of 1e-5. The solution is saved specifically at the log(a) values corresponding to the input redshifts z, obtained using _a_z.\n\nSee Also\n\n_growth!: Defines the growth ODE.\n_growth_solver(Ωcb0, h; mν, w0, wa): Method to solve over a fixed range.\n_growth_solver(w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n_a_z: Converts redshift to scale factor.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._growth_solver-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._growth_solver","text":"_D_z(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the linear growth factor D(z) for a single redshift z.\n\nThe linear growth factor describes how density perturbations grow in the linear regime of structure formation. It is obtained by solving a second-order ODE.\n\nArguments\n\nz: The redshift (scalar).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated linear growth factor D(z) (scalar).\n\nDetails\n\nThis function solves the growth ODE using the _growth_solver(Ωcb0, h; mν, w0, wa) method, which solves over a fixed range of log(a). It then evaluates the solution at the log(a) value corresponding to the input redshift z (obtained via _a_z) to get the value of D(z).\n\nSee Also\n\n_growth_solver: Solves the growth ODE.\n_a_z: Converts redshift to scale factor.\n_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa): Method for a vector of redshifts.\n_D_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._D_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._D_z","text":"_growth_solver(z, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nSolves the ODE for the linear growth factor D(a) and its derivative dD/d(log a) and returns the solution evaluated specifically at the given redshift(s) z.\n\nThis function solves the _growth! ODE over a range of log(a) and then extracts the solution values corresponding to the provided redshift(s).\n\nArguments\n\nz: The redshift or an array of redshifts at which to save the solution.\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA 2xN array (where N is the number of redshifts in z) containing the solution. The first row contains the growth factor D(z), and the second row contains the derivative dD/d(log a) evaluated at redshift z.\n\nDetails\n\nThe ODE is solved from log(amin) to log(1.01), where amin = 1/139. Initial conditions u₀ = [amin, amin] are used, corresponding to D(a) ≈ a at early times. The problem is solved using the Tsit5() solver with a relative tolerance of 1e-5. The solution is saved specifically at the log(a) values corresponding to the input redshifts z, obtained using _a_z.\n\nSee Also\n\n_growth!: Defines the growth ODE.\n_growth_solver(Ωcb0, h; mν, w0, wa): Method to solve over a fixed range.\n_growth_solver(w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n_a_z: Converts redshift to scale factor.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._D_z-Tuple{AbstractVector, Any, Any}","page":"Internal API","title":"Effort._D_z","text":"_D_z(z::AbstractVector, Ωcb0, h; mν=0.0, w0=-1.0, wa=0.0)\n\nCalculates the linear growth factor D(z) for a vector of redshifts z.\n\nThe linear growth factor describes how density perturbations grow in the linear regime of structure formation. It is obtained by solving a second-order ODE.\n\nArguments\n\nz: A vector of redshifts (AbstractVector).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA vector containing the calculated linear growth factor D(z) for each redshift in the input vector z.\n\nDetails\n\nThis function solves the growth ODE using the _growth_solver(z, Ωcb0, h; mν, w0, wa) method, which solves the ODE and saves the solution specifically at the log(a) values corresponding to the input redshifts z. It then extracts the first row of the solution (which contains the D(z) values) and reverses it.\n\nSee Also\n\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Solves the growth ODE and saves at specific redshifts.\n_a_z: Converts redshift to scale factor (used internally by _growth_solver).\n_D_z(z, Ωcb0, h; mν, w0, wa): Method for a single redshift.\n_D_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._D_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._D_z","text":"_D_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the linear growth factor D(z) for a given redshift or vector of redshifts z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _D_z(z, Ωcb0, h; mν, w0, wa) or _D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa) functions. It extracts the necessary cosmological parameters from the provided struct and calls the appropriate method based on whether z is a scalar or a vector.\n\nArguments\n\nz: The redshift or an array of redshifts.\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated linear growth factor D(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls either _D_z(z, Ωcb0, h; mν, w0, wa) or _D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa) internally, depending on the type of z.\n\nSee Also\n\n_D_z(z, Ωcb0, h; mν, w0, wa): Method for a single redshift.\n_D_z(z::AbstractVector, Ωcb0, h; mν, w0, wa): Method for a vector of redshifts.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._f_z-Tuple{AbstractVector, Any, Any}","page":"Internal API","title":"Effort._f_z","text":"_f_z(z::AbstractVector, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\n\nCalculates the linear growth rate f(z) for a vector of redshifts z.\n\nThe linear growth rate is defined as f(z) = fracd ln Dd ln a = fracdDd(ln a)D, where D(z) is the linear growth factor and a is the scale factor.\n\nArguments\n\nz: A vector of redshifts (AbstractVector).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA vector containing the calculated linear growth rate f(z) for each redshift in the input vector z.\n\nDetails\n\nThis function uses the _growth_solver(z, Ωcb0, h; mν, w0, wa) method to solve the growth ODE and obtain the growth factor D(z) and its derivative with respect to log(a), dD/d(log a), at the specified redshifts. It then calculates f(z) as the ratio of dD/d(log a) to D(z) at each redshift. The result is reversed before returning.\n\nFormula\n\nThe formula used is: f(z) = fracd ln Dd ln a = fracdDd(ln a)D\n\nSee Also\n\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Solves the growth ODE and saves at specific redshifts.\n_D_z: Calculates the linear growth factor.\n_f_z(z, Ωcb0, h; mν, w0, wa): Method for a single redshift.\n_f_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n_D_f_z: Calculates both D(z) and f(z).\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._f_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._f_z","text":"_f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\n\nCalculates the linear growth rate f(z) for a single redshift z.\n\nThe linear growth rate is defined as f(z) = fracd ln Dd ln a = fracdDd(ln a)D, where D(z) is the linear growth factor and a is the scale factor.\n\nArguments\n\nz: The redshift (scalar).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nThe calculated linear growth rate f(z) (scalar).\n\nDetails\n\nThis function uses the _growth_solver(z, Ωcb0, h; mν, w0, wa) method to solve the growth ODE and obtain the growth factor D(z) and its derivative with respect to log(a), dD/d(log a), at the specified redshift. It then calculates f(z) as the ratio of dD/d(log a) to D(z).\n\nFormula\n\nThe formula used is: f(z) = fracd ln Dd ln a = fracdDd(ln a)D\n\nSee Also\n\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Solves the growth ODE and saves at specific redshifts.\n_D_z: Calculates the linear growth factor.\n_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa): Method for a vector of redshifts.\n_f_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n_D_f_z: Calculates both D(z) and f(z).\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._f_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._f_z","text":"_f_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates the linear growth rate f(z) for a given redshift or vector of redshifts z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _f_z(z, Ωcb0, h; mν, w0, wa) or _f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa) functions. It extracts the necessary cosmological parameters from the provided struct and calls the appropriate method based on whether z is a scalar or a vector.\n\nArguments\n\nz: The redshift or an array of redshifts.\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nThe calculated linear growth rate f(z) (scalar or array).\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls either _f_z(z, Ωcb0, h; mν, w0, wa) or _f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa) internally, depending on the type of z.\n\nSee Also\n\n_f_z(z, Ωcb0, h; mν, w0, wa): Method for a single redshift.\n_f_z(z::AbstractVector, Ωcb0, h; mν, w0, wa): Method for a vector of redshifts.\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_D_f_z: Calculates both D(z) and f(z).\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._D_f_z-Tuple{Any, Any, Any}","page":"Internal API","title":"Effort._D_f_z","text":"_D_f_z(z, Ωcb0, h; mν=0, w0=-1.0, wa=0.0)\n\nCalculates both the linear growth factor D(z) and the linear growth rate f(z) for a vector of redshifts z.\n\nThis function is a convenience to get both quantities from a single ODE solution. The growth rate is defined as f(z) = fracd ln Dd ln a = fracdDd(ln a)D.\n\nArguments\n\nz: A vector of redshifts (AbstractVector).\nΩcb0: The density parameter for cold dark matter and baryons today.\nh: The Hubble parameter today, divided by 100 km/s/Mpc.\n\nKeyword Arguments\n\nmν: Total neutrino mass(es).\nw0: Dark energy equation of state parameter.\nwa: Dark energy equation of state parameter derivative.\n\nReturns\n\nA tuple (D_values, f_values), where D_values is a vector of the linear growth factor D(z) and f_values is a vector of the linear growth rate f(z) for each redshift in the input vector z. Both vectors are reversed before returning.\n\nDetails\n\nThis function uses the _growth_solver(z, Ωcb0, h; mν, w0, wa) method to solve the growth ODE and obtain the growth factor D(z) and its derivative with respect to log(a), dD/d(log a), at the specified redshifts. It then calculates f(z) as the ratio of dD/d(log a) to D(z) at each redshift. Both the D(z) and calculated f(z) vectors are returned.\n\nFormula\n\nThe formula used for f(z) is: f(z) = fracd ln Dd ln a = fracdDd(ln a)D\n\nSee Also\n\n_growth_solver(z, Ωcb0, h; mν, w0, wa): Solves the growth ODE and saves at specific redshifts.\n_D_z: Calculates the linear growth factor separately.\n_f_z: Calculates the linear growth rate separately.\n_D_f_z(z, w0wacosmo::w0waCDMCosmology): Method using a cosmology struct.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._D_f_z-Tuple{Any, Effort.w0waCDMCosmology}","page":"Internal API","title":"Effort._D_f_z","text":"_D_f_z(z, w0wacosmo::w0waCDMCosmology)\n\nCalculates both the linear growth factor D(z) and the linear growth rate f(z) for a vector of redshifts z, using parameters extracted from a w0waCDMCosmology struct.\n\nThis method is a convenience wrapper around the primary _D_f_z(z, Ωcb0, h; mν, w0, wa) function. It extracts the necessary cosmological parameters from the provided struct.\n\nArguments\n\nz: A vector of redshifts.\nw0wacosmo: A struct of type w0waCDMCosmology containing the cosmological parameters.\n\nReturns\n\nA tuple (D_values, f_values), where D_values is a vector of the linear growth factor D(z) and f_values is a vector of the linear growth rate f(z) for each redshift in the input vector z.\n\nDetails\n\nThe parameters Ωcb0, h, mν, w0, and wa are extracted from the w0wacosmo struct. Ωcb0 is calculated as (w0wacosmo.ωb + w0wacosmo.ωc) / w0wacosmo.h^2.\n\nThis method calls the primary _D_f_z(z, Ωcb0, h; mν, w0, wa) method internally.\n\nSee Also\n\n_D_f_z(z, Ωcb0, h; mν, w0, wa): The primary method for calculating D(z) and f(z).\nw0waCDMCosmology: The struct type containing the cosmological parameters.\n_D_z: Calculates the linear growth factor separately.\n_f_z: Calculates the linear growth rate separately.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Projection","page":"Internal API","title":"Projection","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Effort._Pkμ\nEffort._k_true(k_o, μ_o, q_perp, F)\nEffort._k_true(k_o::Array, μ_o::Array, q_perp, F)\nEffort._μ_true(μ_o, F)\nEffort._μ_true(μ_o::Array, F)\nEffort._P_obs\nEffort.interp_Pℓs\nEffort.apply_AP_check(k_input::Array, k_output::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array, q_par, q_perp)\nEffort._Pk_recon","category":"page"},{"location":"api_internal/#Effort._Pkμ","page":"Internal API","title":"Effort._Pkμ","text":"_Pkμ(k, μ, Int_Mono, Int_Quad, Int_Hexa)\n\nReconstructs the anisotropic power spectrum P(k mu) at a given wavenumber k and cosine of the angle to the line-of-sight μ, using its Legendre multipole moments.\n\nArguments\n\nk: The wavenumber.\nμ: The cosine of the angle to the line-of-sight.\nInt_Mono: A function or interpolant that provides the monopole moment I_0(k) at wavenumber k.\nInt_Quad: A function or interpolant that provides the quadrupole moment I_2(k) at wavenumber k.\nInt_Hexa: A function or interpolant that provides the hexadecapole moment I_4(k) at wavenumber k.\n\nReturns\n\nThe value of the anisotropic power spectrum P(k mu) at the given k and μ.\n\nDetails\n\nThe anisotropic power spectrum is reconstructed as a sum of its multipole moments multiplied by the corresponding Legendre polynomials evaluated at μ. The function uses the 0th, 2nd, and 4th order Legendre polynomials.\n\nFormula\n\nThe formula used is:\n\nP(k mu) = I_0(k) mathcalL_0(mu) + I_2(k) mathcalL_2(mu) + I_4(k) mathcalL_4(mu)\n\nwhere I_l(k) are the multipole moments and mathcalL_l(mu) are the Legendre polynomials of order l.\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._k_true-NTuple{4, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o, μ_o, q_perp, F)\n\nCalculates the true (physical) wavenumber k from the observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by q_perp and F.\n\nArguments\n\nk_o: The observed wavenumber (scalar).\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true wavenumber k (scalar).\n\nFormula\n\nThe formula used is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o::Array, μ_o::Array, q_perp, F): Method for arrays of observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._k_true-Tuple{Array, Array, Any, Any}","page":"Internal API","title":"Effort._k_true","text":"_k_true(k_o::Array, μ_o::Array, q_perp, F)\n\nCalculates the true (physical) wavenumber k for arrays of observed wavenumbers k_o and observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true wavenumber element-wise or for combinations of input arrays, accounting for anisotropic effects parameterized by q_perp and F.\n\nArguments\n\nk_o: An array of observed wavenumbers.\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nA vector containing the calculated true wavenumbers k for the given input arrays.\n\nDetails\n\nThe function calculates k for pairs or combinations of values from the input arrays k_o and μ_o using a formula derived from anisotropic scaling. The calculation involves broadcasting and array operations to handle the array inputs efficiently. The result is flattened into a vector.\n\nFormula\n\nThe underlying transformation for each pair of k_o and μ_o is:\n\nk = frack_oq_perp sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_k_true(k_o, μ_o, q_perp, F): Method for scalar observed values.\n_μ_true: Calculates the true cosine of the angle to the line-of-sight.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Any, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ from the observed cosine of the angle to the line-of-sight μ_o.\n\nThis transformation accounts for anisotropic effects, likely redshift-space distortions (RSD) or anisotropic cosmological scaling, parameterized by F.\n\nArguments\n\nμ_o: The observed cosine of the angle to the line-of-sight (scalar).\nF: A parameter related to parallel anisotropic scaling (often the growth rate f divided by the anisotropic scaling parameter q_parallel).\n\nReturns\n\nThe calculated true cosine of the angle to the line-of-sight μ (scalar).\n\nFormula\n\nThe formula used is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o::Array, F): Method for an array of observed values.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._μ_true-Tuple{Array, Any}","page":"Internal API","title":"Effort._μ_true","text":"_μ_true(μ_o::Array, F)\n\nCalculates the true (physical) cosine of the angle to the line-of-sight μ for an array of observed cosines of the angle to the line-of-sight μ_o.\n\nThis method applies the transformation from observed to true angle cosine element-wise, accounting for anisotropic effects parameterized by F.\n\nArguments\n\nμ_o: An array of observed cosines of the angle to the line-of-sight.\nF: A parameter related to parallel anisotropic scaling.\n\nReturns\n\nAn array containing the calculated true cosines of the angle to the line-of-sight μ.\n\nDetails\n\nThe function calculates μ for each value in the input array μ_o using a formula derived from anisotropic scaling. Broadcasting (@.) is used to apply the calculation element-wise.\n\nFormula\n\nThe underlying transformation for each μ_o is:\n\nmu = fracmu_oF sqrt1 + mu_o^2 left(frac1F^2 - 1right)\n\nSee Also\n\n_μ_true(μ_o, F): Method for a scalar observed value.\n_k_true: Calculates the true wavenumber.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._P_obs","page":"Internal API","title":"Effort._P_obs","text":"_P_obs(k_o, μ_o, q_par, q_perp, Int_Mono, Int_Quad, Int_Hexa)\n\nCalculates the observed power spectrum P_textobs(k_o mu_o) at a given observed wavenumber k_o and observed cosine of the angle to the line-of-sight μ_o.\n\nThis function transforms the observed coordinates to true (physical) coordinates, calculates the true power spectrum using provided interpolants for the multipole moments, and applies the appropriate scaling factor due to anisotropic effects.\n\nArguments\n\nk_o: The observed wavenumber.\nμ_o: The observed cosine of the angle to the line-of-sight.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\nInt_Mono: An interpolation function for the monopole moment I_0(k) in true k.\nInt_Quad: An interpolation function for the quadrupole moment I_2(k) in true k.\nInt_Hexa: An interpolation function for the hexadecapole moment I_4(k) in true k.\n\nReturns\n\nThe value of the observed power spectrum P_textobs(k_o mu_o).\n\nDetails\n\nThe observed coordinates (k_o mu_o) are transformed to true coordinates (k_t mu_t) using the _k_true and _μ_true functions, with F = q_parallel  q_perp. The true power spectrum P(k_t mu_t) is then reconstructed using _Pkμ and the provided multipole interpolants. Finally, the result is scaled by 1  (q_parallel q_perp^2).\n\nFormula\n\nThe formula used is:\n\nP_textobs(k_o mu_o) = frac1q_parallel q_perp^2 P(k_t mu_t)\n\nwhere\n\nk_t = text_k_true(k_o mu_o q_perp F)\n\nmath \\mut = \\text{μtrue}(\\muo, F)\n\nand\n\nmath F = q\\parallel / q\\perp ```\n\nSee Also\n\n_k_true: Transforms observed wavenumber to true wavenumber.\n_μ_true: Transforms observed angle cosine to true angle cosine.\n_Pkμ: Reconstructs the true power spectrum from multipole moments.\ninterp_Pℓs: Creates the multipole interpolants.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.interp_Pℓs","page":"Internal API","title":"Effort.interp_Pℓs","text":"interp_Pℓs(Mono_array, Quad_array, Hexa_array, k_grid)\n\nCreates interpolation functions for the monopole, quadrupole, and hexadecapole moments of the power spectrum.\n\nThese interpolants can then be used to efficiently evaluate the multipole moments at arbitrary wavenumbers k.\n\nArguments\n\nMono_array: An array containing the values of the monopole moment I_0(k).\nQuad_array: An array containing the values of the quadrupole moment I_2(k).\nHexa_array: An array containing the values of the hexadecapole moment I_4(k).\nk_grid: An array containing the corresponding wavenumber k values for the multipole arrays.\n\nReturns\n\nA tuple containing three interpolation functions: (Int_Mono, Int_Quad, Int_Hexa).\n\nDetails\n\nThe function uses AkimaInterpolation from the Interpolations.jl package to create the interpolants. Extrapolation is set to ExtrapolationType.Extension, which means the interpolant will use the nearest data points to extrapolate outside the provided k_grid range. Note that extrapolation can sometimes introduce errors.\n\nSee Also\n\n_Pkμ: Uses the interpolation functions to reconstruct the anisotropic power spectrum.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort.apply_AP_check-Tuple{Array, Array, Array, Array, Array, Any, Any}","page":"Internal API","title":"Effort.apply_AP_check","text":"apply_AP_check(k_input::Array, k_output::Array, Mono_array::Array, Quad_array::Array, Hexa_array::Array, q_par, q_perp)\n\nCalculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid k_output, from arrays of true multipole moments provided on an input wavenumber grid k_input, using numerical integration.\n\nThis is a check version, intended for verifying results from faster methods. It is significantly slower due to the use of numerical integration over the angle μ.\n\nArguments\n\nk_input: An array of wavenumber values on which the input true multipole moments (Mono_array, Quad_array, Hexa_array) are defined.\nk_output: An array of observed wavenumber values at which to calculate the output observed multipoles.\nMono_array: An array containing the values of the true monopole moment I_0(k) on the k_input grid.\nQuad_array: An array containing the values of the true quadrupole moment I_2(k) on the k_input grid.\nHexa_array: An array containing the values of the true hexadecapole moment I_4(k) on the k_input grid.\nq_par: A parameter related to parallel anisotropic scaling.\nq_perp: A parameter related to perpendicular anisotropic scaling.\n\nReturns\n\nA tuple (P0_obs, P2_obs, P4_obs), where each element is an array containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the wavenumbers in k_output.\n\nDetails\n\nThis method first creates interpolation functions for the true multipole moments using interp_Pℓs based on the k_input grid. It then calls the core apply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp) method, passing k_output as the grid at which to calculate the observed multipoles.\n\nThis function is a slower check implementation and should not be used in performance-critical code.\n\nFormula\n\nThe observed multipole moments are calculated using the formula:\n\nP_ell(k_o) = (2ell + 1) int_0^1 P_textobs(k_o mu_o) mathcalL_ell(mu_o) dmu_o\n\nfor ell in 0 2 4. The observed power spectrum P_textobs(k_o mu_o) is calculated using _P_obs(k_o, μ_o, q_par, q_perp, int_Mono, int_Quad, int_Hexa).\n\nSee Also\n\napply_AP_check(k_grid, int_Mono, int_Quad, int_Hexa, q_par, q_perp): The core method performing the integration.\ninterp_Pℓs: Creates the interpolation functions for the true multipoles.\n_P_obs: Calculates the observed power spectrum.\n\n\n\n\n\n","category":"method"},{"location":"api_internal/#Effort._Pk_recon","page":"Internal API","title":"Effort._Pk_recon","text":"_Pk_recon(mono::Matrix, quad::Matrix, hexa::Matrix, l0, l2, l4)\n\nReconstructs the anisotropic power spectrum P(k mu) on a grid of wavenumbers k and cosines of the angle to the line-of-sight μ, using matrices of its Legendre multipole moments and vectors of Legendre polynomial values.\n\nThis function is designed to efficiently reconstruct the 2D power spectrum for multiple k and μ values simultaneously, assuming the multipole moments are provided as matrices (e.g., N_k x 1) and Legendre polynomials as vectors (e.g., N_μ).\n\nArguments\n\nmono: A matrix containing the monopole moment I_0(k) values (expected dimensions N_k x 1).\nquad: A matrix containing the quadrupole moment I_2(k) values (expected dimensions N_k x 1).\nhexa: A matrix containing the hexadecapole moment I_4(k) values (expected dimensions N_k x 1).\nl0: A vector containing the 0th order Legendre polynomial mathcalL_0(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl2: A vector containing the 2nd order Legendre polynomial mathcalL_2(mu) values evaluated at the desired μ values (expected dimensions N_μ).\nl4: A vector containing the 4th order Legendre polynomial mathcalL_4(mu) values evaluated at the desired μ values (expected dimensions N_μ).\n\nReturns\n\nA matrix representing the anisotropic power spectrum P(k mu) on the N_k x N_μ grid.\n\nDetails\n\nThe function reconstructs the anisotropic power spectrum using the formula that sums the multipole moments multiplied by the corresponding Legendre polynomials. The matrix and vector operations are broadcast to calculate the result for all combinations of input k (from the rows of the moment matrices) and μ (from the elements of the Legendre polynomial vectors).\n\nFormula\n\nThe formula used for each element (i j) of the output matrix (corresponding to the i-th wavenumber and j-th angle cosine) is:\n\nP(k_i mu_j) = I_0(k_i) mathcalL_0(mu_j) + I_2(k_i) mathcalL_2(mu_j) + I_4(k_i) mathcalL_4(mu_j)\n\nSee Also\n\n_Pkμ: Reconstructs P(k mu) for single k and μ.\n_Legendre_0, _Legendre_2, _Legendre_4: Calculate the Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Utils","page":"Internal API","title":"Utils","text":"","category":"section"},{"location":"api_internal/","page":"Internal API","title":"Internal API","text":"Effort._transformed_weights\nEffort._Legendre_0\nEffort._Legendre_2\nEffort._Legendre_4\nEffort._cubic_spline\nEffort._quadratic_spline\nEffort._akima_spline","category":"page"},{"location":"api_internal/#Effort._transformed_weights","page":"Internal API","title":"Effort._transformed_weights","text":"_transformed_weights(quadrature_rule, order, a, b)\n\nTransforms the points and weights of a standard quadrature rule from the interval [-1, 1] to a specified interval [a, b].\n\nThis is a utility function used to adapt standard quadrature rules (like Gauss-Legendre) for numerical integration over arbitrary intervals [a, b].\n\nArguments\n\nquadrature_rule: A function that takes an order and returns a tuple (points, weights)                    for the standard interval [-1, 1].\norder: The order of the quadrature rule (number of points).\na: The lower bound of the target interval.\nb: The upper bound of the target interval.\n\nReturns\n\nA tuple (transformed_points, transformed_weights) for the interval [a, b].\n\nDetails\n\nThe transformation is applied to the standard points x_i^textstd and weights w_i^textstd obtained from the quadrature_rule:\n\nTransformed points: x_i = fracb - a2 x_i^textstd + fracb + a2\nTransformed weights: w_i = fracb - a2 w_i^textstd\n\nFormula\n\nThe transformation formulas are: Points: x_i = fracb - a2 x_i^textstd + fracb + a2 Weights: w_i = fracb - a2 w_i^textstd\n\nSee Also\n\n_r̃_z: An example function that uses this utility for numerical integration.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_0","page":"Internal API","title":"Effort._Legendre_0","text":"_Legendre_0(x)\n\nCalculates the 0th order Legendre polynomial, mathcalL_0(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 0th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 0th order Legendre polynomial is:\n\nmathcalL_0(x) = 1\n\nSee Also\n\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_2","page":"Internal API","title":"Effort._Legendre_2","text":"_Legendre_2(x)\n\nCalculates the 2nd order Legendre polynomial, mathcalL_2(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 2nd order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 2nd order Legendre polynomial is:\n\nmathcalL_2(x) = frac12 (3x^2 - 1)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_4: Calculates the 4th order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._Legendre_4","page":"Internal API","title":"Effort._Legendre_4","text":"_Legendre_4(x)\n\nCalculates the 4th order Legendre polynomial, mathcalL_4(x).\n\nArguments\n\nx: The input value (typically the cosine of an angle, -1 ≤ x ≤ 1).\n\nReturns\n\nThe value of the 4th order Legendre polynomial evaluated at x.\n\nFormula\n\nThe formula for the 4th order Legendre polynomial is:\n\nmathcalL_4(x) = frac18 (35x^4 - 30x^2 + 3)\n\nSee Also\n\n_Legendre_0: Calculates the 0th order Legendre polynomial.\n_Legendre_2: Calculates the 2nd order Legendre polynomial.\n_Pkμ: A function that uses Legendre polynomials.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._cubic_spline","page":"Internal API","title":"Effort._cubic_spline","text":"_cubic_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply a cubic spline interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating a CubicSpline interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.CubicSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates a cubic spline interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.CubicSpline: The underlying interpolation function.\n_quadratic_spline: Wrapper for quadratic spline interpolation.\n_akima_spline: Wrapper for Akima interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._quadratic_spline","page":"Internal API","title":"Effort._quadratic_spline","text":"_quadratic_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply a quadratic spline interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating a QuadraticSpline interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.QuadraticSpline(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates a quadratic spline interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.QuadraticSpline: The underlying interpolation function.\n_cubic_spline: Wrapper for cubic spline interpolation.\n_akima_spline: Wrapper for Akima interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api_internal/#Effort._akima_spline","page":"Internal API","title":"Effort._akima_spline","text":"_akima_spline(u, t, new_t::AbstractArray)\n\nA convenience wrapper to create and apply an Akima interpolation using DataInterpolations.jl.\n\nThis function simplifies the process of creating an AkimaInterpolation interpolant for the data (u, t) and evaluating it at the points new_t.\n\nArguments\n\nu: An array of data values.\nt: An array of data points corresponding to u.\nnew_t: An array of points at which to interpolate.\n\nReturns\n\nAn array of interpolated values corresponding to new_t.\n\nDetails\n\nThis function is a convenience wrapper around DataInterpolations.AkimaInterpolation(u, t; extrapolation=ExtrapolationType.Extension).(new_t). It creates an Akima interpolant with extrapolation enabled using ExtrapolationType.Extension and immediately evaluates it at all points in new_t.\n\nSee Also\n\nDataInterpolations.AkimaInterpolation: The underlying interpolation function.\n_cubic_spline: Wrapper for cubic spline interpolation.\n_quadratic_spline: Wrapper for quadratic spline interpolation.\n\n\n\n\n\n","category":"function"},{"location":"#Effort.jl","page":"Home","title":"Effort.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is a Julia package designed to emulate the computation of the Effective Field Theory of Large Scale Structure, as computed by PyBird. An emulator is a surrogate model, a computational technique that can mimick the behaviour of computationally expensive functions, with a speedup of several orders of magnitude.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example page shows how to use Effort, while showing its computational performance.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marco Bonici, PostDoctoral Researcher at Waterloo Centre for Astrophysics\nGuido D'Amico, Associate Professor at Università Degli Studi di Parma","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Free usage of the software in this repository is provided, given that you cite our release paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Bonici, G. D'Amico, J. Bel, C. Carbone, Effort.jl: a fast and differentiable emulator for the Effective Field Theory of the Large Scale Structure of the Universe","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code has been used in the following publications:","category":"page"},{"location":"","page":"Home","title":"Home","text":"H. Zhang, M. Bonici, A. Rocher, W. J. Percival, A. de Mattia, et al., Enhancing DESI DR1 Full-Shape analyses using HOD-informed priors\nH. Zhang, M. Bonici, G. D'Amico, S. Paradiso, W. J. Percival, HOD-informed prior for EFT-based full-shape analyses of LSS\nS. Paradiso, M. Bonici, M. Chen, W. J. Percival, G. D'Amico, H. Zhang, G. McGee, Reducing nuisance prior sensitivity via non-linear reparameterization, with application to EFT analyses of large-scale structure\nA. Baleato Lizancos, U. Seljak, M. Karamanis, M. Bonici, S. Ferraro, Selecting samples of galaxies with fewer Fingers-of-God","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effort is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"using Plots; gr()\nPlots.reset_defaults()\nusing BenchmarkTools\ndefault(palette = palette(:tab10))\nbenchmark = BenchmarkTools.load(\"./assets/effort_benchmark.json\")\nnew_benchmark = BenchmarkTools.load(\"./assets/new_effort.json\")","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In order to use Effort.jl you need a trained emulator. There are two different categories of trained emulators:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"single component emulators (e.g.  P_11, P_mathrmloop, P_mathrmct)\ncomplete emulators, containing all the three different component emulators","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In this section we are going to show how to:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"obtain a multipole power spectrum, using a trained emulator\napply the Alcock-Paczyński effect\ncompute stochastic term contribution","category":"page"},{"location":"example/#Basic-usage","page":"Example","title":"Basic usage","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Let us show how to use Effort.jl to compute Power Spectrum Multipoles.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"First of all, we need some trained emulators, then we can use the Effort.get_Pℓ function","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Effort.get_Pℓ","category":"page"},{"location":"example/#Effort.get_Pℓ","page":"Example","title":"Effort.get_Pℓ","text":"get_Pℓ(cosmology::Array, D, bs::Array, cosmoemu::AbstractPℓEmulators)\n\nCompute the Pℓ array given the cosmological parameters array cosmology, the bias array bs, the growth factor D and an AbstractEmulator.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Example","title":"Example","text":"info: Trained emulators\nRight now we do not provide any emulator, but with the paper publication we will release several trained emulators on Zenodo.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nPct_comp_array = Effort.compute_component(input_test, Pct_Mono_emu) #compute the components of Pct without the bias\nPct_array_Effort = Array{Float64}(zeros(length(Pct_comp_array[1,:]))) #allocate final array\nEffort.bias_multiplication!(Pct_array_Effort, bct, Pct_comp_array) #components multiplied by bias\nEffort.get_Pℓ(input_test, bs, f, Pℓ_Mono_emu) # whole multipole computation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Here we are using a ComponentEmulator, which can compute one of the components as predicted by PyBird, and a MultipoleEmulator, which emulates an entire multipole.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This computation is quite fast: a benchmark performed locally, gives the following result for a multipole computation","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"benchmark[1][\"Effort\"][\"Monopole\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result of these computations look like this (Image: effort)","category":"page"},{"location":"example/#Alcock-Paczyński-effect","page":"Example","title":"Alcock-Paczyński effect","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Here we are going to write down the equations related to the AP effect, following the Ivanov et al. (2019) and D'Amico et al. (2020) notation.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In particular, we are going to use:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"rmref, for the quantities evaluated in the reference cosmology used to perform the measurements\nrmtrue, for the quantities evaluated in the true cosmology used to perform the theoretical predictions\nmathrmobs, for the observed quantities after applying the AP effect","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The wavenumbers parallel and perpendicular to the line of sight (k^mathrmtrue_parallel k^mathrmtrue_perp) are related to the ones of the reference cosmology as (k^mathrmref_parallel k^mathrmref_perp) as:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"k_^text ref =q_ k^mathrmtrue_ quad k_perp^mathrmref=q_perp k^mathrmtrue_perp","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the distortion parameters are defined by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"q_=fracD^mathrmtrue_A(z) H^mathrmtrue(z=0)D_A^mathrmref(z) H^mathrmref(z=0) quad q_perp=fracH^mathrmref(z)  H^mathrmref(z=0)H^mathrmtrue(z)  H^mathrmtrue(z=0)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where D^A, H are the angular diameter distance and Hubble parameter, respectively. In terms of these parameters, the power spectrum multipoles in the reference cosmology is given by the multipole projection integral","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"P_ell mathrmAP(k)=frac2 ell+12 int_-1^1 d mu_mathrmobs P_mathrmobsleft(k_mathrmobs mu_mathrmobsright) cdot mathcalP_ellleft(mu_mathrmobsright)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The observed P_mathrmobsleft(k_mathrmobs mu_mathrmobsright), when including the AP effect, is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"P_mathrmobsleft(k_mathrmobs mu_mathrmobsright)= frac1q_ q_perp^2 cdot P_gleft(k_text true leftk_mathrmobs mu_mathrmobsright mu_text true leftk_text obs  mu_mathrmobsrightright)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In the Effort.jl workflow, the Alcock-Paczyński (AP) effect can be included in two different ways:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"by training the emulators using spectra where the AP effect has already been applied\nby using standard trained emulators and applying analitycally the AP effect","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"While the former approach is computationally faster (there is no overhead from the NN point-of-view), the latter is more flexible, since the reference cosmology for the AP effect computation can be changed at runtime.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Regarding the second approach, the most important choice regards the algorithm employed to compute the multipole projection integral. Here we implement two different approaches, based on","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"QuadGK.jl. This approach is the most precise, since it uses an adaptive method to compute the integral.\nFastGaussQuadrature.jl. This approach is the fastest, since we are going to employ only 5 points to compute the integral, taking advantage of the Gauss-Lobatto quadrature rule.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In order to understand why it is possible to use few points to evaluate the AP projection integral, it is intructive to plot the mu dependence of the integrand","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: mu_dependence)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The ell=4 integrand, the most complicated one, can be accurately fit with a n=8 polynomial","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: polyfit_residuals)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since a n Gauss-Lobatto rule can integrate exactly 2n  3 degree polynomials,  we expect that a GL rule with 10 points can perform the integral with high precision.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we can show how to use Effort.jl to compute the AP effect using the GK adaptive integration","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nEffort.apply_AP_check(k_test, k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP_check\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"As said, this is precise but a bit expensive from a computational point of view. What about Gauss-Lobatto?","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import Effort\nEffort.apply_AP(k_test, k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This is 200 times faster than the adaptive integration, but is also very accurate! A comparison with the GK-based rule shows a percentual relative difference of about 10^-11 for the Hexadecapole, with a higher precision for the other two multipoles.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: gk_gl_residuals)","category":"page"},{"location":"example/#Growth-factor","page":"Example","title":"Growth factor","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"A quantity required to compute EFTofLSS observables is the growth rate, f. While other emulator packages employ an emulator also for f (or equivalently emulate the growth factor D), we choose a different approach, using the DiffEq.jl library to efficiently solve the equation for the growth factor, as written in Bayer, Banerjee & Feng (2021)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(a)+left(2+fracE(a)E(a)right)D(a)=frac32Omega_m(a)D(a)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where E(a) is the adimensional Hubble factor, whose expression is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"E(a)=leftOmega_gamma 0 a^-4+Omega_c 0 a^-3+Omega_nu(a) E^2(a)+Omega_mathrmDE(a)right^1  2","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since we start solving the equation deep in the matter dominated era, when D(a)sim a, we can set as initial conditions","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(z_i) = a_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"D(z_i)=a_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In E(a), we precisely take into account radiation, non-relativistic matter, massive neutrinos, evolving Dark Energy. Regarding massive neutrinos, their energy density is given by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Omega_nu(a) E^2(a)=frac15pi^4 Gamma_nu^4 fracOmega_gamma 0a^4 sum_j=1^N_nu mathcalFleft(fracm_j ak_B T_nu 0right)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"with","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mathcalF(y) equiv int_0^infty d x fracx^2 sqrtx^2+y^21+e^x","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Regarding Dark Energy, its contribution to the Hubble is","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Omega_mathrmDE(a)=Omega_mathrmDE0(1+z)^3left(1+w_0+w_aright) e^-3 w_a z (1+z)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Solving the previous equation is quite fast, as the benchmark shows","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@benchmark Effort._D_z($z, $ΩM, $h)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"Growth\"] # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result is also quite accurate; here is a check against the CLASS computation both for the growth factor and the growth rate","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: growth_check_class)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Since the final goal is to embedd Effort in bayesian analysis pipelines which need gradient computations, emphasis has been put on its compatibility with AD tools such as ForwardDiff and Enzyme. In particular, for the ODE solution, this is guaranteed by the SciMLSensitivity stack.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Comparing with Fig. 5 of Donald-McCann et al. (2021), we see that the error is similar to the one they obtained, with the advantage that we don't have the restriction of an emulation range. However, if required, we may as well include an emulator for D(z) and f(z).","category":"page"},{"location":"example/#Automatic-Differentiation","page":"Example","title":"Automatic Differentiation","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Great care has been devoted to ensure that Effort is compatible with AD systems. Here, in particular, we are going to show the performance of backward-AD as implemented in Zygote.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@benchmark Zygote.gradient(k_test->sum(Effort.apply_AP(k_test, Mono_Effort, Quad_Effort, Hexa_Effort,  q_par, q_perp)), k_test)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"new_benchmark[1][\"Effort\"][\"AP & Zygote\"] # hide","category":"page"}]
}
