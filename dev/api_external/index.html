<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>External API · Effort.jl</title><meta name="title" content="External API · Effort.jl"/><meta property="og:title" content="External API · Effort.jl"/><meta property="twitter:title" content="External API · Effort.jl"/><meta name="description" content="Documentation for Effort.jl."/><meta property="og:description" content="Documentation for Effort.jl."/><meta property="twitter:description" content="Documentation for Effort.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Effort.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Effort.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><span class="tocitem">API Documentation</span><ul><li class="is-active"><a class="tocitem" href>External API</a></li><li><a class="tocitem" href="../api_internal/">Internal API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>External API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>External API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/main/docs/src/api_external.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="External-API"><a class="docs-heading-anchor" href="#External-API">External API</a><a id="External-API-1"></a><a class="docs-heading-anchor-permalink" href="#External-API" title="Permalink"></a></h1><p>This section documents the public functions intended for users.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.q_par_perp-Tuple{Any, AbstractCosmology, AbstractCosmology}" href="#Effort.q_par_perp-Tuple{Any, AbstractCosmology, AbstractCosmology}"><code>Effort.q_par_perp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">q_par_perp(z, cosmo_mcmc::AbstractCosmology, cosmo_ref::AbstractCosmology)</code></pre><p>Calculates the parallel (<code>q_par</code>) and perpendicular (<code>q_perp</code>) Alcock-Paczynski (AP) parameters at a given redshift <code>z</code>, comparing a varying cosmology to a reference cosmology.</p><p>The AP parameters quantify the distortion of observed clustering due to assuming a different cosmology than the true one when converting redshifts and angles to distances.</p><p><strong>Arguments</strong></p><ul><li><code>z</code>: The redshift at which to calculate the AP parameters.</li><li><code>cosmo_mcmc</code>: An <code>AbstractCosmology</code> struct representing the varying cosmology (e.g., from an MCMC chain).</li><li><code>cosmo_ref</code>: An <code>AbstractCosmology</code> struct representing the reference cosmology used for measurements.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(q_par, q_perp)</code> containing the calculated parallel and perpendicular AP parameters at redshift <code>z</code>.</p><p><strong>Details</strong></p><p>The parallel AP parameter <code>q_par</code> is the ratio of the Hubble parameter in the reference cosmology to that in the varying cosmology. The perpendicular AP parameter <code>q_perp</code> is the ratio of the conformal angular diameter distance in the varying cosmology to that in the reference cosmology.</p><p><strong>Formula</strong></p><p>The formulas for the Alcock-Paczynski parameters are:</p><p class="math-container">\[q_\parallel(z) = \frac{E_{\text{ref}}(z)}{E_{\text{mcmc}}(z)}\]</p><p class="math-container">\[q_\perp(z) = \frac{\tilde{d}_{A,\text{mcmc}}(z)}{\tilde{d}_{A,\text{ref}}(z)}\]</p><p>where <span>$E(z)$</span> is the normalized Hubble parameter and <span>$\tilde{d}_A(z)$</span> is the conformal angular diameter distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/aa711d5ad2140b517eb3159050225313d69fcf61/src/projection.jl#L341-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.apply_AP" href="#Effort.apply_AP"><code>Effort.apply_AP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp; n_GL_points=8)</code></pre><p>Calculates the observed power spectrum multipole moments (monopole, quadrupole, hexadecapole) on a given observed wavenumber grid <code>k_output</code>, using arrays of true multipole moments provided on an input wavenumber grid <code>k_input</code>, and employing Gauss-Lobatto quadrature.</p><p>This is the <strong>standard, faster implementation</strong> for applying the Alcock-Paczynski (AP) effect to the power spectrum multipoles, designed for performance compared to the check version using generic numerical integration.</p><p><strong>Arguments</strong></p><ul><li><code>k_input</code>: A vector of wavenumber values on which the input true multipole moments (<code>mono</code>, <code>quad</code>, <code>hexa</code>) are defined.</li><li><code>k_output</code>: A vector of observed wavenumber values at which to calculate the output observed multipoles.</li><li><code>mono</code>: A vector containing the values of the true monopole moment <span>$I_0(k)$</span> on the <code>k_input</code> grid.</li><li><code>quad</code>: A vector containing the values of the true quadrupole moment <span>$I_2(k)$</span> on the <code>k_input</code> grid.</li><li><code>hexa</code>: A vector containing the values of the true hexadecapole moment <span>$I_4(k)$</span> on the <code>k_input</code> grid.</li><li><code>q_par</code>: A parameter related to parallel anisotropic scaling.</li><li><code>q_perp</code>: A parameter related to perpendicular anisotropic scaling.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_GL_points</code>: The number of Gauss-Lobatto points to use for the integration over <code>μ</code>. The actual number of nodes used corresponds to <code>2 * n_GL_points</code>. Defaults to 8.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(P0_obs, P2_obs, P4_obs)</code>, where each element is a vector containing the calculated observed monopole, quadrupole, and hexadecapole moments respectively, evaluated at the observed wavenumbers in <code>k_output</code>.</p><p><strong>Details</strong></p><p>The function applies the AP and RSD effects by integrating the observed anisotropic power spectrum <span>$P_{\text{obs}}(k_o, \mu_o)$</span> over the observed cosine of the angle to the line-of-sight <span>$\mu_o \in [0, 1]$</span> (assuming symmetry for even multipoles), weighted by the corresponding Legendre polynomial <span>$\mathcal{L}_\ell(\mu_o)$</span>.</p><p>The process involves:</p><ol><li>Determine Gauss-Lobatto nodes and weights for the interval <code>[0, 1]</code>.</li><li>For each observed wavenumber <code>k_o</code> in the input <code>k_output</code> array and each <code>μ_o</code> node: a. Calculate the true wavenumber <span>$k_t(k_o, \mu_o)$</span> using <a href="../api_internal/#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>. b. Calculate the true angle cosine <span>$\mu_t(\mu_o)$</span> using <a href="../api_internal/#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>. c. Interpolate the true multipole moments <span>$I_\ell(k_t)$</span> using <a href="../api_internal/#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>_akima_interpolation</code></a>, interpolating from the <code>k_input</code> grid to the new <code>k_t</code> values. d. Calculate the true Legendre polynomials <span>$\mathcal{L}_\ell(\mu_t)$</span> using <a href="../api_internal/#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="../api_internal/#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="../api_internal/#Effort._Legendre_4"><code>_Legendre_4</code></a>. e. Reconstruct the true power spectrum <span>$P(k_t, \mu_t)$</span> using <a href="../api_internal/#Effort._Pk_recon"><code>_Pk_recon</code></a>. f. Calculate the observed power spectrum <span>$P_{\text{obs}}(k_o, \mu_o) = P(k_t, \mu_t) / (q_\parallel q_\perp^2)$</span>.</li><li>Perform the weighted sum (quadrature) over the <code>μ_o</code> nodes to get the observed multipoles <span>$P_\ell(k_o)$</span> on the <code>k_output</code> grid.</li></ol><p>This function is the <strong>standard, performant implementation</strong> for applying AP compared to the slower <a href="../api_internal/#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check</code></a>.</p><p><strong>Formula</strong></p><p>The observed multipole moments are calculated using the formula:</p><p class="math-container">\[P_\ell(k_o) = (2\ell + 1) \int_{0}^1 P_{\text{obs}}(k_o, \mu_o) \mathcal{L}_\ell(\mu_o) d\mu_o\]</p><p>for <span>$\ell \in \{0, 2, 4\}$</span>. The integral is approximated using Gauss-Lobatto quadrature.</p><p><strong>See Also</strong></p><ul><li><a href="../api_internal/#Effort.apply_AP_check-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP_check</code></a>: The slower, check version using generic numerical integration.</li><li><a href="../api_internal/#Effort._k_true-NTuple{4, Any}"><code>_k_true</code></a>: Transforms observed wavenumber to true wavenumber.</li><li><a href="../api_internal/#Effort._μ_true-Tuple{Any, Any}"><code>_μ_true</code></a>: Transforms observed angle cosine to true angle cosine.</li><li><a href="../api_internal/#Effort._Legendre_0"><code>_Legendre_0</code></a>, <a href="../api_internal/#Effort._Legendre_2"><code>_Legendre_2</code></a>, <a href="../api_internal/#Effort._Legendre_4"><code>_Legendre_4</code></a>: Calculate the Legendre polynomials.</li><li><a href="../api_internal/#Effort._akima_interpolation-Tuple{Any, Any, Any}"><code>_akima_interpolation</code></a>: Interpolates the true multipole moments.</li><li><a href="../api_internal/#Effort._Pk_recon"><code>_Pk_recon</code></a>: Reconstructs the true power spectrum on a grid.</li><li><code>gausslobatto</code>: Function used to get quadrature nodes and weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/aa711d5ad2140b517eb3159050225313d69fcf61/src/projection.jl#L432-L494">source</a></section><section><div><pre><code class="language-julia hljs">apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractMatrix, quad::AbstractMatrix, hexa::AbstractMatrix, q_par, q_perp; n_GL_points=8)</code></pre><p>Batch version of <code>apply_AP</code> for processing multiple columns simultaneously using optimized matrix Akima interpolation.</p><p>This method applies the Alcock-Paczynski effect to multiple sets of multipole moments (e.g., multiple Jacobian columns or parameter variations) in a single call. It leverages the optimized matrix Akima spline implementation to interpolate all columns at once, providing significant performance improvements over column-by-column processing.</p><p><strong>Arguments</strong></p><ul><li><code>k_input::AbstractVector</code>: Input wavenumber grid.</li><li><code>k_output::AbstractVector</code>: Output wavenumber grid.</li><li><code>mono::AbstractMatrix</code>: Monopole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>quad::AbstractMatrix</code>: Quadrupole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>hexa::AbstractMatrix</code>: Hexadecapole moments with shape <code>(n_k, n_cols)</code>.</li><li><code>q_par</code>: Parallel AP parameter.</li><li><code>q_perp</code>: Perpendicular AP parameter.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_GL_points::Int</code>: Number of Gauss-Lobatto points. Default: 8.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(mono_AP, quad_AP, hexa_AP)</code> where each is a matrix of shape <code>(n_k_output, n_cols)</code> containing the AP-corrected multipoles for all input columns.</p><p><strong>Details</strong></p><p>This optimized implementation uses matrix Akima interpolation to process all columns simultaneously rather than iterating column-by-column. For N columns, this reduces 3×N Akima calls to just 3 matrix Akima calls, providing a ~2-3× speedup.</p><p>This is particularly useful for computing Jacobians where each column represents the derivative with respect to a different parameter (typically 11 bias parameters).</p><p><strong>Performance</strong></p><p>For typical DESI-like scenarios (50 input k-points, 100 output k-points, 11 columns):</p><ul><li>Old implementation: ~6 ms (33 scalar Akima calls)</li><li>New implementation: ~2 ms (3 matrix Akima calls)</li><li>Speedup: ~2.5-3×</li></ul><p><strong>See Also</strong></p><ul><li><a href="../api_internal/#Effort.apply_AP-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Any, Any}"><code>apply_AP(k_input::AbstractVector, k_output::AbstractVector, mono::AbstractVector, quad::AbstractVector, hexa::AbstractVector, q_par, q_perp)</code></a>: Single-column version.</li><li><a href="../api_internal/#Effort._akima_interpolation-Tuple{AbstractMatrix, Any, Any}"><code>_akima_interpolation(u::AbstractMatrix, t, t_new)</code></a>: Optimized matrix Akima interpolation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/aa711d5ad2140b517eb3159050225313d69fcf61/src/projection.jl#L525-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T" href="#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T"><code>Effort.window_convolution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">window_convolution(W::Array{T, 4}, v::Matrix) where {T}</code></pre><p>Applies a 4-dimensional window function or kernel <code>W</code> to a 2-dimensional input matrix <code>v</code>.</p><p>This operation performs a transformation or generalized convolution, summing over the <code>j</code> and <code>l</code> indices of the inputs to produce a 2D result indexed by <code>i</code> and <code>k</code>. This is commonly used in analyses where a 4D kernel relates input data in two dimensions to output data in another two dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: A 4-dimensional array representing the window function or kernel.</li><li><code>v</code>: A 2-dimensional matrix representing the input data.</li></ul><p><strong>Returns</strong></p><p>A 2-dimensional matrix representing the result of the convolution or transformation.</p><p><strong>Details</strong></p><p>The function implements the summation using the <code>@tullio</code> macro, which provides an efficient way to express tensor contractions and generalized convolutions. The operation can be thought of as applying a 4D kernel to a 2D input, resulting in a 2D output.</p><p><strong>Formula</strong></p><p>The operation is defined as:</p><p class="math-container">\[C_{ik} = \sum_{j,l} W_{ijkl} v_{jl}\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}"><code>window_convolution(W::AbstractMatrix, v::AbstractVector)</code></a>: Method for a matrix kernel and vector input.</li></ul><p><strong>References</strong></p><ul><li>The methodology for this type of window measurement is discussed in: <a href="https://arxiv.org/abs/1810.05051">arXiv:1810.05051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/aa711d5ad2140b517eb3159050225313d69fcf61/src/projection.jl#L617-L651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}" href="#Effort.window_convolution-Tuple{AbstractMatrix, AbstractVector}"><code>Effort.window_convolution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">window_convolution(W::AbstractMatrix, v::AbstractVector)</code></pre><p>Performs matrix-vector multiplication, where the matrix <code>W</code> acts as a linear transformation or window applied to the vector input <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: An abstract matrix representing the linear transformation or window.</li><li><code>v</code>: An abstract vector representing the input data.</li></ul><p><strong>Returns</strong></p><p>An abstract vector representing the result of the matrix-vector multiplication.</p><p><strong>Details</strong></p><p>This method is a direct implementation of standard matrix-vector multiplication. It applies the linear transformation defined by matrix <code>W</code> to the vector <code>v</code>.</p><p><strong>Formula</strong></p><p>The operation is defined as:</p><p class="math-container">\[\mathbf{c} = \mathbf{W} \mathbf{v}\]</p><p>or element-wise:</p><p class="math-container">\[c_i = \sum_j W_{ij} v_j\]</p><p><strong>See Also</strong></p><ul><li><a href="#Effort.window_convolution-Union{Tuple{T}, Tuple{Array{T, 4}, Matrix}} where T"><code>window_convolution(W::Array{T, 4}, v::Matrix) where {T}</code></a>: Method for a 4D kernel and matrix input.</li></ul><p><strong>References</strong></p><ul><li>The methodology for this type of window measurement is discussed in: <a href="https://arxiv.org/abs/1810.05051">arXiv:1810.05051</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CosmologicalEmulators/Effort.jl/blob/aa711d5ad2140b517eb3159050225313d69fcf61/src/projection.jl#L656-L688">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Example</a><a class="docs-footer-nextpage" href="../api_internal/">Internal API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 22 October 2025 23:07">Wednesday 22 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
